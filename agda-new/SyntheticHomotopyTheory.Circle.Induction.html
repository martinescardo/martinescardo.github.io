<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SyntheticHomotopyTheory.Circle.Induction</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Tom de Jong, 1-18 March 2021

We show that the induction principle for 𝕊¹ with propositional computation rules
follows from the universal property of 𝕊¹.

This is claimed at the end of Section 6.2 in the HoTT Book and follows from a
general result by Sojakova in her PhD Thesis &quot;Higher Inductive Types as
Homotopy-Initial Algebras&quot; (CMU-CS-16-125). The proof of the general result is
quite complicated (see for instance Lemma 105 in the PhD thesis) and the
development below offers an alternative proof for 𝕊¹.

</a><a id="513" class="Markup">\begin{code}</a>

<a id="527" class="Symbol">{-#</a> <a id="531" class="Keyword">OPTIONS</a> <a id="539" class="Pragma">--safe</a> <a id="546" class="Pragma">--without-K</a> <a id="558" class="Symbol">#-}</a>

<a id="563" class="Keyword">open</a> <a id="568" class="Keyword">import</a> <a id="575" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="588" class="Keyword">open</a> <a id="593" class="Keyword">import</a> <a id="600" href="UF.Base.html" class="Module">UF.Base</a>
<a id="608" class="Keyword">open</a> <a id="613" class="Keyword">import</a> <a id="620" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="629" class="Keyword">open</a> <a id="634" class="Keyword">import</a> <a id="641" href="UF.FunExt.html" class="Module">UF.FunExt</a>
<a id="651" class="Keyword">open</a> <a id="656" class="Keyword">import</a> <a id="663" href="UF.Sets.html" class="Module">UF.Sets</a>
<a id="671" class="Keyword">open</a> <a id="676" class="Keyword">import</a> <a id="683" href="UF.Sets-Properties.html" class="Module">UF.Sets-Properties</a>
<a id="702" class="Keyword">open</a> <a id="707" class="Keyword">import</a> <a id="714" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>

<a id="732" class="Keyword">module</a> <a id="739" href="SyntheticHomotopyTheory.Circle.Induction.html" class="Module">SyntheticHomotopyTheory.Circle.Induction</a> <a id="780" class="Keyword">where</a>

<a id="787" class="Markup">\end{code}</a><a id="797" class="Background">

First some preliminaries on the free loop space.

</a><a id="849" class="Markup">\begin{code}</a>

<a id="𝓛"></a><a id="863" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="865" class="Symbol">:</a> <a id="867" class="Symbol">(</a><a id="868" href="SyntheticHomotopyTheory.Circle.Induction.html#868" class="Bound">X</a> <a id="870" class="Symbol">:</a> <a id="872" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="874" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="876" class="Symbol">)</a> <a id="878" class="Symbol">→</a> <a id="880" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="882" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="884" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="886" href="SyntheticHomotopyTheory.Circle.Induction.html#886" class="Bound">X</a> <a id="888" class="Symbol">=</a> <a id="890" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="892" href="SyntheticHomotopyTheory.Circle.Induction.html#892" class="Bound">x</a> <a id="894" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="896" href="SyntheticHomotopyTheory.Circle.Induction.html#886" class="Bound">X</a> <a id="898" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="900" href="SyntheticHomotopyTheory.Circle.Induction.html#892" class="Bound">x</a> <a id="902" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="904" href="SyntheticHomotopyTheory.Circle.Induction.html#892" class="Bound">x</a>

<a id="𝓛-functor"></a><a id="907" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="917" class="Symbol">:</a> <a id="919" class="Symbol">{</a><a id="920" href="SyntheticHomotopyTheory.Circle.Induction.html#920" class="Bound">X</a> <a id="922" class="Symbol">:</a> <a id="924" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="926" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="928" class="Symbol">}</a> <a id="930" class="Symbol">{</a><a id="931" href="SyntheticHomotopyTheory.Circle.Induction.html#931" class="Bound">Y</a> <a id="933" class="Symbol">:</a> <a id="935" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="937" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="939" class="Symbol">}</a> <a id="941" class="Symbol">(</a><a id="942" href="SyntheticHomotopyTheory.Circle.Induction.html#942" class="Bound">f</a> <a id="944" class="Symbol">:</a> <a id="946" href="SyntheticHomotopyTheory.Circle.Induction.html#920" class="Bound">X</a> <a id="948" class="Symbol">→</a> <a id="950" href="SyntheticHomotopyTheory.Circle.Induction.html#931" class="Bound">Y</a><a id="951" class="Symbol">)</a> <a id="953" class="Symbol">→</a> <a id="955" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="957" href="SyntheticHomotopyTheory.Circle.Induction.html#920" class="Bound">X</a> <a id="959" class="Symbol">→</a> <a id="961" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="963" href="SyntheticHomotopyTheory.Circle.Induction.html#931" class="Bound">Y</a>
<a id="965" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="975" href="SyntheticHomotopyTheory.Circle.Induction.html#975" class="Bound">f</a> <a id="977" class="Symbol">(</a><a id="978" href="SyntheticHomotopyTheory.Circle.Induction.html#978" class="Bound">x</a> <a id="980" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="982" href="SyntheticHomotopyTheory.Circle.Induction.html#982" class="Bound">p</a><a id="983" class="Symbol">)</a> <a id="985" class="Symbol">=</a> <a id="987" href="SyntheticHomotopyTheory.Circle.Induction.html#975" class="Bound">f</a> <a id="989" href="SyntheticHomotopyTheory.Circle.Induction.html#978" class="Bound">x</a> <a id="991" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="993" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="996" href="SyntheticHomotopyTheory.Circle.Induction.html#975" class="Bound">f</a> <a id="998" href="SyntheticHomotopyTheory.Circle.Induction.html#982" class="Bound">p</a>

<a id="𝓛-functor-id"></a><a id="1001" href="SyntheticHomotopyTheory.Circle.Induction.html#1001" class="Function">𝓛-functor-id</a> <a id="1014" class="Symbol">:</a> <a id="1016" class="Symbol">{</a><a id="1017" href="SyntheticHomotopyTheory.Circle.Induction.html#1017" class="Bound">X</a> <a id="1019" class="Symbol">:</a> <a id="1021" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="1023" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1025" class="Symbol">}</a> <a id="1027" class="Symbol">→</a> <a id="1029" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1039" href="MLTT.Pi.html#444" class="Function">id</a> <a id="1042" href="MLTT.Id.html#1889" class="Function Operator">∼</a> <a id="1044" href="MLTT.Pi.html#444" class="Function">id</a> <a id="1047" class="Symbol">{</a><a id="1048" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a><a id="1049" class="Symbol">}</a> <a id="1051" class="Symbol">{</a><a id="1052" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="1054" href="SyntheticHomotopyTheory.Circle.Induction.html#1017" class="Bound">X</a><a id="1055" class="Symbol">}</a>
<a id="1057" href="SyntheticHomotopyTheory.Circle.Induction.html#1001" class="Function">𝓛-functor-id</a> <a id="1070" class="Symbol">{</a><a id="1071" href="SyntheticHomotopyTheory.Circle.Induction.html#1071" class="Bound">𝓤</a><a id="1072" class="Symbol">}</a> <a id="1074" class="Symbol">{</a><a id="1075" href="SyntheticHomotopyTheory.Circle.Induction.html#1075" class="Bound">X</a><a id="1076" class="Symbol">}</a> <a id="1078" class="Symbol">(</a><a id="1079" href="SyntheticHomotopyTheory.Circle.Induction.html#1079" class="Bound">x</a> <a id="1081" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1083" href="SyntheticHomotopyTheory.Circle.Induction.html#1083" class="Bound">p</a><a id="1084" class="Symbol">)</a> <a id="1086" class="Symbol">=</a> <a id="1088" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="1095" class="Symbol">(</a><a id="1096" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1101" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1103" href="SyntheticHomotopyTheory.Circle.Induction.html#1117" class="Function">γ</a> <a id="1105" href="SyntheticHomotopyTheory.Circle.Induction.html#1083" class="Bound">p</a><a id="1106" class="Symbol">)</a>
 <a id="1109" class="Keyword">where</a>
  <a id="1117" href="SyntheticHomotopyTheory.Circle.Induction.html#1117" class="Function">γ</a> <a id="1119" class="Symbol">:</a> <a id="1121" class="Symbol">{</a><a id="1122" href="SyntheticHomotopyTheory.Circle.Induction.html#1122" class="Bound">y</a> <a id="1124" href="SyntheticHomotopyTheory.Circle.Induction.html#1124" class="Bound">z</a> <a id="1126" class="Symbol">:</a> <a id="1128" href="SyntheticHomotopyTheory.Circle.Induction.html#1075" class="Bound">X</a><a id="1129" class="Symbol">}</a> <a id="1131" class="Symbol">(</a><a id="1132" href="SyntheticHomotopyTheory.Circle.Induction.html#1132" class="Bound">q</a> <a id="1134" class="Symbol">:</a> <a id="1136" href="SyntheticHomotopyTheory.Circle.Induction.html#1122" class="Bound">y</a> <a id="1138" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1140" href="SyntheticHomotopyTheory.Circle.Induction.html#1124" class="Bound">z</a><a id="1141" class="Symbol">)</a> <a id="1143" class="Symbol">→</a> <a id="1145" href="MLTT.Id.html#735" class="Function">transport</a> <a id="1155" class="Symbol">(λ</a> <a id="1158" href="SyntheticHomotopyTheory.Circle.Induction.html#1158" class="Bound">-</a> <a id="1160" class="Symbol">→</a> <a id="1162" href="SyntheticHomotopyTheory.Circle.Induction.html#1122" class="Bound">y</a> <a id="1164" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1166" href="SyntheticHomotopyTheory.Circle.Induction.html#1158" class="Bound">-</a><a id="1167" class="Symbol">)</a> <a id="1169" href="SyntheticHomotopyTheory.Circle.Induction.html#1132" class="Bound">q</a> <a id="1171" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1176" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1178" href="SyntheticHomotopyTheory.Circle.Induction.html#1132" class="Bound">q</a>
  <a id="1182" href="SyntheticHomotopyTheory.Circle.Induction.html#1117" class="Function">γ</a> <a id="1184" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1189" class="Symbol">=</a> <a id="1191" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝓛-functor-comp"></a><a id="1197" href="SyntheticHomotopyTheory.Circle.Induction.html#1197" class="Function">𝓛-functor-comp</a> <a id="1212" class="Symbol">:</a> <a id="1214" class="Symbol">{</a><a id="1215" href="SyntheticHomotopyTheory.Circle.Induction.html#1215" class="Bound">X</a> <a id="1217" class="Symbol">:</a> <a id="1219" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="1221" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1223" class="Symbol">}</a> <a id="1225" class="Symbol">{</a><a id="1226" href="SyntheticHomotopyTheory.Circle.Induction.html#1226" class="Bound">Y</a> <a id="1228" class="Symbol">:</a> <a id="1230" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="1232" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1234" class="Symbol">}</a> <a id="1236" class="Symbol">{</a><a id="1237" href="SyntheticHomotopyTheory.Circle.Induction.html#1237" class="Bound">Z</a> <a id="1239" class="Symbol">:</a> <a id="1241" href="MLTT.Universes.html#3838" class="Generalizable">𝓦</a> <a id="1243" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1245" class="Symbol">}</a> <a id="1247" class="Symbol">(</a><a id="1248" href="SyntheticHomotopyTheory.Circle.Induction.html#1248" class="Bound">f</a> <a id="1250" class="Symbol">:</a> <a id="1252" href="SyntheticHomotopyTheory.Circle.Induction.html#1215" class="Bound">X</a> <a id="1254" class="Symbol">→</a> <a id="1256" href="SyntheticHomotopyTheory.Circle.Induction.html#1226" class="Bound">Y</a><a id="1257" class="Symbol">)</a> <a id="1259" class="Symbol">(</a><a id="1260" href="SyntheticHomotopyTheory.Circle.Induction.html#1260" class="Bound">g</a> <a id="1262" class="Symbol">:</a> <a id="1264" href="SyntheticHomotopyTheory.Circle.Induction.html#1226" class="Bound">Y</a> <a id="1266" class="Symbol">→</a> <a id="1268" href="SyntheticHomotopyTheory.Circle.Induction.html#1237" class="Bound">Z</a><a id="1269" class="Symbol">)</a>
               <a id="1286" class="Symbol">→</a> <a id="1288" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1298" href="SyntheticHomotopyTheory.Circle.Induction.html#1260" class="Bound">g</a> <a id="1300" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="1302" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1312" href="SyntheticHomotopyTheory.Circle.Induction.html#1248" class="Bound">f</a> <a id="1314" href="MLTT.Id.html#1889" class="Function Operator">∼</a> <a id="1316" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1326" class="Symbol">(</a><a id="1327" href="SyntheticHomotopyTheory.Circle.Induction.html#1260" class="Bound">g</a> <a id="1329" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="1331" href="SyntheticHomotopyTheory.Circle.Induction.html#1248" class="Bound">f</a><a id="1332" class="Symbol">)</a>
<a id="1334" href="SyntheticHomotopyTheory.Circle.Induction.html#1197" class="Function">𝓛-functor-comp</a> <a id="1349" href="SyntheticHomotopyTheory.Circle.Induction.html#1349" class="Bound">f</a> <a id="1351" href="SyntheticHomotopyTheory.Circle.Induction.html#1351" class="Bound">g</a> <a id="1353" class="Symbol">(</a><a id="1354" href="SyntheticHomotopyTheory.Circle.Induction.html#1354" class="Bound">x</a> <a id="1356" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1358" href="SyntheticHomotopyTheory.Circle.Induction.html#1358" class="Bound">p</a><a id="1359" class="Symbol">)</a> <a id="1361" class="Symbol">=</a> <a id="1363" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="1370" class="Symbol">(</a><a id="1371" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1376" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1378" class="Symbol">(</a><a id="1379" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="1385" href="SyntheticHomotopyTheory.Circle.Induction.html#1349" class="Bound">f</a> <a id="1387" href="SyntheticHomotopyTheory.Circle.Induction.html#1351" class="Bound">g</a> <a id="1389" href="SyntheticHomotopyTheory.Circle.Induction.html#1358" class="Bound">p</a><a id="1390" class="Symbol">))</a>

<a id="ap-𝓛-functor-lemma"></a><a id="1394" href="SyntheticHomotopyTheory.Circle.Induction.html#1394" class="Function">ap-𝓛-functor-lemma</a> <a id="1413" class="Symbol">:</a> <a id="1415" class="Symbol">{</a><a id="1416" href="SyntheticHomotopyTheory.Circle.Induction.html#1416" class="Bound">A</a> <a id="1418" class="Symbol">:</a> <a id="1420" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="1422" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1424" class="Symbol">}</a> <a id="1426" class="Symbol">{</a><a id="1427" href="SyntheticHomotopyTheory.Circle.Induction.html#1427" class="Bound">B</a> <a id="1429" class="Symbol">:</a> <a id="1431" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="1433" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1435" class="Symbol">}</a> <a id="1437" class="Symbol">(</a><a id="1438" href="SyntheticHomotopyTheory.Circle.Induction.html#1438" class="Bound">f</a> <a id="1440" href="SyntheticHomotopyTheory.Circle.Induction.html#1440" class="Bound">g</a> <a id="1442" class="Symbol">:</a> <a id="1444" href="SyntheticHomotopyTheory.Circle.Induction.html#1416" class="Bound">A</a> <a id="1446" class="Symbol">→</a> <a id="1448" href="SyntheticHomotopyTheory.Circle.Induction.html#1427" class="Bound">B</a><a id="1449" class="Symbol">)</a>
                     <a id="1472" class="Symbol">{</a><a id="1473" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a> <a id="1475" class="Symbol">:</a> <a id="1477" href="SyntheticHomotopyTheory.Circle.Induction.html#1416" class="Bound">A</a><a id="1478" class="Symbol">}</a> <a id="1480" class="Symbol">(</a><a id="1481" href="SyntheticHomotopyTheory.Circle.Induction.html#1481" class="Bound">p</a> <a id="1483" class="Symbol">:</a> <a id="1485" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a> <a id="1487" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1489" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a><a id="1490" class="Symbol">)</a> <a id="1492" class="Symbol">{</a><a id="1493" href="SyntheticHomotopyTheory.Circle.Induction.html#1493" class="Bound">b</a> <a id="1495" class="Symbol">:</a> <a id="1497" href="SyntheticHomotopyTheory.Circle.Induction.html#1427" class="Bound">B</a><a id="1498" class="Symbol">}</a> <a id="1500" class="Symbol">(</a><a id="1501" href="SyntheticHomotopyTheory.Circle.Induction.html#1501" class="Bound">q</a> <a id="1503" class="Symbol">:</a> <a id="1505" href="SyntheticHomotopyTheory.Circle.Induction.html#1493" class="Bound">b</a> <a id="1507" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1509" href="SyntheticHomotopyTheory.Circle.Induction.html#1493" class="Bound">b</a><a id="1510" class="Symbol">)</a>
                     <a id="1533" class="Symbol">(</a><a id="1534" href="SyntheticHomotopyTheory.Circle.Induction.html#1534" class="Bound">u</a> <a id="1536" class="Symbol">:</a> <a id="1538" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1548" href="SyntheticHomotopyTheory.Circle.Induction.html#1438" class="Bound">f</a> <a id="1550" class="Symbol">(</a><a id="1551" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a> <a id="1553" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1555" href="SyntheticHomotopyTheory.Circle.Induction.html#1481" class="Bound">p</a><a id="1556" class="Symbol">)</a> <a id="1558" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1560" class="Symbol">(</a><a id="1561" href="SyntheticHomotopyTheory.Circle.Induction.html#1493" class="Bound">b</a> <a id="1563" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1565" href="SyntheticHomotopyTheory.Circle.Induction.html#1501" class="Bound">q</a><a id="1566" class="Symbol">))</a>
                     <a id="1590" class="Symbol">(</a><a id="1591" href="SyntheticHomotopyTheory.Circle.Induction.html#1591" class="Bound">v</a> <a id="1593" class="Symbol">:</a> <a id="1595" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1605" href="SyntheticHomotopyTheory.Circle.Induction.html#1440" class="Bound">g</a> <a id="1607" class="Symbol">(</a><a id="1608" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a> <a id="1610" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1612" href="SyntheticHomotopyTheory.Circle.Induction.html#1481" class="Bound">p</a><a id="1613" class="Symbol">)</a> <a id="1615" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1617" class="Symbol">(</a><a id="1618" href="SyntheticHomotopyTheory.Circle.Induction.html#1493" class="Bound">b</a> <a id="1620" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1622" href="SyntheticHomotopyTheory.Circle.Induction.html#1501" class="Bound">q</a><a id="1623" class="Symbol">))</a>
                     <a id="1647" class="Symbol">(</a><a id="1648" href="SyntheticHomotopyTheory.Circle.Induction.html#1648" class="Bound">w</a> <a id="1650" class="Symbol">:</a> <a id="1652" class="Symbol">(</a><a id="1653" href="SyntheticHomotopyTheory.Circle.Induction.html#1438" class="Bound">f</a> <a id="1655" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1657" href="SyntheticHomotopyTheory.Circle.Induction.html#1534" class="Bound">u</a><a id="1658" class="Symbol">)</a> <a id="1660" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1662" class="Symbol">(</a><a id="1663" href="SyntheticHomotopyTheory.Circle.Induction.html#1440" class="Bound">g</a> <a id="1665" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1667" href="SyntheticHomotopyTheory.Circle.Induction.html#1591" class="Bound">v</a><a id="1668" class="Symbol">))</a>
                   <a id="1690" class="Symbol">→</a> <a id="1692" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="1695" class="Symbol">(λ</a> <a id="1698" href="SyntheticHomotopyTheory.Circle.Induction.html#1698" class="Bound">-</a> <a id="1700" class="Symbol">→</a> <a id="1702" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1712" href="SyntheticHomotopyTheory.Circle.Induction.html#1698" class="Bound">-</a> <a id="1714" class="Symbol">(</a><a id="1715" href="SyntheticHomotopyTheory.Circle.Induction.html#1473" class="Bound">a</a> <a id="1717" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1719" href="SyntheticHomotopyTheory.Circle.Induction.html#1481" class="Bound">p</a><a id="1720" class="Symbol">))</a> <a id="1723" class="Symbol">(</a><a id="1724" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="1727" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="1731" href="SyntheticHomotopyTheory.Circle.Induction.html#1648" class="Bound">w</a><a id="1732" class="Symbol">)</a> <a id="1734" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1736" href="SyntheticHomotopyTheory.Circle.Induction.html#1534" class="Bound">u</a> <a id="1738" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="1740" href="SyntheticHomotopyTheory.Circle.Induction.html#1591" class="Bound">v</a> <a id="1742" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
<a id="1745" href="SyntheticHomotopyTheory.Circle.Induction.html#1394" class="Function">ap-𝓛-functor-lemma</a> <a id="1764" href="SyntheticHomotopyTheory.Circle.Induction.html#1764" class="Bound">f</a> <a id="1766" href="SyntheticHomotopyTheory.Circle.Induction.html#1766" class="Bound">g</a> <a id="1768" href="SyntheticHomotopyTheory.Circle.Induction.html#1768" class="Bound">p</a> <a id="1770" href="SyntheticHomotopyTheory.Circle.Induction.html#1770" class="Bound">q</a> <a id="1772" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1777" href="SyntheticHomotopyTheory.Circle.Induction.html#1777" class="Bound">v</a> <a id="1779" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="1784" class="Symbol">=</a> <a id="1786" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="happly-𝓛-functor-lemma"></a><a id="1792" href="SyntheticHomotopyTheory.Circle.Induction.html#1792" class="Function">happly-𝓛-functor-lemma</a> <a id="1815" class="Symbol">:</a> <a id="1817" class="Symbol">{</a><a id="1818" href="SyntheticHomotopyTheory.Circle.Induction.html#1818" class="Bound">A</a> <a id="1820" class="Symbol">:</a> <a id="1822" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="1824" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1826" class="Symbol">}</a> <a id="1828" class="Symbol">{</a><a id="1829" href="SyntheticHomotopyTheory.Circle.Induction.html#1829" class="Bound">B</a> <a id="1831" class="Symbol">:</a> <a id="1833" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="1835" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1837" class="Symbol">}</a> <a id="1839" class="Symbol">(</a><a id="1840" href="SyntheticHomotopyTheory.Circle.Induction.html#1840" class="Bound">f</a> <a id="1842" href="SyntheticHomotopyTheory.Circle.Induction.html#1842" class="Bound">g</a> <a id="1844" class="Symbol">:</a> <a id="1846" href="SyntheticHomotopyTheory.Circle.Induction.html#1818" class="Bound">A</a> <a id="1848" class="Symbol">→</a> <a id="1850" href="SyntheticHomotopyTheory.Circle.Induction.html#1829" class="Bound">B</a><a id="1851" class="Symbol">)</a>
                         <a id="1878" class="Symbol">{</a><a id="1879" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a> <a id="1881" class="Symbol">:</a> <a id="1883" href="SyntheticHomotopyTheory.Circle.Induction.html#1818" class="Bound">A</a><a id="1884" class="Symbol">}</a> <a id="1886" class="Symbol">(</a><a id="1887" href="SyntheticHomotopyTheory.Circle.Induction.html#1887" class="Bound">p</a> <a id="1889" class="Symbol">:</a> <a id="1891" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a> <a id="1893" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1895" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a><a id="1896" class="Symbol">)</a> <a id="1898" class="Symbol">{</a><a id="1899" href="SyntheticHomotopyTheory.Circle.Induction.html#1899" class="Bound">b</a> <a id="1901" class="Symbol">:</a> <a id="1903" href="SyntheticHomotopyTheory.Circle.Induction.html#1829" class="Bound">B</a><a id="1904" class="Symbol">}</a> <a id="1906" class="Symbol">(</a><a id="1907" href="SyntheticHomotopyTheory.Circle.Induction.html#1907" class="Bound">q</a> <a id="1909" class="Symbol">:</a> <a id="1911" href="SyntheticHomotopyTheory.Circle.Induction.html#1899" class="Bound">b</a> <a id="1913" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1915" href="SyntheticHomotopyTheory.Circle.Induction.html#1899" class="Bound">b</a><a id="1916" class="Symbol">)</a>
                         <a id="1943" class="Symbol">(</a><a id="1944" href="SyntheticHomotopyTheory.Circle.Induction.html#1944" class="Bound">u</a> <a id="1946" class="Symbol">:</a> <a id="1948" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="1958" href="SyntheticHomotopyTheory.Circle.Induction.html#1840" class="Bound">f</a> <a id="1960" class="Symbol">(</a><a id="1961" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a> <a id="1963" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1965" href="SyntheticHomotopyTheory.Circle.Induction.html#1887" class="Bound">p</a><a id="1966" class="Symbol">)</a> <a id="1968" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="1970" class="Symbol">(</a><a id="1971" href="SyntheticHomotopyTheory.Circle.Induction.html#1899" class="Bound">b</a> <a id="1973" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="1975" href="SyntheticHomotopyTheory.Circle.Induction.html#1907" class="Bound">q</a><a id="1976" class="Symbol">))</a>
                         <a id="2004" class="Symbol">(</a><a id="2005" href="SyntheticHomotopyTheory.Circle.Induction.html#2005" class="Bound">v</a> <a id="2007" class="Symbol">:</a> <a id="2009" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="2019" href="SyntheticHomotopyTheory.Circle.Induction.html#1842" class="Bound">g</a> <a id="2021" class="Symbol">(</a><a id="2022" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a> <a id="2024" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2026" href="SyntheticHomotopyTheory.Circle.Induction.html#1887" class="Bound">p</a><a id="2027" class="Symbol">)</a> <a id="2029" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2031" class="Symbol">(</a><a id="2032" href="SyntheticHomotopyTheory.Circle.Induction.html#1899" class="Bound">b</a> <a id="2034" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2036" href="SyntheticHomotopyTheory.Circle.Induction.html#1907" class="Bound">q</a><a id="2037" class="Symbol">))</a>
                         <a id="2065" class="Symbol">(</a><a id="2066" href="SyntheticHomotopyTheory.Circle.Induction.html#2066" class="Bound">w</a> <a id="2068" class="Symbol">:</a> <a id="2070" class="Symbol">(</a><a id="2071" href="SyntheticHomotopyTheory.Circle.Induction.html#1840" class="Bound">f</a> <a id="2073" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2075" href="SyntheticHomotopyTheory.Circle.Induction.html#1944" class="Bound">u</a><a id="2076" class="Symbol">)</a> <a id="2078" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2080" class="Symbol">(</a><a id="2081" href="SyntheticHomotopyTheory.Circle.Induction.html#1842" class="Bound">g</a> <a id="2083" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2085" href="SyntheticHomotopyTheory.Circle.Induction.html#2005" class="Bound">v</a><a id="2086" class="Symbol">))</a>
                       <a id="2112" class="Symbol">→</a> <a id="2114" href="UF.Base.html#11014" class="Function">happly</a> <a id="2121" class="Symbol">(</a><a id="2122" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="2125" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="2129" href="SyntheticHomotopyTheory.Circle.Induction.html#2066" class="Bound">w</a><a id="2130" class="Symbol">)</a> <a id="2132" href="SyntheticHomotopyTheory.Circle.Induction.html#1879" class="Bound">a</a> <a id="2134" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2136" class="Symbol">(</a><a id="2137" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="2140" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="2144" href="SyntheticHomotopyTheory.Circle.Induction.html#1944" class="Bound">u</a><a id="2145" class="Symbol">)</a> <a id="2147" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="2149" class="Symbol">(</a><a id="2150" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="2153" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="2157" href="SyntheticHomotopyTheory.Circle.Induction.html#2005" class="Bound">v</a><a id="2158" class="Symbol">)</a> <a id="2160" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
<a id="2163" href="SyntheticHomotopyTheory.Circle.Induction.html#1792" class="Function">happly-𝓛-functor-lemma</a> <a id="2186" href="SyntheticHomotopyTheory.Circle.Induction.html#2186" class="Bound">f</a> <a id="2188" href="SyntheticHomotopyTheory.Circle.Induction.html#2188" class="Bound">g</a> <a id="2190" href="SyntheticHomotopyTheory.Circle.Induction.html#2190" class="Bound">p</a> <a id="2192" href="SyntheticHomotopyTheory.Circle.Induction.html#2192" class="Bound">q</a> <a id="2194" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="2199" href="SyntheticHomotopyTheory.Circle.Induction.html#2199" class="Bound">v</a> <a id="2201" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="2206" class="Symbol">=</a> <a id="2208" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="2214" class="Markup">\end{code}</a><a id="2224" class="Background">

Next we introduce the circle 𝕊¹ with its point base, its loop at base and its
universal property.

</a><a id="2325" class="Markup">\begin{code}</a>

<a id="2339" class="Keyword">module</a> <a id="2346" href="SyntheticHomotopyTheory.Circle.Induction.html#2346" class="Module">_</a>
        <a id="2356" class="Symbol">(</a><a id="2357" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="2360" class="Symbol">:</a> <a id="2362" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="2364" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2366" class="Symbol">)</a>
        <a id="2376" class="Symbol">(</a><a id="2377" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="2382" class="Symbol">:</a> <a id="2384" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="2386" class="Symbol">)</a>
        <a id="2396" class="Symbol">(</a><a id="2397" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="2402" class="Symbol">:</a> <a id="2404" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="2409" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2411" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="2415" class="Symbol">)</a>
       <a id="2424" class="Keyword">where</a>

 <a id="2432" href="SyntheticHomotopyTheory.Circle.Induction.html#2432" class="Function">𝕊¹-universal-map</a> <a id="2449" class="Symbol">:</a> <a id="2451" class="Symbol">(</a><a id="2452" href="SyntheticHomotopyTheory.Circle.Induction.html#2452" class="Bound">A</a> <a id="2454" class="Symbol">:</a> <a id="2456" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="2458" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2460" class="Symbol">)</a>
                  <a id="2480" class="Symbol">→</a> <a id="2482" class="Symbol">(</a><a id="2483" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="2486" class="Symbol">→</a> <a id="2488" href="SyntheticHomotopyTheory.Circle.Induction.html#2452" class="Bound">A</a><a id="2489" class="Symbol">)</a> <a id="2491" class="Symbol">→</a> <a id="2493" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="2495" href="SyntheticHomotopyTheory.Circle.Induction.html#2452" class="Bound">A</a>
 <a id="2498" href="SyntheticHomotopyTheory.Circle.Induction.html#2432" class="Function">𝕊¹-universal-map</a> <a id="2515" href="SyntheticHomotopyTheory.Circle.Induction.html#2515" class="Bound">A</a> <a id="2517" href="SyntheticHomotopyTheory.Circle.Induction.html#2517" class="Bound">f</a> <a id="2519" class="Symbol">=</a> <a id="2521" class="Symbol">(</a><a id="2522" href="SyntheticHomotopyTheory.Circle.Induction.html#2517" class="Bound">f</a> <a id="2524" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="2529" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2531" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="2534" href="SyntheticHomotopyTheory.Circle.Induction.html#2517" class="Bound">f</a> <a id="2536" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="2540" class="Symbol">)</a>

 <a id="2544" class="Keyword">module</a> <a id="2551" href="SyntheticHomotopyTheory.Circle.Induction.html#2551" class="Module">_</a>
         <a id="2562" class="Symbol">(</a><a id="2563" href="SyntheticHomotopyTheory.Circle.Induction.html#2563" class="Bound">𝕊¹-universal-property</a> <a id="2585" class="Symbol">:</a> <a id="2587" class="Symbol">{</a><a id="2588" href="SyntheticHomotopyTheory.Circle.Induction.html#2588" class="Bound">𝓥</a> <a id="2590" class="Symbol">:</a> <a id="2592" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="2600" class="Symbol">}</a> <a id="2602" class="Symbol">(</a><a id="2603" href="SyntheticHomotopyTheory.Circle.Induction.html#2603" class="Bound">A</a> <a id="2605" class="Symbol">:</a> <a id="2607" href="SyntheticHomotopyTheory.Circle.Induction.html#2588" class="Bound">𝓥</a> <a id="2609" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2611" class="Symbol">)</a>
                                <a id="2645" class="Symbol">→</a> <a id="2647" href="UF.Equiv.html#402" class="Function">is-equiv</a> <a id="2656" class="Symbol">(</a><a id="2657" href="SyntheticHomotopyTheory.Circle.Induction.html#2432" class="Function">𝕊¹-universal-map</a> <a id="2674" href="SyntheticHomotopyTheory.Circle.Induction.html#2603" class="Bound">A</a><a id="2675" class="Symbol">))</a>
        <a id="2686" class="Keyword">where</a>

  <a id="2695" href="SyntheticHomotopyTheory.Circle.Induction.html#2695" class="Function">𝕊¹-uniqueness-principle</a> <a id="2719" class="Symbol">:</a> <a id="2721" class="Symbol">{</a><a id="2722" href="SyntheticHomotopyTheory.Circle.Induction.html#2722" class="Bound">A</a> <a id="2724" class="Symbol">:</a> <a id="2726" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="2728" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2730" class="Symbol">}</a> <a id="2732" class="Symbol">(</a><a id="2733" href="SyntheticHomotopyTheory.Circle.Induction.html#2733" class="Bound">a</a> <a id="2735" class="Symbol">:</a> <a id="2737" href="SyntheticHomotopyTheory.Circle.Induction.html#2722" class="Bound">A</a><a id="2738" class="Symbol">)</a> <a id="2740" class="Symbol">(</a><a id="2741" href="SyntheticHomotopyTheory.Circle.Induction.html#2741" class="Bound">p</a> <a id="2743" class="Symbol">:</a> <a id="2745" href="SyntheticHomotopyTheory.Circle.Induction.html#2733" class="Bound">a</a> <a id="2747" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2749" href="SyntheticHomotopyTheory.Circle.Induction.html#2733" class="Bound">a</a><a id="2750" class="Symbol">)</a>
                          <a id="2778" class="Symbol">→</a> <a id="2780" href="UF.Subsingletons.html#8927" class="Function">∃!</a> <a id="2783" href="SyntheticHomotopyTheory.Circle.Induction.html#2783" class="Bound">r</a> <a id="2785" href="UF.Subsingletons.html#8927" class="Function">꞉</a> <a id="2787" class="Symbol">(</a><a id="2788" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="2791" class="Symbol">→</a> <a id="2793" href="SyntheticHomotopyTheory.Circle.Induction.html#2722" class="Bound">A</a><a id="2794" class="Symbol">)</a> <a id="2796" href="UF.Subsingletons.html#8927" class="Function">,</a> <a id="2798" class="Symbol">(</a><a id="2799" href="SyntheticHomotopyTheory.Circle.Induction.html#2783" class="Bound">r</a> <a id="2801" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="2806" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2808" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="2811" href="SyntheticHomotopyTheory.Circle.Induction.html#2783" class="Bound">r</a> <a id="2813" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="2817" class="Symbol">)</a> <a id="2819" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2821" class="Symbol">(</a><a id="2822" href="SyntheticHomotopyTheory.Circle.Induction.html#2733" class="Bound">a</a> <a id="2824" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2826" href="SyntheticHomotopyTheory.Circle.Induction.html#2741" class="Bound">p</a><a id="2827" class="Symbol">)</a>
  <a id="2831" href="SyntheticHomotopyTheory.Circle.Induction.html#2695" class="Function">𝕊¹-uniqueness-principle</a> <a id="2855" class="Symbol">{</a><a id="2856" href="SyntheticHomotopyTheory.Circle.Induction.html#2856" class="Bound">𝓥</a><a id="2857" class="Symbol">}</a> <a id="2859" class="Symbol">{</a><a id="2860" href="SyntheticHomotopyTheory.Circle.Induction.html#2860" class="Bound">A</a><a id="2861" class="Symbol">}</a> <a id="2863" href="SyntheticHomotopyTheory.Circle.Induction.html#2863" class="Bound">a</a> <a id="2865" href="SyntheticHomotopyTheory.Circle.Induction.html#2865" class="Bound">p</a> <a id="2867" class="Symbol">=</a>
    <a id="2873" href="UF.Equiv.html#18178" class="Function">equivs-are-vv-equivs</a> <a id="2894" class="Symbol">(</a><a id="2895" href="SyntheticHomotopyTheory.Circle.Induction.html#2432" class="Function">𝕊¹-universal-map</a> <a id="2912" href="SyntheticHomotopyTheory.Circle.Induction.html#2860" class="Bound">A</a><a id="2913" class="Symbol">)</a>
                         <a id="2940" class="Symbol">(</a><a id="2941" href="SyntheticHomotopyTheory.Circle.Induction.html#2563" class="Bound">𝕊¹-universal-property</a> <a id="2963" href="SyntheticHomotopyTheory.Circle.Induction.html#2860" class="Bound">A</a><a id="2964" class="Symbol">)</a> <a id="2966" class="Symbol">(</a><a id="2967" href="SyntheticHomotopyTheory.Circle.Induction.html#2863" class="Bound">a</a> <a id="2969" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2971" href="SyntheticHomotopyTheory.Circle.Induction.html#2865" class="Bound">p</a><a id="2972" class="Symbol">)</a>

  <a id="2977" href="SyntheticHomotopyTheory.Circle.Induction.html#2977" class="Function">𝕊¹-at-most-one-function</a> <a id="3001" class="Symbol">:</a> <a id="3003" class="Symbol">{</a><a id="3004" href="SyntheticHomotopyTheory.Circle.Induction.html#3004" class="Bound">A</a> <a id="3006" class="Symbol">:</a> <a id="3008" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="3010" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3012" class="Symbol">}</a> <a id="3014" class="Symbol">(</a><a id="3015" href="SyntheticHomotopyTheory.Circle.Induction.html#3015" class="Bound">a</a> <a id="3017" class="Symbol">:</a> <a id="3019" href="SyntheticHomotopyTheory.Circle.Induction.html#3004" class="Bound">A</a><a id="3020" class="Symbol">)</a> <a id="3022" class="Symbol">(</a><a id="3023" href="SyntheticHomotopyTheory.Circle.Induction.html#3023" class="Bound">p</a> <a id="3025" class="Symbol">:</a> <a id="3027" href="SyntheticHomotopyTheory.Circle.Induction.html#3015" class="Bound">a</a> <a id="3029" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3031" href="SyntheticHomotopyTheory.Circle.Induction.html#3015" class="Bound">a</a><a id="3032" class="Symbol">)</a>
                          <a id="3060" class="Symbol">→</a> <a id="3062" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="3070" class="Symbol">(</a><a id="3071" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="3073" href="SyntheticHomotopyTheory.Circle.Induction.html#3073" class="Bound">r</a> <a id="3075" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="3077" class="Symbol">(</a><a id="3078" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="3081" class="Symbol">→</a> <a id="3083" href="SyntheticHomotopyTheory.Circle.Induction.html#3004" class="Bound">A</a><a id="3084" class="Symbol">)</a> <a id="3086" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="3088" class="Symbol">(</a><a id="3089" href="SyntheticHomotopyTheory.Circle.Induction.html#3073" class="Bound">r</a> <a id="3091" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="3096" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3098" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="3101" href="SyntheticHomotopyTheory.Circle.Induction.html#3073" class="Bound">r</a> <a id="3103" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="3107" class="Symbol">)</a> <a id="3109" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3111" class="Symbol">(</a><a id="3112" href="SyntheticHomotopyTheory.Circle.Induction.html#3015" class="Bound">a</a> <a id="3114" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3116" href="SyntheticHomotopyTheory.Circle.Induction.html#3023" class="Bound">p</a><a id="3117" class="Symbol">))</a>
  <a id="3122" href="SyntheticHomotopyTheory.Circle.Induction.html#2977" class="Function">𝕊¹-at-most-one-function</a> <a id="3146" href="SyntheticHomotopyTheory.Circle.Induction.html#3146" class="Bound">a</a> <a id="3148" href="SyntheticHomotopyTheory.Circle.Induction.html#3148" class="Bound">p</a> <a id="3150" class="Symbol">=</a> <a id="3152" href="UF.Subsingletons.html#2083" class="Function">singletons-are-props</a> <a id="3173" class="Symbol">(</a><a id="3174" href="SyntheticHomotopyTheory.Circle.Induction.html#2695" class="Function">𝕊¹-uniqueness-principle</a> <a id="3198" href="SyntheticHomotopyTheory.Circle.Induction.html#3146" class="Bound">a</a> <a id="3200" href="SyntheticHomotopyTheory.Circle.Induction.html#3148" class="Bound">p</a><a id="3201" class="Symbol">)</a>

<a id="3204" class="Markup">\end{code}</a><a id="3214" class="Background">

The recursion principle for 𝕊¹ with its computation rule follows immediately
from the universal property of 𝕊¹.

</a><a id="3329" class="Markup">\begin{code}</a>

  <a id="3345" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="3352" class="Symbol">:</a> <a id="3354" class="Symbol">{</a><a id="3355" href="SyntheticHomotopyTheory.Circle.Induction.html#3355" class="Bound">A</a> <a id="3357" class="Symbol">:</a> <a id="3359" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="3361" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3363" class="Symbol">}</a> <a id="3365" class="Symbol">(</a><a id="3366" href="SyntheticHomotopyTheory.Circle.Induction.html#3366" class="Bound">a</a> <a id="3368" class="Symbol">:</a> <a id="3370" href="SyntheticHomotopyTheory.Circle.Induction.html#3355" class="Bound">A</a><a id="3371" class="Symbol">)</a> <a id="3373" class="Symbol">(</a><a id="3374" href="SyntheticHomotopyTheory.Circle.Induction.html#3374" class="Bound">p</a> <a id="3376" class="Symbol">:</a> <a id="3378" href="SyntheticHomotopyTheory.Circle.Induction.html#3366" class="Bound">a</a> <a id="3380" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3382" href="SyntheticHomotopyTheory.Circle.Induction.html#3366" class="Bound">a</a><a id="3383" class="Symbol">)</a>
         <a id="3394" class="Symbol">→</a> <a id="3396" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="3399" class="Symbol">→</a> <a id="3401" href="SyntheticHomotopyTheory.Circle.Induction.html#3355" class="Bound">A</a>
  <a id="3405" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="3412" class="Symbol">{</a><a id="3413" href="SyntheticHomotopyTheory.Circle.Induction.html#3413" class="Bound">𝓥</a><a id="3414" class="Symbol">}</a> <a id="3416" class="Symbol">{</a><a id="3417" href="SyntheticHomotopyTheory.Circle.Induction.html#3417" class="Bound">A</a><a id="3418" class="Symbol">}</a> <a id="3420" href="SyntheticHomotopyTheory.Circle.Induction.html#3420" class="Bound">a</a> <a id="3422" href="SyntheticHomotopyTheory.Circle.Induction.html#3422" class="Bound">p</a> <a id="3424" class="Symbol">=</a> <a id="3426" href="UF.Subsingletons.html#9431" class="Function">∃!-witness</a> <a id="3437" class="Symbol">(</a><a id="3438" href="SyntheticHomotopyTheory.Circle.Induction.html#2695" class="Function">𝕊¹-uniqueness-principle</a> <a id="3462" href="SyntheticHomotopyTheory.Circle.Induction.html#3420" class="Bound">a</a> <a id="3464" href="SyntheticHomotopyTheory.Circle.Induction.html#3422" class="Bound">p</a><a id="3465" class="Symbol">)</a>

  <a id="3470" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="3482" class="Symbol">:</a> <a id="3484" class="Symbol">{</a><a id="3485" href="SyntheticHomotopyTheory.Circle.Induction.html#3485" class="Bound">A</a> <a id="3487" class="Symbol">:</a> <a id="3489" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="3491" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3493" class="Symbol">}</a> <a id="3495" class="Symbol">(</a><a id="3496" href="SyntheticHomotopyTheory.Circle.Induction.html#3496" class="Bound">a</a> <a id="3498" class="Symbol">:</a> <a id="3500" href="SyntheticHomotopyTheory.Circle.Induction.html#3485" class="Bound">A</a><a id="3501" class="Symbol">)</a> <a id="3503" class="Symbol">(</a><a id="3504" href="SyntheticHomotopyTheory.Circle.Induction.html#3504" class="Bound">p</a> <a id="3506" class="Symbol">:</a> <a id="3508" href="SyntheticHomotopyTheory.Circle.Induction.html#3496" class="Bound">a</a> <a id="3510" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3512" href="SyntheticHomotopyTheory.Circle.Induction.html#3496" class="Bound">a</a><a id="3513" class="Symbol">)</a>
              <a id="3529" class="Symbol">→</a> <a id="3531" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="3541" class="Symbol">(</a><a id="3542" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="3549" href="SyntheticHomotopyTheory.Circle.Induction.html#3496" class="Bound">a</a> <a id="3551" href="SyntheticHomotopyTheory.Circle.Induction.html#3504" class="Bound">p</a><a id="3552" class="Symbol">)</a> <a id="3554" class="Symbol">(</a><a id="3555" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="3560" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3562" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="3566" class="Symbol">)</a> <a id="3568" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="3571" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="3573" href="SyntheticHomotopyTheory.Circle.Induction.html#3485" class="Bound">A</a> <a id="3575" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="3577" class="Symbol">(</a><a id="3578" href="SyntheticHomotopyTheory.Circle.Induction.html#3496" class="Bound">a</a> <a id="3580" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3582" href="SyntheticHomotopyTheory.Circle.Induction.html#3504" class="Bound">p</a><a id="3583" class="Symbol">)</a>
  <a id="3587" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="3599" class="Symbol">{</a><a id="3600" href="SyntheticHomotopyTheory.Circle.Induction.html#3600" class="Bound">𝓥</a><a id="3601" class="Symbol">}</a> <a id="3603" class="Symbol">{</a><a id="3604" href="SyntheticHomotopyTheory.Circle.Induction.html#3604" class="Bound">A</a><a id="3605" class="Symbol">}</a> <a id="3607" href="SyntheticHomotopyTheory.Circle.Induction.html#3607" class="Bound">a</a> <a id="3609" href="SyntheticHomotopyTheory.Circle.Induction.html#3609" class="Bound">p</a> <a id="3611" class="Symbol">=</a> <a id="3613" href="UF.Subsingletons.html#9511" class="Function">∃!-is-witness</a> <a id="3627" class="Symbol">(</a><a id="3628" href="SyntheticHomotopyTheory.Circle.Induction.html#2695" class="Function">𝕊¹-uniqueness-principle</a> <a id="3652" href="SyntheticHomotopyTheory.Circle.Induction.html#3607" class="Bound">a</a> <a id="3654" href="SyntheticHomotopyTheory.Circle.Induction.html#3609" class="Bound">p</a><a id="3655" class="Symbol">)</a>

  <a id="3660" href="SyntheticHomotopyTheory.Circle.Induction.html#3660" class="Function">𝕊¹-rec-on-base</a> <a id="3675" class="Symbol">:</a> <a id="3677" class="Symbol">{</a><a id="3678" href="SyntheticHomotopyTheory.Circle.Induction.html#3678" class="Bound">A</a> <a id="3680" class="Symbol">:</a> <a id="3682" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="3684" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3686" class="Symbol">}</a> <a id="3688" class="Symbol">(</a><a id="3689" href="SyntheticHomotopyTheory.Circle.Induction.html#3689" class="Bound">a</a> <a id="3691" class="Symbol">:</a> <a id="3693" href="SyntheticHomotopyTheory.Circle.Induction.html#3678" class="Bound">A</a><a id="3694" class="Symbol">)</a> <a id="3696" class="Symbol">(</a><a id="3697" href="SyntheticHomotopyTheory.Circle.Induction.html#3697" class="Bound">p</a> <a id="3699" class="Symbol">:</a> <a id="3701" href="SyntheticHomotopyTheory.Circle.Induction.html#3689" class="Bound">a</a> <a id="3703" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3705" href="SyntheticHomotopyTheory.Circle.Induction.html#3689" class="Bound">a</a><a id="3706" class="Symbol">)</a>
                  <a id="3726" class="Symbol">→</a> <a id="3728" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="3735" href="SyntheticHomotopyTheory.Circle.Induction.html#3689" class="Bound">a</a> <a id="3737" href="SyntheticHomotopyTheory.Circle.Induction.html#3697" class="Bound">p</a> <a id="3739" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="3744" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3746" href="SyntheticHomotopyTheory.Circle.Induction.html#3689" class="Bound">a</a>
  <a id="3750" href="SyntheticHomotopyTheory.Circle.Induction.html#3660" class="Function">𝕊¹-rec-on-base</a> <a id="3765" href="SyntheticHomotopyTheory.Circle.Induction.html#3765" class="Bound">a</a> <a id="3767" href="SyntheticHomotopyTheory.Circle.Induction.html#3767" class="Bound">p</a> <a id="3769" class="Symbol">=</a> <a id="3771" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="3774" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="3778" class="Symbol">(</a><a id="3779" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="3791" href="SyntheticHomotopyTheory.Circle.Induction.html#3765" class="Bound">a</a> <a id="3793" href="SyntheticHomotopyTheory.Circle.Induction.html#3767" class="Bound">p</a><a id="3794" class="Symbol">)</a>

  <a id="3799" href="SyntheticHomotopyTheory.Circle.Induction.html#3799" class="Function">𝕊¹-rec-on-loop</a> <a id="3814" class="Symbol">:</a> <a id="3816" class="Symbol">{</a><a id="3817" href="SyntheticHomotopyTheory.Circle.Induction.html#3817" class="Bound">A</a> <a id="3819" class="Symbol">:</a> <a id="3821" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="3823" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3825" class="Symbol">}</a> <a id="3827" class="Symbol">(</a><a id="3828" href="SyntheticHomotopyTheory.Circle.Induction.html#3828" class="Bound">a</a> <a id="3830" class="Symbol">:</a> <a id="3832" href="SyntheticHomotopyTheory.Circle.Induction.html#3817" class="Bound">A</a><a id="3833" class="Symbol">)</a> <a id="3835" class="Symbol">(</a><a id="3836" href="SyntheticHomotopyTheory.Circle.Induction.html#3836" class="Bound">p</a> <a id="3838" class="Symbol">:</a> <a id="3840" href="SyntheticHomotopyTheory.Circle.Induction.html#3828" class="Bound">a</a> <a id="3842" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3844" href="SyntheticHomotopyTheory.Circle.Induction.html#3828" class="Bound">a</a><a id="3845" class="Symbol">)</a>
                 <a id="3864" class="Symbol">→</a> <a id="3866" href="MLTT.Id.html#735" class="Function">transport</a> <a id="3876" class="Symbol">(λ</a> <a id="3879" href="SyntheticHomotopyTheory.Circle.Induction.html#3879" class="Bound">-</a> <a id="3881" class="Symbol">→</a> <a id="3883" href="SyntheticHomotopyTheory.Circle.Induction.html#3879" class="Bound">-</a> <a id="3885" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3887" href="SyntheticHomotopyTheory.Circle.Induction.html#3879" class="Bound">-</a><a id="3888" class="Symbol">)</a> <a id="3890" class="Symbol">(</a><a id="3891" href="SyntheticHomotopyTheory.Circle.Induction.html#3660" class="Function">𝕊¹-rec-on-base</a> <a id="3906" href="SyntheticHomotopyTheory.Circle.Induction.html#3828" class="Bound">a</a> <a id="3908" href="SyntheticHomotopyTheory.Circle.Induction.html#3836" class="Bound">p</a><a id="3909" class="Symbol">)</a>
                     <a id="3932" class="Symbol">(</a><a id="3933" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="3936" class="Symbol">(</a><a id="3937" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="3944" href="SyntheticHomotopyTheory.Circle.Induction.html#3828" class="Bound">a</a> <a id="3946" href="SyntheticHomotopyTheory.Circle.Induction.html#3836" class="Bound">p</a><a id="3947" class="Symbol">)</a> <a id="3949" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="3953" class="Symbol">)</a>
                 <a id="3972" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3974" href="SyntheticHomotopyTheory.Circle.Induction.html#3836" class="Bound">p</a>
  <a id="3978" href="SyntheticHomotopyTheory.Circle.Induction.html#3799" class="Function">𝕊¹-rec-on-loop</a> <a id="3993" href="SyntheticHomotopyTheory.Circle.Induction.html#3993" class="Bound">a</a> <a id="3995" href="SyntheticHomotopyTheory.Circle.Induction.html#3995" class="Bound">p</a> <a id="3997" class="Symbol">=</a> <a id="3999" href="UF.Base.html#14834" class="Function">from-Σ-＝&#39;</a> <a id="4009" class="Symbol">(</a><a id="4010" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="4022" href="SyntheticHomotopyTheory.Circle.Induction.html#3993" class="Bound">a</a> <a id="4024" href="SyntheticHomotopyTheory.Circle.Induction.html#3995" class="Bound">p</a><a id="4025" class="Symbol">)</a>

<a id="4028" class="Markup">\end{code}</a><a id="4038" class="Background">

The induction principle for 𝕊¹ also follows quite directly. The idea is to turn
a type family A over 𝕊¹ to the type Σ A and consider a nondependent map 𝕊¹ → Σ A
as a substitute for the dependent function (x : 𝕊¹) → A x.

What is significantly harder is showing that it obeys the computation rules.

</a><a id="4339" class="Markup">\begin{code}</a>

  <a id="4355" class="Keyword">module</a> <a id="4362" href="SyntheticHomotopyTheory.Circle.Induction.html#4362" class="Module">𝕊¹-induction</a>
          <a id="4385" class="Symbol">(</a><a id="4386" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="4388" class="Symbol">:</a> <a id="4390" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="4393" class="Symbol">→</a> <a id="4395" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="4397" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="4399" class="Symbol">)</a>
          <a id="4411" class="Symbol">(</a><a id="4412" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a> <a id="4414" class="Symbol">:</a> <a id="4416" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="4418" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="4422" class="Symbol">)</a>
          <a id="4434" class="Symbol">(</a><a id="4435" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a> <a id="4437" class="Symbol">:</a> <a id="4439" href="MLTT.Id.html#735" class="Function">transport</a> <a id="4449" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="4451" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="4456" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a> <a id="4458" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="4460" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="4461" class="Symbol">)</a>
         <a id="4472" class="Keyword">where</a>

   <a id="4482" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a> <a id="4485" class="Symbol">:</a> <a id="4487" class="Symbol">(</a><a id="4488" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4493" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4495" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="4496" class="Symbol">)</a> <a id="4498" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="4501" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="4503" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="4505" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="4507" class="Symbol">(</a><a id="4508" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4513" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4515" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="4516" class="Symbol">)</a>
   <a id="4521" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a> <a id="4524" class="Symbol">=</a> <a id="4526" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="4533" class="Symbol">(</a><a id="4534" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="4539" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4541" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="4542" class="Symbol">)</a>

   <a id="4548" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="4550" class="Symbol">:</a> <a id="4552" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="4555" class="Symbol">→</a> <a id="4557" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="4559" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a>
   <a id="4564" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="4566" class="Symbol">=</a> <a id="4568" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="4575" class="Symbol">(</a><a id="4576" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4581" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4583" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="4584" class="Symbol">)</a> <a id="4586" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a>

<a id="4590" class="Markup">\end{code}</a><a id="4600" class="Background">

Next we show that r is a retraction of pr₁ : Σ A → 𝕊¹. This tells us that
r (x) = (x , pr₂ (r x)), so that we can define 𝕊¹-induction by transport.

</a><a id="4751" class="Markup">\begin{code}</a>

   <a id="4768" href="SyntheticHomotopyTheory.Circle.Induction.html#4768" class="Function">r-retraction-lemma</a> <a id="4787" class="Symbol">:</a> <a id="4789" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="4799" class="Symbol">(</a><a id="4800" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="4804" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="4806" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a><a id="4807" class="Symbol">)</a> <a id="4809" class="Symbol">(</a><a id="4810" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4815" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4817" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="4821" class="Symbol">)</a> <a id="4823" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="4826" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="4828" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="4831" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="4833" class="Symbol">(</a><a id="4834" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4839" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4841" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="4845" class="Symbol">)</a>
   <a id="4850" href="SyntheticHomotopyTheory.Circle.Induction.html#4768" class="Function">r-retraction-lemma</a> <a id="4869" class="Symbol">=</a>
    <a id="4875" class="Symbol">((</a><a id="4877" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="4881" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="4883" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a><a id="4884" class="Symbol">)</a> <a id="4886" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4891" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4893" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="4896" class="Symbol">(</a><a id="4897" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="4901" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="4903" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a><a id="4904" class="Symbol">)</a> <a id="4906" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="4910" class="Symbol">)</a> <a id="4912" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="4915" href="SyntheticHomotopyTheory.Circle.Induction.html#5081" class="Function">I</a>   <a id="4919" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="4925" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="4935" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="4939" class="Symbol">(</a><a id="4940" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="4942" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4947" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4949" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="4952" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="4954" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="4958" class="Symbol">)</a>   <a id="4962" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="4965" href="SyntheticHomotopyTheory.Circle.Induction.html#5133" class="Function">II</a>  <a id="4969" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="4975" class="Symbol">(</a><a id="4976" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="4981" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4983" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="4986" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="4990" class="Symbol">(</a><a id="4991" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="4998" class="Symbol">(</a><a id="4999" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="5004" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5006" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="5007" class="Symbol">)))</a>  <a id="5012" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="5015" href="SyntheticHomotopyTheory.Circle.Induction.html#5192" class="Function">III</a> <a id="5019" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="5025" class="Symbol">(</a><a id="5026" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5031" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5033" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="5037" class="Symbol">)</a>                        <a id="5062" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
     <a id="5069" class="Keyword">where</a>
      <a id="5081" href="SyntheticHomotopyTheory.Circle.Induction.html#5081" class="Function">I</a>   <a id="5085" class="Symbol">=</a> <a id="5087" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="5094" class="Symbol">(</a><a id="5095" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="5100" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5102" class="Symbol">((</a><a id="5104" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="5110" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5112" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5116" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="5120" class="Symbol">)</a> <a id="5122" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="5124" class="Symbol">))</a>
      <a id="5133" href="SyntheticHomotopyTheory.Circle.Induction.html#5133" class="Function">II</a>  <a id="5137" class="Symbol">=</a> <a id="5139" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="5142" class="Symbol">(</a><a id="5143" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="5153" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="5156" class="Symbol">)</a> <a id="5158" class="Symbol">(</a><a id="5159" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="5171" class="Symbol">(</a><a id="5172" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5177" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5179" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="5180" class="Symbol">)</a> <a id="5182" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a><a id="5184" class="Symbol">)</a>
      <a id="5192" href="SyntheticHomotopyTheory.Circle.Induction.html#5192" class="Function">III</a> <a id="5196" class="Symbol">=</a> <a id="5198" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="5205" class="Symbol">(</a><a id="5206" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="5211" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5213" class="Symbol">(</a><a id="5214" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="5228" class="Symbol">(</a><a id="5229" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="5234" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5236" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="5237" class="Symbol">)))</a>

   <a id="5245" href="SyntheticHomotopyTheory.Circle.Induction.html#5245" class="Function">r-is-retraction-of-pr₁</a> <a id="5268" class="Symbol">:</a> <a id="5270" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5274" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5276" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5278" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5280" href="MLTT.Pi.html#444" class="Function">id</a>
   <a id="5286" href="SyntheticHomotopyTheory.Circle.Induction.html#5245" class="Function">r-is-retraction-of-pr₁</a> <a id="5309" class="Symbol">=</a> <a id="5311" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="5314" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5318" class="Symbol">(</a><a id="5319" href="SyntheticHomotopyTheory.Circle.Induction.html#2977" class="Function">𝕊¹-at-most-one-function</a> <a id="5343" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5348" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
                                     <a id="5390" class="Symbol">(</a><a id="5391" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5395" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5397" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5399" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5401" href="SyntheticHomotopyTheory.Circle.Induction.html#4768" class="Function">r-retraction-lemma</a><a id="5419" class="Symbol">)</a>
                                     <a id="5458" class="Symbol">(</a><a id="5459" href="MLTT.Pi.html#444" class="Function">id</a> <a id="5462" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5464" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="5471" class="Symbol">(</a><a id="5472" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="5477" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5479" href="UF.Base.html#7444" class="Function">ap-id-is-id</a> <a id="5491" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="5495" class="Symbol">)))</a>

   <a id="5503" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="5516" class="Symbol">:</a> <a id="5518" class="Symbol">(</a><a id="5519" href="SyntheticHomotopyTheory.Circle.Induction.html#5519" class="Bound">x</a> <a id="5521" class="Symbol">:</a> <a id="5523" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="5525" class="Symbol">)</a> <a id="5527" class="Symbol">→</a> <a id="5529" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="5531" href="SyntheticHomotopyTheory.Circle.Induction.html#5519" class="Bound">x</a>
   <a id="5536" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="5549" href="SyntheticHomotopyTheory.Circle.Induction.html#5549" class="Bound">x</a> <a id="5551" class="Symbol">=</a> <a id="5553" href="MLTT.Id.html#735" class="Function">transport</a> <a id="5563" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="5565" class="Symbol">(</a><a id="5566" href="UF.Base.html#11014" class="Function">happly</a> <a id="5573" href="SyntheticHomotopyTheory.Circle.Induction.html#5245" class="Function">r-is-retraction-of-pr₁</a> <a id="5596" href="SyntheticHomotopyTheory.Circle.Induction.html#5549" class="Bound">x</a><a id="5597" class="Symbol">)</a> <a id="5599" class="Symbol">(</a><a id="5600" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="5604" class="Symbol">(</a><a id="5605" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5607" href="SyntheticHomotopyTheory.Circle.Induction.html#5549" class="Bound">x</a><a id="5608" class="Symbol">))</a>

<a id="5612" class="Markup">\end{code}</a><a id="5622" class="Background">

Next we set out to prove the computation rules for 𝕊¹-induction.

</a><a id="5690" class="Markup">\begin{code}</a>

   <a id="5707" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="5709" class="Symbol">:</a> <a id="5711" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="5714" class="Symbol">→</a> <a id="5716" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="5718" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a>
   <a id="5723" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="5725" href="SyntheticHomotopyTheory.Circle.Induction.html#5725" class="Bound">x</a> <a id="5727" class="Symbol">=</a> <a id="5729" class="Symbol">(</a><a id="5730" href="SyntheticHomotopyTheory.Circle.Induction.html#5725" class="Bound">x</a> <a id="5732" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5734" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="5747" href="SyntheticHomotopyTheory.Circle.Induction.html#5725" class="Bound">x</a><a id="5748" class="Symbol">)</a>

   <a id="5754" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a> <a id="5761" class="Symbol">:</a> <a id="5763" class="Symbol">(</a><a id="5764" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5766" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5771" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5773" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="5776" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5778" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="5782" class="Symbol">)</a> <a id="5784" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="5787" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="5789" class="Symbol">(</a><a id="5790" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="5792" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a><a id="5793" class="Symbol">)</a> <a id="5795" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="5797" class="Symbol">((</a><a id="5799" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5804" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5806" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="5807" class="Symbol">)</a> <a id="5809" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5811" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a><a id="5813" class="Symbol">)</a>
   <a id="5818" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a> <a id="5825" class="Symbol">=</a> <a id="5827" href="SyntheticHomotopyTheory.Circle.Induction.html#3470" class="Function">𝕊¹-rec-comp</a> <a id="5839" class="Symbol">(</a><a id="5840" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="5845" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5847" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="5848" class="Symbol">)</a> <a id="5850" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a>

   <a id="5857" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="5870" class="Symbol">:</a> <a id="5872" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="5874" href="MLTT.Id.html#1889" class="Function Operator">∼</a> <a id="5876" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a>
   <a id="5881" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="5894" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a> <a id="5896" class="Symbol">=</a> <a id="5898" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="5905" class="Symbol">((</a><a id="5907" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="5910" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="5912" class="Symbol">)</a> <a id="5914" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5916" href="SyntheticHomotopyTheory.Circle.Induction.html#6009" class="Function">γ₂</a><a id="5918" class="Symbol">)</a>
    <a id="5924" class="Keyword">where</a>
     <a id="5935" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="5938" class="Symbol">:</a> <a id="5940" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5944" class="Symbol">(</a><a id="5945" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="5947" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="5948" class="Symbol">)</a> <a id="5950" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5952" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5956" class="Symbol">(</a><a id="5957" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="5959" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="5960" class="Symbol">)</a>
     <a id="5967" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="5970" class="Symbol">=</a> <a id="5972" href="UF.Base.html#11014" class="Function">happly</a> <a id="5979" href="SyntheticHomotopyTheory.Circle.Induction.html#5245" class="Function">r-is-retraction-of-pr₁</a> <a id="6002" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a>
     <a id="6009" href="SyntheticHomotopyTheory.Circle.Induction.html#6009" class="Function">γ₂</a> <a id="6012" class="Symbol">=</a> <a id="6014" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6024" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6026" class="Symbol">(</a><a id="6027" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6030" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6032" class="Symbol">)</a> <a id="6034" class="Symbol">(</a><a id="6035" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6039" class="Symbol">(</a><a id="6040" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6042" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6043" class="Symbol">))</a>                  <a id="6063" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6066" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="6071" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="6083" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6093" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6095" class="Symbol">(</a><a id="6096" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6099" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6101" class="Symbol">)</a> <a id="6103" class="Symbol">(</a><a id="6104" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6114" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6116" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6119" class="Symbol">(</a><a id="6120" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6124" class="Symbol">(</a><a id="6125" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6127" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6128" class="Symbol">)))</a> <a id="6132" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6135" href="SyntheticHomotopyTheory.Circle.Induction.html#6360" class="Function">I</a>    <a id="6140" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="6152" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6162" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6164" class="Symbol">(</a><a id="6165" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6168" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="6170" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6173" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6175" class="Symbol">)</a> <a id="6177" class="Symbol">(</a><a id="6178" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6182" class="Symbol">(</a><a id="6183" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6185" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6186" class="Symbol">))</a>             <a id="6201" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6204" href="SyntheticHomotopyTheory.Circle.Induction.html#6402" class="Function">II</a>   <a id="6209" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="6221" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6231" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6233" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="6238" class="Symbol">(</a><a id="6239" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6243" class="Symbol">(</a><a id="6244" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6246" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6247" class="Symbol">))</a>                     <a id="6270" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6273" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="6278" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="6290" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6294" class="Symbol">(</a><a id="6295" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6297" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6298" class="Symbol">)</a>                                        <a id="6339" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="6347" class="Keyword">where</a>
       <a id="6360" href="SyntheticHomotopyTheory.Circle.Induction.html#6360" class="Function">I</a>  <a id="6363" class="Symbol">=</a> <a id="6365" class="Symbol">(</a><a id="6366" href="UF.Base.html#4718" class="Function">transport-∙</a> <a id="6378" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6380" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6383" class="Symbol">(</a><a id="6384" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a> <a id="6387" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6389" class="Symbol">))</a> <a id="6392" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
       <a id="6402" href="SyntheticHomotopyTheory.Circle.Induction.html#6402" class="Function">II</a> <a id="6405" class="Symbol">=</a> <a id="6407" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6410" class="Symbol">(λ</a> <a id="6413" href="SyntheticHomotopyTheory.Circle.Induction.html#6413" class="Bound">-</a> <a id="6415" class="Symbol">→</a> <a id="6417" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6427" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="6429" href="SyntheticHomotopyTheory.Circle.Induction.html#6413" class="Bound">-</a> <a id="6431" class="Symbol">(</a><a id="6432" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6436" class="Symbol">(</a><a id="6437" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6439" href="SyntheticHomotopyTheory.Circle.Induction.html#5894" class="Bound">x</a><a id="6440" class="Symbol">)))</a> <a id="6444" class="Symbol">((</a><a id="6446" href="UF.Base.html#11903" class="Function">right-inverse</a> <a id="6460" href="SyntheticHomotopyTheory.Circle.Induction.html#5935" class="Function">γ₁</a><a id="6462" class="Symbol">)</a> <a id="6464" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6466" class="Symbol">)</a>

   <a id="6472" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a> <a id="6497" class="Symbol">:</a> <a id="6499" class="Symbol">(</a><a id="6500" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6502" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="6507" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6509" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6512" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6514" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="6518" class="Symbol">)</a> <a id="6520" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="6523" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="6525" class="Symbol">(</a><a id="6526" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="6528" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a><a id="6529" class="Symbol">)</a> <a id="6531" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="6533" class="Symbol">(</a><a id="6534" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6536" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="6541" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6543" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6546" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6548" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="6552" class="Symbol">)</a>
   <a id="6557" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a> <a id="6582" class="Symbol">=</a> <a id="6584" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="6591" class="Symbol">(</a><a id="6592" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6605" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="6610" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6612" href="SyntheticHomotopyTheory.Circle.Induction.html#6630" class="Function">γ</a><a id="6613" class="Symbol">)</a>
    <a id="6619" class="Keyword">where</a>
     <a id="6630" href="SyntheticHomotopyTheory.Circle.Induction.html#6630" class="Function">γ</a> <a id="6632" class="Symbol">=</a> <a id="6634" href="MLTT.Id.html#735" class="Function">transport</a> <a id="6644" class="Symbol">(λ</a> <a id="6647" href="SyntheticHomotopyTheory.Circle.Induction.html#6647" class="Bound">-</a> <a id="6649" class="Symbol">→</a> <a id="6651" href="SyntheticHomotopyTheory.Circle.Induction.html#6647" class="Bound">-</a> <a id="6653" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6655" href="SyntheticHomotopyTheory.Circle.Induction.html#6647" class="Bound">-</a><a id="6656" class="Symbol">)</a> <a id="6658" class="Symbol">(</a><a id="6659" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6672" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="6676" class="Symbol">)</a> <a id="6678" class="Symbol">(</a><a id="6679" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6682" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6684" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="6688" class="Symbol">)</a> <a id="6690" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6693" href="SyntheticHomotopyTheory.Circle.Induction.html#6857" class="Function">I</a>  <a id="6696" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="6707" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6720" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="6725" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="6728" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="6730" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6733" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6735" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="6740" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="6742" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6755" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>    <a id="6763" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="6766" href="SyntheticHomotopyTheory.Circle.Induction.html#6919" class="Function">II</a> <a id="6769" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="6780" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6783" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6785" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>                                               <a id="6836" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="6844" class="Keyword">where</a>
       <a id="6857" href="SyntheticHomotopyTheory.Circle.Induction.html#6857" class="Function">I</a>  <a id="6860" class="Symbol">=</a> <a id="6862" href="UF.Base.html#16880" class="Function">transport-along-＝</a> <a id="6880" class="Symbol">(</a><a id="6881" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6894" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="6898" class="Symbol">)</a> <a id="6900" class="Symbol">(</a><a id="6901" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6904" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6906" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="6910" class="Symbol">)</a>
       <a id="6919" href="SyntheticHomotopyTheory.Circle.Induction.html#6919" class="Function">II</a> <a id="6922" class="Symbol">=</a> <a id="6924" href="UF.Base.html#13580" class="Function">homotopies-are-natural&#39;&#39;</a> <a id="6949" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="6951" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="6953" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="6966" class="Symbol">{</a><a id="6967" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="6971" class="Symbol">}</a> <a id="6973" class="Symbol">{</a><a id="6974" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="6978" class="Symbol">}</a> <a id="6980" class="Symbol">{</a><a id="6981" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="6985" class="Symbol">}</a>

   <a id="6991" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a> <a id="6998" class="Symbol">:</a> <a id="7000" class="Symbol">(</a><a id="7001" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="7003" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="7008" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="7010" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7013" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="7015" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="7019" class="Symbol">)</a> <a id="7021" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="7024" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="7026" class="Symbol">(</a><a id="7027" href="MLTT.Sigma-Type.html#116" class="Record">Σ</a> <a id="7029" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a><a id="7030" class="Symbol">)</a> <a id="7032" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="7034" class="Symbol">((</a><a id="7036" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="7041" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="7043" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="7044" class="Symbol">)</a> <a id="7046" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="7048" href="SyntheticHomotopyTheory.Circle.Induction.html#4482" class="Function">l⁺</a><a id="7050" class="Symbol">)</a>
   <a id="7055" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a> <a id="7062" class="Symbol">=</a> <a id="7064" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a> <a id="7089" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="7091" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>

<a id="7099" class="Markup">\end{code}</a><a id="7109" class="Background">

Looking at ρ-comp, we see that ρ base = (base , 𝕊¹-induction base) ＝ (base , a),
which looks promising, for if we can show that the equality in the first
component is refl, then 𝕊¹-induction base ＝ a would follow. So that&#39;s exactly
what we do next.

</a><a id="7361" class="Markup">\begin{code}</a>

   <a id="7378" href="SyntheticHomotopyTheory.Circle.Induction.html#7378" class="Function">ρ-comp-lemma</a> <a id="7391" class="Symbol">:</a> <a id="7393" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7396" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7400" class="Symbol">(</a><a id="7401" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7404" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7408" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="7414" class="Symbol">)</a> <a id="7416" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7418" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
   <a id="7426" href="SyntheticHomotopyTheory.Circle.Induction.html#7378" class="Function">ρ-comp-lemma</a> <a id="7439" class="Symbol">=</a>
    <a id="7445" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7448" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7452" class="Symbol">(</a><a id="7453" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7456" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7460" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="7466" class="Symbol">)</a>                                          <a id="7509" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="7512" href="SyntheticHomotopyTheory.Circle.Induction.html#7878" class="Function">I</a>   <a id="7516" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="7522" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7525" class="Symbol">(</a><a id="7526" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7530" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7532" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="7535" class="Symbol">)</a> <a id="7537" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a>                                           <a id="7586" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="7589" href="SyntheticHomotopyTheory.Circle.Induction.html#7910" class="Function">II</a>  <a id="7593" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="7599" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7602" class="Symbol">(</a><a id="7603" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7607" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7609" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="7612" class="Symbol">)</a> <a id="7614" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a> <a id="7639" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="7641" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="7644" class="Symbol">(</a><a id="7645" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7649" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7651" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="7654" class="Symbol">)</a> <a id="7656" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a> <a id="7663" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="7666" href="SyntheticHomotopyTheory.Circle.Induction.html#7996" class="Function">III</a> <a id="7670" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="7676" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a> <a id="7678" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="7681" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="7683" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a>                                                        <a id="7740" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="7743" href="SyntheticHomotopyTheory.Circle.Induction.html#7970" class="Function">IV</a>  <a id="7747" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="7753" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>                                                            <a id="7817" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
    <a id="7823" class="Keyword">where</a>
     <a id="7834" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a> <a id="7836" class="Symbol">=</a> <a id="7838" href="UF.Base.html#11014" class="Function">happly</a> <a id="7845" href="SyntheticHomotopyTheory.Circle.Induction.html#5245" class="Function">r-is-retraction-of-pr₁</a> <a id="7868" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>
     <a id="7878" href="SyntheticHomotopyTheory.Circle.Induction.html#7878" class="Function">I</a>   <a id="7882" class="Symbol">=</a> <a id="7884" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="7890" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7894" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7898" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a>
     <a id="7910" href="SyntheticHomotopyTheory.Circle.Induction.html#7910" class="Function">II</a>  <a id="7914" class="Symbol">=</a> <a id="7916" href="UF.Base.html#7618" class="Function">ap-∙</a> <a id="7921" class="Symbol">(</a><a id="7922" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="7926" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7928" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="7931" class="Symbol">)</a> <a id="7933" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a> <a id="7958" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>
     <a id="7970" href="SyntheticHomotopyTheory.Circle.Induction.html#7970" class="Function">IV</a>  <a id="7974" class="Symbol">=</a> <a id="7976" href="UF.Base.html#11795" class="Function">left-inverse</a> <a id="7989" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a>
     <a id="7996" href="SyntheticHomotopyTheory.Circle.Induction.html#7996" class="Function">III</a> <a id="8000" class="Symbol">=</a> <a id="8002" href="UF.Base.html#8182" class="Function">ap₂</a> <a id="8006" href="MLTT.Id.html#968" class="Function Operator">_∙_</a> <a id="8010" href="SyntheticHomotopyTheory.Circle.Induction.html#8035" class="Function">γ₁</a> <a id="8013" href="SyntheticHomotopyTheory.Circle.Induction.html#8524" class="Function">γ₂</a>
      <a id="8022" class="Keyword">where</a>
       <a id="8035" href="SyntheticHomotopyTheory.Circle.Induction.html#8035" class="Function">γ₁</a> <a id="8038" class="Symbol">:</a> <a id="8040" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8043" class="Symbol">(</a><a id="8044" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8048" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="8050" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="8053" class="Symbol">)</a> <a id="8055" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a>  <a id="8081" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="8083" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a> <a id="8085" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
       <a id="8095" href="SyntheticHomotopyTheory.Circle.Induction.html#8035" class="Function">γ₁</a> <a id="8098" class="Symbol">=</a> <a id="8100" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8103" class="Symbol">(</a><a id="8104" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8108" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="8110" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="8113" class="Symbol">)</a> <a id="8115" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a>  <a id="8141" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8144" href="SyntheticHomotopyTheory.Circle.Induction.html#8355" class="Function">I₁</a>   <a id="8149" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
            <a id="8163" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8166" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8170" class="Symbol">(</a><a id="8171" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8174" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8178" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a><a id="8202" class="Symbol">)</a> <a id="8204" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8207" href="SyntheticHomotopyTheory.Circle.Induction.html#8415" class="Function">II₁</a>  <a id="8212" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
            <a id="8226" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8229" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8233" class="Symbol">(</a><a id="8234" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="8247" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="8251" class="Symbol">)</a>               <a id="8267" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8270" href="SyntheticHomotopyTheory.Circle.Induction.html#8483" class="Function">III₁</a> <a id="8275" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
            <a id="8289" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a> <a id="8291" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>                                     <a id="8330" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
        <a id="8340" class="Keyword">where</a>
         <a id="8355" href="SyntheticHomotopyTheory.Circle.Induction.html#8355" class="Function">I₁</a>   <a id="8360" class="Symbol">=</a> <a id="8362" class="Symbol">(</a><a id="8363" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="8369" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8373" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8377" href="SyntheticHomotopyTheory.Circle.Induction.html#6472" class="Function">ρ-and-r-on-base-and-loop</a><a id="8401" class="Symbol">)</a> <a id="8403" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
         <a id="8415" href="SyntheticHomotopyTheory.Circle.Induction.html#8415" class="Function">II₁</a>  <a id="8420" class="Symbol">=</a> <a id="8422" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8425" class="Symbol">(</a><a id="8426" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8429" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="8432" class="Symbol">)</a> <a id="8434" class="Symbol">(</a><a id="8435" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="8449" class="Symbol">(</a><a id="8450" href="SyntheticHomotopyTheory.Circle.Induction.html#5857" class="Function">ρ-r-homotopy</a> <a id="8463" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="8468" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8470" class="Symbol">_))</a>
         <a id="8483" href="SyntheticHomotopyTheory.Circle.Induction.html#8483" class="Function">III₁</a> <a id="8488" class="Symbol">=</a> <a id="8490" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="8504" class="Symbol">((</a><a id="8506" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a> <a id="8508" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="8510" class="Symbol">)</a> <a id="8512" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8514" class="Symbol">_)</a>
       <a id="8524" href="SyntheticHomotopyTheory.Circle.Induction.html#8524" class="Function">γ₂</a> <a id="8527" class="Symbol">:</a> <a id="8529" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8532" class="Symbol">(</a><a id="8533" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8537" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="8539" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="8542" class="Symbol">)</a> <a id="8544" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a> <a id="8551" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="8553" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a>
       <a id="8562" href="SyntheticHomotopyTheory.Circle.Induction.html#8524" class="Function">γ₂</a> <a id="8565" class="Symbol">=</a> <a id="8567" href="SyntheticHomotopyTheory.Circle.Induction.html#8627" class="Function">ϕ</a> <a id="8569" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
        <a id="8580" class="Keyword">where</a>
         <a id="8595" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a> <a id="8597" class="Symbol">=</a> <a id="8599" href="SyntheticHomotopyTheory.Circle.Induction.html#4768" class="Function">r-retraction-lemma</a>
         <a id="8627" href="SyntheticHomotopyTheory.Circle.Induction.html#8627" class="Function">ϕ</a> <a id="8629" class="Symbol">=</a> <a id="8631" href="SyntheticHomotopyTheory.Circle.Induction.html#7834" class="Function">p</a>                                                     <a id="8685" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8688" href="SyntheticHomotopyTheory.Circle.Induction.html#9150" class="Function">I₂</a>    <a id="8694" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
             <a id="8709" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8712" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8716" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a> <a id="8718" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="8720" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8723" href="SyntheticHomotopyTheory.Circle.Induction.html#9104" class="Function">π</a> <a id="8725" class="Symbol">(</a><a id="8726" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="8733" class="Symbol">(</a><a id="8734" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="8739" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8741" href="UF.Base.html#7444" class="Function">ap-id-is-id</a> <a id="8753" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="8757" class="Symbol">))</a> <a id="8760" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="8763" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8766" href="SyntheticHomotopyTheory.Circle.Induction.html#9438" class="Function">II₂</a>   <a id="8772" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
             <a id="8787" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8790" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8794" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a> <a id="8796" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="8798" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="8803" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>                                    <a id="8841" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8844" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>  <a id="8850" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
             <a id="8865" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8868" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8872" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a>                                              <a id="8919" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="8922" href="SyntheticHomotopyTheory.Circle.Induction.html#9640" class="Function">III₂</a>  <a id="8928" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
             <a id="8943" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8946" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8950" class="Symbol">(</a><a id="8951" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="8954" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="8958" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a><a id="8964" class="Symbol">)</a>                                <a id="8997" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9000" href="SyntheticHomotopyTheory.Circle.Induction.html#9601" class="Function">IV₂</a>   <a id="9006" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
             <a id="9021" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9024" class="Symbol">(</a><a id="9025" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9029" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9031" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="9034" class="Symbol">)</a> <a id="9036" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>                                 <a id="9075" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
          <a id="9087" class="Keyword">where</a>
           <a id="9104" href="SyntheticHomotopyTheory.Circle.Induction.html#9104" class="Function">π</a> <a id="9106" class="Symbol">:</a> <a id="9108" href="SyntheticHomotopyTheory.Circle.Induction.html#863" class="Function">𝓛</a> <a id="9110" class="Symbol">(</a><a id="9111" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="9113" class="Symbol">)</a> <a id="9115" class="Symbol">→</a> <a id="9117" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a>
           <a id="9131" href="SyntheticHomotopyTheory.Circle.Induction.html#9104" class="Function">π</a> <a id="9133" class="Symbol">=</a> <a id="9135" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a>
           <a id="9150" href="SyntheticHomotopyTheory.Circle.Induction.html#9150" class="Function">I₂</a>   <a id="9155" class="Symbol">=</a> <a id="9157" href="SyntheticHomotopyTheory.Circle.Induction.html#1792" class="Function">happly-𝓛-functor-lemma</a> <a id="9180" class="Symbol">(</a><a id="9181" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9185" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9187" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a><a id="9188" class="Symbol">)</a> <a id="9190" href="MLTT.Pi.html#444" class="Function">id</a> <a id="9193" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="9198" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
                   <a id="9222" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a> <a id="9224" class="Symbol">(</a><a id="9225" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="9232" class="Symbol">(</a><a id="9233" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="9238" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9240" href="UF.Base.html#7444" class="Function">ap-id-is-id</a> <a id="9252" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="9256" class="Symbol">))</a>
                   <a id="9278" class="Symbol">(</a><a id="9279" href="SyntheticHomotopyTheory.Circle.Induction.html#2977" class="Function">𝕊¹-at-most-one-function</a> <a id="9303" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="9308" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
                     <a id="9334" class="Symbol">(</a><a id="9335" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9339" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9341" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="9343" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9345" href="SyntheticHomotopyTheory.Circle.Induction.html#4768" class="Function">r-retraction-lemma</a><a id="9363" class="Symbol">)</a>
                     <a id="9386" class="Symbol">(</a><a id="9387" href="MLTT.Pi.html#444" class="Function">id</a> <a id="9390" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9392" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="9399" class="Symbol">(</a><a id="9400" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="9405" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9407" href="UF.Base.html#7444" class="Function">ap-id-is-id</a> <a id="9419" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="9423" class="Symbol">)))</a>
           <a id="9438" href="SyntheticHomotopyTheory.Circle.Induction.html#9438" class="Function">II₂</a>  <a id="9443" class="Symbol">=</a> <a id="9445" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9448" class="Symbol">(λ</a> <a id="9451" href="SyntheticHomotopyTheory.Circle.Induction.html#9451" class="Bound">-</a> <a id="9453" class="Symbol">→</a> <a id="9455" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9458" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9462" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a> <a id="9464" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9466" href="SyntheticHomotopyTheory.Circle.Induction.html#9451" class="Bound">-</a> <a id="9468" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="9470" class="Symbol">)</a>
                   <a id="9491" class="Symbol">(</a><a id="9492" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="9506" class="Symbol">{</a><a id="9507" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="9508" class="Symbol">}</a> <a id="9510" class="Symbol">{</a><a id="9511" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="9512" class="Symbol">}</a> <a id="9514" class="Symbol">{</a><a id="9515" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="9517" class="Symbol">}</a> <a id="9519" class="Symbol">{λ</a> <a id="9522" href="SyntheticHomotopyTheory.Circle.Induction.html#9522" class="Bound">-</a> <a id="9524" class="Symbol">→</a> <a id="9526" class="Symbol">(</a><a id="9527" href="SyntheticHomotopyTheory.Circle.Induction.html#9522" class="Bound">-</a> <a id="9529" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="9531" href="SyntheticHomotopyTheory.Circle.Induction.html#9522" class="Bound">-</a><a id="9532" class="Symbol">)}</a> <a id="9535" class="Symbol">{_}</a> <a id="9539" class="Symbol">{_}</a>
                    <a id="9563" class="Symbol">(</a><a id="9564" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="9569" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9571" href="UF.Base.html#7444" class="Function">ap-id-is-id</a> <a id="9583" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="9587" class="Symbol">))</a>
           <a id="9601" href="SyntheticHomotopyTheory.Circle.Induction.html#9601" class="Function">IV₂</a>  <a id="9606" class="Symbol">=</a> <a id="9608" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="9614" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9618" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9622" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>
           <a id="9640" href="SyntheticHomotopyTheory.Circle.Induction.html#9640" class="Function">III₂</a> <a id="9645" class="Symbol">=</a> <a id="9647" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9650" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9654" href="SyntheticHomotopyTheory.Circle.Induction.html#8595" class="Function">κ</a>                        <a id="9679" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9682" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="9687" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="9707" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9710" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9714" class="Symbol">(</a><a id="9715" href="SyntheticHomotopyTheory.Circle.Induction.html#10324" class="Function">κ₁</a> <a id="9718" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9720" class="Symbol">(</a><a id="9721" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="9724" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9726" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="9728" class="Symbol">))</a>         <a id="9739" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9742" href="SyntheticHomotopyTheory.Circle.Induction.html#10505" class="Function">I&#39;</a>   <a id="9747" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="9767" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9770" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9774" href="SyntheticHomotopyTheory.Circle.Induction.html#10324" class="Function">κ₁</a> <a id="9777" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9779" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9782" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9786" class="Symbol">(</a><a id="9787" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="9790" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9792" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="9794" class="Symbol">)</a>    <a id="9799" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9802" href="SyntheticHomotopyTheory.Circle.Induction.html#10553" class="Function">II&#39;</a>  <a id="9807" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="9827" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="9832" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9834" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9837" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9841" class="Symbol">(</a><a id="9842" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="9845" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9847" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="9849" class="Symbol">)</a>         <a id="9859" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9862" href="SyntheticHomotopyTheory.Circle.Induction.html#10747" class="Function">III&#39;</a> <a id="9867" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="9887" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9890" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9894" class="Symbol">(</a><a id="9895" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="9898" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9900" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="9902" class="Symbol">)</a>                <a id="9919" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9922" href="SyntheticHomotopyTheory.Circle.Induction.html#10791" class="Function">IV&#39;</a>  <a id="9927" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="9947" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9950" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9954" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="9957" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="9959" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="9962" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="9966" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a>           <a id="9979" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="9982" href="SyntheticHomotopyTheory.Circle.Induction.html#10832" class="Function">V&#39;</a>   <a id="9987" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="10007" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10010" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10014" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="10017" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="10019" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>                <a id="10039" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="10042" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10047" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="10067" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10070" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10074" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a>                       <a id="10099" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="10102" href="SyntheticHomotopyTheory.Circle.Induction.html#11020" class="Function">VI&#39;</a>  <a id="10107" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="10127" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10130" class="Symbol">(</a><a id="10131" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10135" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="10137" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="10147" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="10150" class="Symbol">)</a> <a id="10152" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a> <a id="10159" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="10162" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10167" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="10187" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10190" class="Symbol">(</a><a id="10191" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10195" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="10197" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="10200" class="Symbol">)</a> <a id="10202" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>           <a id="10219" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="10222" href="SyntheticHomotopyTheory.Circle.Induction.html#11079" class="Function">VII&#39;</a> <a id="10227" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                  <a id="10247" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10250" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10254" class="Symbol">(</a><a id="10255" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10258" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10262" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a><a id="10268" class="Symbol">)</a>          <a id="10279" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
                  <a id="10299" class="Keyword">where</a>
                   <a id="10324" href="SyntheticHomotopyTheory.Circle.Induction.html#10324" class="Function">κ₁</a> <a id="10327" class="Symbol">=</a> <a id="10329" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="10336" class="Symbol">(</a><a id="10337" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10342" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10344" class="Symbol">((</a><a id="10346" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="10352" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="10354" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10358" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="10362" class="Symbol">)</a> <a id="10364" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="10366" class="Symbol">))</a>
                   <a id="10388" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="10391" class="Symbol">=</a> <a id="10393" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10396" class="Symbol">(</a><a id="10397" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="10407" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="10410" class="Symbol">)</a> <a id="10412" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>
                   <a id="10438" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a> <a id="10441" class="Symbol">=</a> <a id="10443" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="10450" class="Symbol">(</a><a id="10451" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10456" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10458" class="Symbol">(</a><a id="10459" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="10473" class="Symbol">(</a><a id="10474" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="10479" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10481" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="10482" class="Symbol">)))</a>
                   <a id="10505" href="SyntheticHomotopyTheory.Circle.Induction.html#10505" class="Function">I&#39;</a>   <a id="10510" class="Symbol">=</a> <a id="10512" href="UF.Base.html#7618" class="Function">ap-∙</a> <a id="10517" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10521" href="SyntheticHomotopyTheory.Circle.Induction.html#10324" class="Function">κ₁</a> <a id="10524" class="Symbol">(</a><a id="10525" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="10528" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="10530" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="10532" class="Symbol">)</a>
                   <a id="10553" href="SyntheticHomotopyTheory.Circle.Induction.html#10553" class="Function">II&#39;</a>  <a id="10558" class="Symbol">=</a> <a id="10560" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10563" class="Symbol">(</a><a id="10564" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="10567" class="Symbol">(</a><a id="10568" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10571" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10575" class="Symbol">(</a><a id="10576" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="10579" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="10581" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a><a id="10583" class="Symbol">)))</a>
                           <a id="10614" class="Symbol">(</a><a id="10615" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="10629" class="Symbol">{</a><a id="10630" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="10631" class="Symbol">}</a> <a id="10633" class="Symbol">{</a><a id="10634" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="10635" class="Symbol">}</a> <a id="10637" class="Symbol">{</a><a id="10638" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="10640" class="Symbol">}</a> <a id="10642" class="Symbol">{λ</a> <a id="10645" href="SyntheticHomotopyTheory.Circle.Induction.html#10645" class="Bound">-</a> <a id="10647" class="Symbol">→</a> <a id="10649" class="Symbol">(</a><a id="10650" href="SyntheticHomotopyTheory.Circle.Induction.html#10645" class="Bound">-</a> <a id="10652" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10654" href="SyntheticHomotopyTheory.Circle.Induction.html#10645" class="Bound">-</a><a id="10655" class="Symbol">)}</a> <a id="10658" class="Symbol">{_}</a> <a id="10662" class="Symbol">{_}</a>
                            <a id="10694" class="Symbol">(</a><a id="10695" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10700" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10702" class="Symbol">((</a><a id="10704" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="10710" href="SyntheticHomotopyTheory.Circle.Induction.html#4548" class="Function">r</a> <a id="10712" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10716" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="10720" class="Symbol">)</a> <a id="10722" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="10724" class="Symbol">)))</a>
                   <a id="10747" href="SyntheticHomotopyTheory.Circle.Induction.html#10747" class="Function">III&#39;</a> <a id="10752" class="Symbol">=</a> <a id="10754" href="UF.Base.html#10546" class="Function">refl-left-neutral</a>
                   <a id="10791" href="SyntheticHomotopyTheory.Circle.Induction.html#10791" class="Function">IV&#39;</a>  <a id="10796" class="Symbol">=</a> <a id="10798" href="UF.Base.html#7618" class="Function">ap-∙</a> <a id="10803" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10807" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a> <a id="10810" href="SyntheticHomotopyTheory.Circle.Induction.html#10438" class="Function">κ₃</a>
                   <a id="10832" href="SyntheticHomotopyTheory.Circle.Induction.html#10832" class="Function">V&#39;</a>   <a id="10837" class="Symbol">=</a> <a id="10839" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10842" class="Symbol">((</a><a id="10844" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="10847" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="10851" href="SyntheticHomotopyTheory.Circle.Induction.html#10388" class="Function">κ₂</a><a id="10853" class="Symbol">)</a> <a id="10855" href="MLTT.Id.html#968" class="Function Operator">∙_</a><a id="10857" class="Symbol">)</a>
                           <a id="10886" class="Symbol">(</a><a id="10887" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="10901" class="Symbol">{</a><a id="10902" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="10903" class="Symbol">}</a> <a id="10905" class="Symbol">{</a><a id="10906" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="10907" class="Symbol">}</a> <a id="10909" class="Symbol">{</a><a id="10910" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="10912" class="Symbol">}</a> <a id="10914" class="Symbol">{λ</a> <a id="10917" href="SyntheticHomotopyTheory.Circle.Induction.html#10917" class="Bound">-</a> <a id="10919" class="Symbol">→</a> <a id="10921" class="Symbol">(</a><a id="10922" href="SyntheticHomotopyTheory.Circle.Induction.html#10917" class="Bound">-</a> <a id="10924" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10926" href="SyntheticHomotopyTheory.Circle.Induction.html#10917" class="Bound">-</a><a id="10927" class="Symbol">)}</a> <a id="10930" class="Symbol">{_}</a> <a id="10934" class="Symbol">{_}</a>
                            <a id="10966" class="Symbol">(</a><a id="10967" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="10972" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10974" href="UF.Base.html#15319" class="Function">ap-pr₁-to-Σ-＝</a> <a id="10988" class="Symbol">(</a><a id="10989" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="10994" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10996" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="10997" class="Symbol">)))</a>
                   <a id="11020" href="SyntheticHomotopyTheory.Circle.Induction.html#11020" class="Function">VI&#39;</a>  <a id="11025" class="Symbol">=</a> <a id="11027" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="11033" class="Symbol">(</a><a id="11034" href="SyntheticHomotopyTheory.Circle.Induction.html#907" class="Function">𝓛-functor</a> <a id="11044" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a><a id="11047" class="Symbol">)</a> <a id="11049" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11053" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a>
                   <a id="11079" href="SyntheticHomotopyTheory.Circle.Induction.html#11079" class="Function">VII&#39;</a> <a id="11084" class="Symbol">=</a> <a id="11086" class="Symbol">(</a><a id="11087" href="UF.Base.html#8001" class="Function">ap-ap</a> <a id="11093" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11097" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11101" href="SyntheticHomotopyTheory.Circle.Induction.html#5754" class="Function">r-comp</a><a id="11107" class="Symbol">)</a> <a id="11109" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>

   <a id="11116" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="11137" class="Symbol">:</a> <a id="11139" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="11152" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="11157" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="11159" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a>
   <a id="11164" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="11185" class="Symbol">=</a>
    <a id="11191" href="MLTT.Id.html#735" class="Function">transport</a> <a id="11201" class="Symbol">(λ</a> <a id="11204" href="SyntheticHomotopyTheory.Circle.Induction.html#11204" class="Bound">-</a> <a id="11206" class="Symbol">→</a> <a id="11208" href="MLTT.Id.html#735" class="Function">transport</a> <a id="11218" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="11220" href="SyntheticHomotopyTheory.Circle.Induction.html#11204" class="Bound">-</a> <a id="11222" class="Symbol">(</a><a id="11223" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="11236" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="11240" class="Symbol">)</a> <a id="11242" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="11244" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="11245" class="Symbol">)</a> <a id="11247" href="SyntheticHomotopyTheory.Circle.Induction.html#7378" class="Function">ρ-comp-lemma</a> <a id="11260" href="SyntheticHomotopyTheory.Circle.Induction.html#11279" class="Function">γ</a>
     <a id="11267" class="Keyword">where</a>
      <a id="11279" href="SyntheticHomotopyTheory.Circle.Induction.html#11279" class="Function">γ</a> <a id="11281" class="Symbol">:</a> <a id="11283" href="MLTT.Id.html#735" class="Function">transport</a> <a id="11293" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="11295" class="Symbol">(</a><a id="11296" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="11299" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11303" class="Symbol">(</a><a id="11304" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="11307" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11311" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="11317" class="Symbol">))</a> <a id="11320" class="Symbol">(</a><a id="11321" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="11334" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="11338" class="Symbol">)</a> <a id="11340" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="11342" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a>
      <a id="11350" href="SyntheticHomotopyTheory.Circle.Induction.html#11279" class="Function">γ</a> <a id="11352" class="Symbol">=</a> <a id="11354" href="UF.Base.html#14834" class="Function">from-Σ-＝&#39;</a> <a id="11364" class="Symbol">(</a><a id="11365" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="11368" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="11372" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="11378" class="Symbol">)</a>

<a id="11381" class="Markup">\end{code}</a><a id="11391" class="Background">

This takes care of the first computation rule for 𝕊¹-induction. We can
get a fairly direct proof of the second computation rule (the one for
loop) by assuming that base ＝ base is a set, because this tells us
that every element of loop ＝ loop must be refl.

We can satisfy this assumption for our intended application (see
CircleConstruction.lagda), because for the construction involving ℤ-torsors it&#39;s
is quite easy to prove that base ＝ base is a set.

However, for completeness sake, below we also show that assuming function
extensionality and univalence, it is possible to prove that base ＝ base is a
set, by using both computation rules for 𝕊¹-rec and the first computation rule
for 𝕊¹-induction.

</a><a id="12096" class="Markup">\begin{code}</a>

   <a id="12113" href="SyntheticHomotopyTheory.Circle.Induction.html#12113" class="Function">𝕊¹-induction-on-loop-lemma</a> <a id="12140" class="Symbol">:</a> <a id="12142" class="Symbol">(</a><a id="12143" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12148" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12150" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12160" class="Symbol">(λ</a> <a id="12163" href="SyntheticHomotopyTheory.Circle.Induction.html#12163" class="Bound">-</a> <a id="12165" class="Symbol">→</a> <a id="12167" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12177" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="12179" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12184" href="SyntheticHomotopyTheory.Circle.Induction.html#12163" class="Bound">-</a> <a id="12186" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12188" href="SyntheticHomotopyTheory.Circle.Induction.html#12163" class="Bound">-</a><a id="12189" class="Symbol">)</a>
                                         <a id="12232" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a>
                                         <a id="12294" class="Symbol">(</a><a id="12295" href="UF.Base.html#7318" class="Function">apd</a> <a id="12299" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="12312" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="12316" class="Symbol">))</a>
                              <a id="12349" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12351" class="Symbol">(</a><a id="12352" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12357" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12359" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="12360" class="Symbol">)</a>
   <a id="12365" href="SyntheticHomotopyTheory.Circle.Induction.html#12113" class="Function">𝕊¹-induction-on-loop-lemma</a> <a id="12392" class="Symbol">=</a>
      <a id="12400" class="Symbol">(</a><a id="12401" href="UF.Base.html#15689" class="Function">fromto-Σ-＝</a> <a id="12412" class="Symbol">(</a><a id="12413" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12418" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12420" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12430" class="Symbol">(λ</a> <a id="12433" href="SyntheticHomotopyTheory.Circle.Induction.html#12433" class="Bound">-</a> <a id="12435" class="Symbol">→</a> <a id="12437" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12447" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="12449" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12454" href="SyntheticHomotopyTheory.Circle.Induction.html#12433" class="Bound">-</a> <a id="12456" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12458" href="SyntheticHomotopyTheory.Circle.Induction.html#12433" class="Bound">-</a><a id="12459" class="Symbol">)</a> <a id="12461" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a> <a id="12463" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="12464" class="Symbol">))</a> <a id="12467" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
    <a id="12474" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="12476" class="Symbol">(</a><a id="12477" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="12480" href="UF.Base.html#14997" class="Function">from-Σ-＝</a> <a id="12489" href="SyntheticHomotopyTheory.Circle.Induction.html#12598" class="Function">γ</a><a id="12490" class="Symbol">)</a> <a id="12492" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="12494" class="Symbol">(</a><a id="12495" href="UF.Base.html#15689" class="Function">fromto-Σ-＝</a> <a id="12506" class="Symbol">(</a><a id="12507" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12512" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12514" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="12515" class="Symbol">))</a>
     <a id="12523" class="Keyword">where</a>
      <a id="12535" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a> <a id="12537" class="Symbol">=</a> <a id="12539" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a>
      <a id="12566" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a> <a id="12568" class="Symbol">=</a> <a id="12570" href="UF.Base.html#7318" class="Function">apd</a> <a id="12574" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="12587" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
      <a id="12598" href="SyntheticHomotopyTheory.Circle.Induction.html#12598" class="Function">γ</a> <a id="12600" class="Symbol">:</a> <a id="12602" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12609" class="Symbol">(</a><a id="12610" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12615" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12617" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12627" class="Symbol">(λ</a> <a id="12630" href="SyntheticHomotopyTheory.Circle.Induction.html#12630" class="Bound">-</a> <a id="12632" class="Symbol">→</a> <a id="12634" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12644" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="12646" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12651" href="SyntheticHomotopyTheory.Circle.Induction.html#12630" class="Bound">-</a> <a id="12653" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12655" href="SyntheticHomotopyTheory.Circle.Induction.html#12630" class="Bound">-</a><a id="12656" class="Symbol">)</a> <a id="12658" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a> <a id="12660" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="12661" class="Symbol">)</a>
        <a id="12671" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12673" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12680" class="Symbol">(</a><a id="12681" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12686" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12688" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="12689" class="Symbol">)</a>
      <a id="12697" href="SyntheticHomotopyTheory.Circle.Induction.html#12598" class="Function">γ</a> <a id="12699" class="Symbol">=</a> <a id="12701" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12708" class="Symbol">(</a><a id="12709" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12714" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12716" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12726" class="Symbol">(λ</a> <a id="12729" href="SyntheticHomotopyTheory.Circle.Induction.html#12729" class="Bound">-</a> <a id="12731" class="Symbol">→</a> <a id="12733" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12743" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="12745" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12750" href="SyntheticHomotopyTheory.Circle.Induction.html#12729" class="Bound">-</a> <a id="12752" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12754" href="SyntheticHomotopyTheory.Circle.Induction.html#12729" class="Bound">-</a><a id="12755" class="Symbol">)</a> <a id="12757" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a> <a id="12759" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="12760" class="Symbol">)</a>    <a id="12765" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="12768" href="SyntheticHomotopyTheory.Circle.Induction.html#13120" class="Function">I</a>   <a id="12772" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="12784" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12794" class="Symbol">(λ</a> <a id="12797" href="SyntheticHomotopyTheory.Circle.Induction.html#12797" class="Bound">-</a> <a id="12799" class="Symbol">→</a> <a id="12801" href="SyntheticHomotopyTheory.Circle.Induction.html#12797" class="Bound">-</a> <a id="12803" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12805" href="SyntheticHomotopyTheory.Circle.Induction.html#12797" class="Bound">-</a><a id="12806" class="Symbol">)</a> <a id="12808" class="Symbol">(</a><a id="12809" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12816" class="Symbol">(</a><a id="12817" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="12822" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12824" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a><a id="12825" class="Symbol">))</a> <a id="12828" class="Symbol">(</a><a id="12829" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12836" class="Symbol">(</a><a id="12837" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12842" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12844" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="12845" class="Symbol">))</a> <a id="12848" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="12851" href="SyntheticHomotopyTheory.Circle.Induction.html#13462" class="Function">II</a>  <a id="12855" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="12867" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12877" class="Symbol">(λ</a> <a id="12880" href="SyntheticHomotopyTheory.Circle.Induction.html#12880" class="Bound">-</a> <a id="12882" class="Symbol">→</a> <a id="12884" href="SyntheticHomotopyTheory.Circle.Induction.html#12880" class="Bound">-</a> <a id="12886" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12888" href="SyntheticHomotopyTheory.Circle.Induction.html#12880" class="Bound">-</a><a id="12889" class="Symbol">)</a> <a id="12891" class="Symbol">(</a><a id="12892" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="12895" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="12899" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="12905" class="Symbol">)</a> <a id="12907" class="Symbol">(</a><a id="12908" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="12915" class="Symbol">(</a><a id="12916" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="12921" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12923" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="12924" class="Symbol">))</a>     <a id="12931" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="12934" href="SyntheticHomotopyTheory.Circle.Induction.html#13840" class="Function">III</a> <a id="12938" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="12950" href="MLTT.Id.html#735" class="Function">transport</a> <a id="12960" class="Symbol">(λ</a> <a id="12963" href="SyntheticHomotopyTheory.Circle.Induction.html#12963" class="Bound">-</a> <a id="12965" class="Symbol">→</a> <a id="12967" href="SyntheticHomotopyTheory.Circle.Induction.html#12963" class="Bound">-</a> <a id="12969" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12971" href="SyntheticHomotopyTheory.Circle.Induction.html#12963" class="Bound">-</a><a id="12972" class="Symbol">)</a> <a id="12974" class="Symbol">(</a><a id="12975" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="12978" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="12982" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="12988" class="Symbol">)</a> <a id="12990" class="Symbol">(</a><a id="12991" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="12994" href="SyntheticHomotopyTheory.Circle.Induction.html#5707" class="Function">ρ</a> <a id="12996" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="13000" class="Symbol">)</a>             <a id="13014" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="13017" href="SyntheticHomotopyTheory.Circle.Induction.html#14120" class="Function">IV</a>  <a id="13021" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
          <a id="13033" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13040" class="Symbol">(</a><a id="13041" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="13046" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13048" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="13049" class="Symbol">)</a>                                               <a id="13097" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
       <a id="13106" class="Keyword">where</a>
        <a id="13120" href="SyntheticHomotopyTheory.Circle.Induction.html#13120" class="Function">I</a>   <a id="13124" class="Symbol">=</a> <a id="13126" href="SyntheticHomotopyTheory.Circle.Induction.html#13162" class="Function">h</a> <a id="13128" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="13133" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a> <a id="13135" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a>
         <a id="13146" class="Keyword">where</a>
          <a id="13162" href="SyntheticHomotopyTheory.Circle.Induction.html#13162" class="Function">h</a> <a id="13164" class="Symbol">:</a> <a id="13166" class="Symbol">{</a><a id="13167" href="SyntheticHomotopyTheory.Circle.Induction.html#13167" class="Bound">X</a> <a id="13169" class="Symbol">:</a> <a id="13171" href="MLTT.Universes.html#3838" class="Generalizable">𝓦</a> <a id="13173" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="13175" class="Symbol">}</a> <a id="13177" class="Symbol">{</a><a id="13178" href="SyntheticHomotopyTheory.Circle.Induction.html#13178" class="Bound">Y</a> <a id="13180" class="Symbol">:</a> <a id="13182" href="SyntheticHomotopyTheory.Circle.Induction.html#13167" class="Bound">X</a> <a id="13184" class="Symbol">→</a> <a id="13186" href="MLTT.Universes.html#3840" class="Generalizable">𝓣</a> <a id="13188" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="13190" class="Symbol">}</a> <a id="13192" class="Symbol">{</a><a id="13193" href="SyntheticHomotopyTheory.Circle.Induction.html#13193" class="Bound">x</a> <a id="13195" class="Symbol">:</a> <a id="13197" href="SyntheticHomotopyTheory.Circle.Induction.html#13167" class="Bound">X</a><a id="13198" class="Symbol">}</a> <a id="13200" class="Symbol">(</a><a id="13201" href="SyntheticHomotopyTheory.Circle.Induction.html#13201" class="Bound">p</a> <a id="13203" class="Symbol">:</a> <a id="13205" href="SyntheticHomotopyTheory.Circle.Induction.html#13193" class="Bound">x</a> <a id="13207" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13209" href="SyntheticHomotopyTheory.Circle.Induction.html#13193" class="Bound">x</a><a id="13210" class="Symbol">)</a> <a id="13212" class="Symbol">{</a><a id="13213" href="SyntheticHomotopyTheory.Circle.Induction.html#13213" class="Bound">y</a> <a id="13215" href="SyntheticHomotopyTheory.Circle.Induction.html#13215" class="Bound">y&#39;</a> <a id="13218" class="Symbol">:</a> <a id="13220" href="SyntheticHomotopyTheory.Circle.Induction.html#13178" class="Bound">Y</a> <a id="13222" href="SyntheticHomotopyTheory.Circle.Induction.html#13193" class="Bound">x</a><a id="13223" class="Symbol">}</a>
              <a id="13239" class="Symbol">(</a><a id="13240" href="SyntheticHomotopyTheory.Circle.Induction.html#13240" class="Bound">q</a> <a id="13242" class="Symbol">:</a> <a id="13244" href="SyntheticHomotopyTheory.Circle.Induction.html#13213" class="Bound">y</a> <a id="13246" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13248" href="SyntheticHomotopyTheory.Circle.Induction.html#13215" class="Bound">y&#39;</a><a id="13250" class="Symbol">)</a> <a id="13252" class="Symbol">(</a><a id="13253" href="SyntheticHomotopyTheory.Circle.Induction.html#13253" class="Bound">q&#39;</a> <a id="13256" class="Symbol">:</a> <a id="13258" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13268" href="SyntheticHomotopyTheory.Circle.Induction.html#13178" class="Bound">Y</a> <a id="13270" href="SyntheticHomotopyTheory.Circle.Induction.html#13201" class="Bound">p</a> <a id="13272" href="SyntheticHomotopyTheory.Circle.Induction.html#13213" class="Bound">y</a> <a id="13274" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13276" href="SyntheticHomotopyTheory.Circle.Induction.html#13213" class="Bound">y</a><a id="13277" class="Symbol">)</a>
            <a id="13291" class="Symbol">→</a> <a id="13293" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13300" class="Symbol">(</a><a id="13301" href="SyntheticHomotopyTheory.Circle.Induction.html#13201" class="Bound">p</a> <a id="13303" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13305" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13315" class="Symbol">(λ</a> <a id="13318" href="SyntheticHomotopyTheory.Circle.Induction.html#13318" class="Bound">-</a> <a id="13320" class="Symbol">→</a> <a id="13322" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13332" href="SyntheticHomotopyTheory.Circle.Induction.html#13178" class="Bound">Y</a> <a id="13334" href="SyntheticHomotopyTheory.Circle.Induction.html#13201" class="Bound">p</a> <a id="13336" href="SyntheticHomotopyTheory.Circle.Induction.html#13318" class="Bound">-</a> <a id="13338" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13340" href="SyntheticHomotopyTheory.Circle.Induction.html#13318" class="Bound">-</a><a id="13341" class="Symbol">)</a> <a id="13343" href="SyntheticHomotopyTheory.Circle.Induction.html#13240" class="Bound">q</a> <a id="13345" href="SyntheticHomotopyTheory.Circle.Induction.html#13253" class="Bound">q&#39;</a><a id="13347" class="Symbol">)</a>
            <a id="13361" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13363" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13373" class="Symbol">(λ</a> <a id="13376" href="SyntheticHomotopyTheory.Circle.Induction.html#13376" class="Bound">-</a> <a id="13378" class="Symbol">→</a> <a id="13380" href="SyntheticHomotopyTheory.Circle.Induction.html#13376" class="Bound">-</a> <a id="13382" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13384" href="SyntheticHomotopyTheory.Circle.Induction.html#13376" class="Bound">-</a><a id="13385" class="Symbol">)</a> <a id="13387" class="Symbol">(</a><a id="13388" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13395" class="Symbol">(</a><a id="13396" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="13401" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13403" href="SyntheticHomotopyTheory.Circle.Induction.html#13240" class="Bound">q</a><a id="13404" class="Symbol">))</a> <a id="13407" class="Symbol">(</a><a id="13408" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13415" class="Symbol">(</a><a id="13416" href="SyntheticHomotopyTheory.Circle.Induction.html#13201" class="Bound">p</a> <a id="13418" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13420" href="SyntheticHomotopyTheory.Circle.Induction.html#13253" class="Bound">q&#39;</a><a id="13422" class="Symbol">))</a>
          <a id="13435" href="SyntheticHomotopyTheory.Circle.Induction.html#13162" class="Function">h</a> <a id="13437" href="SyntheticHomotopyTheory.Circle.Induction.html#13437" class="Bound">p</a> <a id="13439" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="13444" href="SyntheticHomotopyTheory.Circle.Induction.html#13444" class="Bound">q&#39;</a> <a id="13447" class="Symbol">=</a> <a id="13449" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
        <a id="13462" href="SyntheticHomotopyTheory.Circle.Induction.html#13462" class="Function">II</a>  <a id="13466" class="Symbol">=</a> <a id="13468" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13471" class="Symbol">(λ</a> <a id="13474" href="SyntheticHomotopyTheory.Circle.Induction.html#13474" class="Bound">-</a> <a id="13476" class="Symbol">→</a> <a id="13478" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13488" class="Symbol">(λ</a> <a id="13491" href="SyntheticHomotopyTheory.Circle.Induction.html#13491" class="Bound">-</a> <a id="13493" class="Symbol">→</a> <a id="13495" href="SyntheticHomotopyTheory.Circle.Induction.html#13491" class="Bound">-</a> <a id="13497" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13499" href="SyntheticHomotopyTheory.Circle.Induction.html#13491" class="Bound">-</a><a id="13500" class="Symbol">)</a> <a id="13502" href="SyntheticHomotopyTheory.Circle.Induction.html#13474" class="Bound">-</a> <a id="13504" class="Symbol">(</a><a id="13505" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13512" class="Symbol">(</a><a id="13513" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="13518" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13520" href="SyntheticHomotopyTheory.Circle.Induction.html#12566" class="Function">τ</a><a id="13521" class="Symbol">)))</a> <a id="13525" href="SyntheticHomotopyTheory.Circle.Induction.html#13552" class="Function">h</a>
         <a id="13536" class="Keyword">where</a>
          <a id="13552" href="SyntheticHomotopyTheory.Circle.Induction.html#13552" class="Function">h</a> <a id="13554" class="Symbol">=</a> <a id="13556" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13563" class="Symbol">(</a><a id="13564" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="13569" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13571" href="SyntheticHomotopyTheory.Circle.Induction.html#12535" class="Function">σ</a><a id="13572" class="Symbol">)</a>                 <a id="13590" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="13593" href="SyntheticHomotopyTheory.Circle.Induction.html#13735" class="Function">I&#39;</a>  <a id="13597" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
              <a id="13613" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13620" class="Symbol">(</a><a id="13621" href="UF.Base.html#14997" class="Function">from-Σ-＝</a> <a id="13630" class="Symbol">(</a><a id="13631" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13634" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13638" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="13644" class="Symbol">))</a> <a id="13647" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="13650" href="SyntheticHomotopyTheory.Circle.Induction.html#13799" class="Function">II&#39;</a> <a id="13654" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
              <a id="13670" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13673" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13677" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a>                     <a id="13704" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
           <a id="13717" class="Keyword">where</a>
            <a id="13735" href="SyntheticHomotopyTheory.Circle.Induction.html#13735" class="Function">I&#39;</a>  <a id="13739" class="Symbol">=</a> <a id="13741" class="Symbol">(</a><a id="13742" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13745" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13752" class="Symbol">(</a><a id="13753" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="13760" class="Symbol">(</a><a id="13761" href="SyntheticHomotopyTheory.Circle.Induction.html#7378" class="Function">ρ-comp-lemma</a> <a id="13774" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="13776" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="13780" class="Symbol">)))</a> <a id="13784" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
            <a id="13799" href="SyntheticHomotopyTheory.Circle.Induction.html#13799" class="Function">II&#39;</a> <a id="13803" class="Symbol">=</a> <a id="13805" href="UF.Base.html#15897" class="Function">tofrom-Σ-＝</a> <a id="13816" class="Symbol">(</a><a id="13817" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13820" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13824" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="13830" class="Symbol">)</a>
        <a id="13840" href="SyntheticHomotopyTheory.Circle.Induction.html#13840" class="Function">III</a> <a id="13844" class="Symbol">=</a> <a id="13846" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13849" class="Symbol">(</a><a id="13850" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13860" class="Symbol">(λ</a> <a id="13863" href="SyntheticHomotopyTheory.Circle.Induction.html#13863" class="Bound">-</a> <a id="13865" class="Symbol">→</a> <a id="13867" href="SyntheticHomotopyTheory.Circle.Induction.html#13863" class="Bound">-</a> <a id="13869" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13871" href="SyntheticHomotopyTheory.Circle.Induction.html#13863" class="Bound">-</a><a id="13872" class="Symbol">)</a> <a id="13874" class="Symbol">(</a><a id="13875" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13878" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13882" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a><a id="13888" class="Symbol">))</a> <a id="13891" class="Symbol">(</a><a id="13892" href="SyntheticHomotopyTheory.Circle.Induction.html#13938" class="Function">h</a> <a id="13894" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="13907" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="13911" class="Symbol">)</a>
         <a id="13922" class="Keyword">where</a>
          <a id="13938" href="SyntheticHomotopyTheory.Circle.Induction.html#13938" class="Function">h</a> <a id="13940" class="Symbol">:</a> <a id="13942" class="Symbol">{</a><a id="13943" href="SyntheticHomotopyTheory.Circle.Induction.html#13943" class="Bound">X</a> <a id="13945" class="Symbol">:</a> <a id="13947" href="MLTT.Universes.html#3838" class="Generalizable">𝓦</a> <a id="13949" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="13951" class="Symbol">}</a> <a id="13953" class="Symbol">{</a><a id="13954" href="SyntheticHomotopyTheory.Circle.Induction.html#13954" class="Bound">Y</a> <a id="13956" class="Symbol">:</a> <a id="13958" href="SyntheticHomotopyTheory.Circle.Induction.html#13943" class="Bound">X</a> <a id="13960" class="Symbol">→</a> <a id="13962" href="MLTT.Universes.html#3840" class="Generalizable">𝓣</a> <a id="13964" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="13966" class="Symbol">}</a> <a id="13968" class="Symbol">(</a><a id="13969" href="SyntheticHomotopyTheory.Circle.Induction.html#13969" class="Bound">f</a> <a id="13971" class="Symbol">:</a> <a id="13973" class="Symbol">(</a><a id="13974" href="SyntheticHomotopyTheory.Circle.Induction.html#13974" class="Bound">x</a> <a id="13976" class="Symbol">:</a> <a id="13978" href="SyntheticHomotopyTheory.Circle.Induction.html#13943" class="Bound">X</a><a id="13979" class="Symbol">)</a> <a id="13981" class="Symbol">→</a> <a id="13983" href="SyntheticHomotopyTheory.Circle.Induction.html#13954" class="Bound">Y</a> <a id="13985" href="SyntheticHomotopyTheory.Circle.Induction.html#13974" class="Bound">x</a><a id="13986" class="Symbol">)</a>
              <a id="14002" class="Symbol">{</a><a id="14003" href="SyntheticHomotopyTheory.Circle.Induction.html#14003" class="Bound">x</a> <a id="14005" href="SyntheticHomotopyTheory.Circle.Induction.html#14005" class="Bound">x&#39;</a> <a id="14008" class="Symbol">:</a> <a id="14010" href="SyntheticHomotopyTheory.Circle.Induction.html#13943" class="Bound">X</a><a id="14011" class="Symbol">}</a> <a id="14013" class="Symbol">(</a><a id="14014" href="SyntheticHomotopyTheory.Circle.Induction.html#14014" class="Bound">p</a> <a id="14016" class="Symbol">:</a> <a id="14018" href="SyntheticHomotopyTheory.Circle.Induction.html#14003" class="Bound">x</a> <a id="14020" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14022" href="SyntheticHomotopyTheory.Circle.Induction.html#14005" class="Bound">x&#39;</a><a id="14024" class="Symbol">)</a>
            <a id="14038" class="Symbol">→</a> <a id="14040" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="14047" class="Symbol">(</a><a id="14048" href="SyntheticHomotopyTheory.Circle.Induction.html#14014" class="Bound">p</a> <a id="14050" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="14052" href="UF.Base.html#7318" class="Function">apd</a> <a id="14056" href="SyntheticHomotopyTheory.Circle.Induction.html#13969" class="Bound">f</a> <a id="14058" href="SyntheticHomotopyTheory.Circle.Induction.html#14014" class="Bound">p</a><a id="14059" class="Symbol">)</a> <a id="14061" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14063" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="14066" class="Symbol">(λ</a> <a id="14069" href="SyntheticHomotopyTheory.Circle.Induction.html#14069" class="Bound">x</a> <a id="14071" class="Symbol">→</a> <a id="14073" class="Symbol">(</a><a id="14074" href="SyntheticHomotopyTheory.Circle.Induction.html#14069" class="Bound">x</a> <a id="14076" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="14078" href="SyntheticHomotopyTheory.Circle.Induction.html#13969" class="Bound">f</a> <a id="14080" href="SyntheticHomotopyTheory.Circle.Induction.html#14069" class="Bound">x</a><a id="14081" class="Symbol">))</a> <a id="14084" href="SyntheticHomotopyTheory.Circle.Induction.html#14014" class="Bound">p</a>
          <a id="14096" href="SyntheticHomotopyTheory.Circle.Induction.html#13938" class="Function">h</a> <a id="14098" href="SyntheticHomotopyTheory.Circle.Induction.html#14098" class="Bound">f</a> <a id="14100" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="14105" class="Symbol">=</a> <a id="14107" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
        <a id="14120" href="SyntheticHomotopyTheory.Circle.Induction.html#14120" class="Function">IV</a>  <a id="14124" class="Symbol">=</a> <a id="14126" href="UF.Base.html#14834" class="Function">from-Σ-＝&#39;</a> <a id="14136" href="SyntheticHomotopyTheory.Circle.Induction.html#6991" class="Function">ρ-comp</a>

   <a id="14147" class="Keyword">module</a> <a id="14154" href="SyntheticHomotopyTheory.Circle.Induction.html#14154" class="Module">_</a>
           <a id="14167" class="Symbol">(</a><a id="14168" href="SyntheticHomotopyTheory.Circle.Induction.html#14168" class="Bound">base-sethood</a> <a id="14181" class="Symbol">:</a> <a id="14183" href="UF.Sets.html#709" class="Function">is-set</a> <a id="14190" class="Symbol">(</a><a id="14191" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="14196" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14198" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="14202" class="Symbol">))</a>
          <a id="14215" class="Keyword">where</a>

    <a id="14226" href="SyntheticHomotopyTheory.Circle.Induction.html#14226" class="Function">𝕊¹-induction-on-loop</a> <a id="14247" class="Symbol">:</a> <a id="14249" href="MLTT.Id.html#735" class="Function">transport</a> <a id="14259" class="Symbol">(λ</a> <a id="14262" href="SyntheticHomotopyTheory.Circle.Induction.html#14262" class="Bound">-</a> <a id="14264" class="Symbol">→</a> <a id="14266" href="MLTT.Id.html#735" class="Function">transport</a> <a id="14276" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="14278" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="14283" href="SyntheticHomotopyTheory.Circle.Induction.html#14262" class="Bound">-</a> <a id="14285" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14287" href="SyntheticHomotopyTheory.Circle.Induction.html#14262" class="Bound">-</a><a id="14288" class="Symbol">)</a>
                            <a id="14318" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="14339" class="Symbol">(</a><a id="14340" href="UF.Base.html#7318" class="Function">apd</a> <a id="14344" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="14357" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="14361" class="Symbol">)</a>
                         <a id="14388" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14390" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a>
    <a id="14396" href="SyntheticHomotopyTheory.Circle.Induction.html#14226" class="Function">𝕊¹-induction-on-loop</a> <a id="14417" class="Symbol">=</a>
     <a id="14424" href="UF.Base.html#16487" class="Function">ap-pr₁-refl-lemma</a> <a id="14442" class="Symbol">(λ</a> <a id="14445" href="SyntheticHomotopyTheory.Circle.Induction.html#14445" class="Bound">-</a> <a id="14447" class="Symbol">→</a> <a id="14449" href="MLTT.Id.html#735" class="Function">transport</a> <a id="14459" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="14461" href="SyntheticHomotopyTheory.Circle.Induction.html#14445" class="Bound">-</a> <a id="14463" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a> <a id="14465" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14467" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a><a id="14468" class="Symbol">)</a> <a id="14470" href="SyntheticHomotopyTheory.Circle.Induction.html#12113" class="Function">𝕊¹-induction-on-loop-lemma</a> <a id="14497" href="SyntheticHomotopyTheory.Circle.Induction.html#14516" class="Function">γ</a>
     <a id="14504" class="Keyword">where</a>
      <a id="14516" href="SyntheticHomotopyTheory.Circle.Induction.html#14516" class="Function">γ</a> <a id="14518" class="Symbol">:</a> <a id="14520" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="14523" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="14527" href="SyntheticHomotopyTheory.Circle.Induction.html#12113" class="Function">𝕊¹-induction-on-loop-lemma</a> <a id="14554" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14556" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
      <a id="14567" href="SyntheticHomotopyTheory.Circle.Induction.html#14516" class="Function">γ</a> <a id="14569" class="Symbol">=</a> <a id="14571" href="SyntheticHomotopyTheory.Circle.Induction.html#14168" class="Bound">base-sethood</a> <a id="14584" class="Symbol">(</a><a id="14585" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="14588" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="14592" href="SyntheticHomotopyTheory.Circle.Induction.html#12113" class="Function">𝕊¹-induction-on-loop-lemma</a><a id="14618" class="Symbol">)</a> <a id="14620" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

    <a id="14630" href="SyntheticHomotopyTheory.Circle.Induction.html#14630" class="Function">𝕊¹-induction-comp</a> <a id="14648" class="Symbol">:</a> <a id="14650" class="Symbol">(</a><a id="14651" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="14664" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="14669" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="14671" href="UF.Base.html#7318" class="Function">apd</a> <a id="14675" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="14688" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="14692" class="Symbol">)</a>
                      <a id="14716" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="14719" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="14721" href="SyntheticHomotopyTheory.Circle.Induction.html#14721" class="Bound">y</a> <a id="14723" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="14725" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="14727" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="14732" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="14734" href="MLTT.Id.html#735" class="Function">transport</a> <a id="14744" href="SyntheticHomotopyTheory.Circle.Induction.html#4386" class="Bound">A</a> <a id="14746" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="14751" href="SyntheticHomotopyTheory.Circle.Induction.html#14721" class="Bound">y</a> <a id="14753" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14755" href="SyntheticHomotopyTheory.Circle.Induction.html#14721" class="Bound">y</a> <a id="14757" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="14759" class="Symbol">(</a><a id="14760" href="SyntheticHomotopyTheory.Circle.Induction.html#4412" class="Bound">a</a> <a id="14762" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="14764" href="SyntheticHomotopyTheory.Circle.Induction.html#4435" class="Bound">l</a><a id="14765" class="Symbol">)</a>
    <a id="14771" href="SyntheticHomotopyTheory.Circle.Induction.html#14630" class="Function">𝕊¹-induction-comp</a> <a id="14789" class="Symbol">=</a> <a id="14791" href="UF.Base.html#15163" class="Function">to-Σ-＝</a> <a id="14798" class="Symbol">(</a><a id="14799" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="14820" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="14822" href="SyntheticHomotopyTheory.Circle.Induction.html#14226" class="Function">𝕊¹-induction-on-loop</a><a id="14842" class="Symbol">)</a>

<a id="14845" class="Markup">\end{code}</a><a id="14855" class="Background">

As promised above, here follows a proof, assuming function
extensionality and univalence, that base ＝ base is a set, using both
computation rules for 𝕊¹-rec and the first computation rule for
𝕊¹-induction.

The proof uses the encode-decode method (Section 8.1.4 of the HoTT
Book) to show that base ＝ base is a retract of ℤ. Since sets are
closed under retracts, the claim follows.

</a><a id="15239" class="Markup">\begin{code}</a>

  <a id="15255" class="Keyword">open</a> <a id="15260" class="Keyword">import</a> <a id="15267" href="SyntheticHomotopyTheory.Circle.Integers.html" class="Module">SyntheticHomotopyTheory.Circle.Integers</a>
  <a id="15309" class="Keyword">open</a> <a id="15314" class="Keyword">import</a> <a id="15321" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html" class="Module">SyntheticHomotopyTheory.Circle.Integers-Properties</a>

  <a id="15375" class="Keyword">open</a> <a id="15380" class="Keyword">import</a> <a id="15387" href="UF.Univalence.html" class="Module">UF.Univalence</a>

  <a id="15404" class="Keyword">module</a> <a id="15411" href="SyntheticHomotopyTheory.Circle.Induction.html#15411" class="Module">_</a>
          <a id="15423" class="Symbol">(</a><a id="15424" href="SyntheticHomotopyTheory.Circle.Induction.html#15424" class="Bound">ua</a> <a id="15427" class="Symbol">:</a> <a id="15429" href="UF.Univalence.html#412" class="Function">is-univalent</a> <a id="15442" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a><a id="15444" class="Symbol">)</a>
         <a id="15455" class="Keyword">where</a>

   <a id="15465" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a> <a id="15474" class="Symbol">:</a> <a id="15476" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15478" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15480" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a>
   <a id="15485" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a> <a id="15494" class="Symbol">=</a> <a id="15496" href="UF.Univalence.html#905" class="Function">eqtoid</a> <a id="15503" href="SyntheticHomotopyTheory.Circle.Induction.html#15424" class="Bound">ua</a> <a id="15506" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15508" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15510" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#1381" class="Function">succ-ℤ-≃</a>

   <a id="15523" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15528" class="Symbol">:</a> <a id="15530" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="15533" class="Symbol">→</a> <a id="15535" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="15538" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
   <a id="15543" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15548" class="Symbol">=</a> <a id="15550" href="SyntheticHomotopyTheory.Circle.Induction.html#3345" class="Function">𝕊¹-rec</a> <a id="15557" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15559" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a>

<a id="15569" class="Markup">\end{code}</a><a id="15579" class="Background">

   Using the first computation rule for 𝕊¹-rec:

</a><a id="15630" class="Markup">\begin{code}</a>

   <a id="15647" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="15660" class="Symbol">:</a> <a id="15662" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15667" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="15672" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15674" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a>
   <a id="15679" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="15692" class="Symbol">=</a> <a id="15694" href="SyntheticHomotopyTheory.Circle.Induction.html#3660" class="Function">𝕊¹-rec-on-base</a> <a id="15709" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15711" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a>

   <a id="15724" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="15739" class="Symbol">:</a> <a id="15741" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="15743" class="Symbol">→</a> <a id="15745" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15750" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>
   <a id="15758" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="15773" class="Symbol">=</a> <a id="15775" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="15783" class="Symbol">(</a><a id="15784" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="15797" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="15799" class="Symbol">)</a>

   <a id="15805" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a> <a id="15820" class="Symbol">:</a> <a id="15822" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15827" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="15832" class="Symbol">→</a> <a id="15834" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a>
   <a id="15839" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a> <a id="15854" class="Symbol">=</a> <a id="15856" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="15864" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a>

   <a id="15881" href="SyntheticHomotopyTheory.Circle.Induction.html#15881" class="Function">transport-code-loop-is-succ-ℤ</a> <a id="15911" class="Symbol">:</a> <a id="15913" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
                                 <a id="15961" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="15963" href="MLTT.Id.html#735" class="Function">transport</a> <a id="15973" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="15978" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
                                 <a id="16016" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16018" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
                                 <a id="16066" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16068" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a>
   <a id="16078" href="SyntheticHomotopyTheory.Circle.Induction.html#15881" class="Function">transport-code-loop-is-succ-ℤ</a> <a id="16108" class="Symbol">=</a>
    <a id="16114" href="SyntheticHomotopyTheory.Circle.Induction.html#16607" class="Function">δ</a> <a id="16116" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16118" href="MLTT.Id.html#735" class="Function">transport</a> <a id="16128" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="16133" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="16138" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16140" href="SyntheticHomotopyTheory.Circle.Induction.html#16582" class="Function">ε</a>                  <a id="16159" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16162" href="SyntheticHomotopyTheory.Circle.Induction.html#16632" class="Function">I</a>    <a id="16167" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16173" href="SyntheticHomotopyTheory.Circle.Induction.html#16607" class="Function">δ</a> <a id="16175" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16177" href="MLTT.Id.html#735" class="Function">transport</a> <a id="16187" href="MLTT.Pi.html#444" class="Function">id</a> <a id="16190" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a> <a id="16194" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16196" href="SyntheticHomotopyTheory.Circle.Induction.html#16582" class="Function">ε</a>                     <a id="16218" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16221" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="16226" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16232" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16240" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16244" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16246" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16254" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a> <a id="16258" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16260" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16268" class="Symbol">(</a><a id="16269" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16273" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="16275" class="Symbol">)</a> <a id="16277" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16280" href="SyntheticHomotopyTheory.Circle.Induction.html#16694" class="Function">II</a>   <a id="16285" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16291" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16299" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16303" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16305" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16313" class="Symbol">(</a><a id="16314" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16318" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="16321" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="16323" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a><a id="16326" class="Symbol">)</a>         <a id="16336" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16339" href="SyntheticHomotopyTheory.Circle.Induction.html#16762" class="Function">III</a>  <a id="16344" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16350" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16358" class="Symbol">(</a><a id="16359" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16363" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="16366" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="16368" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a> <a id="16372" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="16374" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a><a id="16377" class="Symbol">)</a>                 <a id="16395" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16398" href="SyntheticHomotopyTheory.Circle.Induction.html#16890" class="Function">IV</a>   <a id="16403" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16409" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16417" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a>                             <a id="16454" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="16457" href="SyntheticHomotopyTheory.Circle.Induction.html#16999" class="Function">V</a>    <a id="16462" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="16468" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a>                                       <a id="16513" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
     <a id="16520" class="Keyword">where</a>
      <a id="16532" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16536" class="Symbol">=</a> <a id="16538" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a>
      <a id="16557" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a> <a id="16561" class="Symbol">=</a> <a id="16563" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="16566" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="16571" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
      <a id="16582" href="SyntheticHomotopyTheory.Circle.Induction.html#16582" class="Function">ε</a> <a id="16584" class="Symbol">=</a> <a id="16586" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
      <a id="16607" href="SyntheticHomotopyTheory.Circle.Induction.html#16607" class="Function">δ</a> <a id="16609" class="Symbol">=</a> <a id="16611" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
      <a id="16632" href="SyntheticHomotopyTheory.Circle.Induction.html#16632" class="Function">I</a>   <a id="16636" class="Symbol">=</a> <a id="16638" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="16641" class="Symbol">(λ</a> <a id="16644" href="SyntheticHomotopyTheory.Circle.Induction.html#16644" class="Bound">-</a> <a id="16646" class="Symbol">→</a> <a id="16648" href="SyntheticHomotopyTheory.Circle.Induction.html#16607" class="Function">δ</a> <a id="16650" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16652" href="SyntheticHomotopyTheory.Circle.Induction.html#16644" class="Bound">-</a> <a id="16654" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="16656" href="SyntheticHomotopyTheory.Circle.Induction.html#16582" class="Function">ε</a><a id="16657" class="Symbol">)</a> <a id="16659" class="Symbol">(</a><a id="16660" href="UF.Base.html#5320" class="Function">transport-ap&#39;</a> <a id="16674" href="MLTT.Pi.html#444" class="Function">id</a> <a id="16677" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="16682" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="16686" class="Symbol">)</a>
      <a id="16694" href="SyntheticHomotopyTheory.Circle.Induction.html#16694" class="Function">II</a>  <a id="16698" class="Symbol">=</a> <a id="16700" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="16703" class="Symbol">(</a><a id="16704" href="MLTT.Pi.html#513" class="Function Operator">_∘_</a> <a id="16708" class="Symbol">(</a><a id="16709" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16717" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a><a id="16720" class="Symbol">))</a> <a id="16723" class="Symbol">((</a><a id="16725" href="UF.Univalence.html#1852" class="Function">Idtofun-∙</a> <a id="16735" href="SyntheticHomotopyTheory.Circle.Induction.html#15424" class="Bound">ua</a> <a id="16738" class="Symbol">(</a><a id="16739" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16743" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="16745" class="Symbol">)</a> <a id="16747" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a><a id="16750" class="Symbol">)</a> <a id="16752" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="16754" class="Symbol">)</a>
      <a id="16762" href="SyntheticHomotopyTheory.Circle.Induction.html#16762" class="Function">III</a> <a id="16766" class="Symbol">=</a> <a id="16768" class="Symbol">(</a><a id="16769" href="UF.Univalence.html#1852" class="Function">Idtofun-∙</a> <a id="16779" href="SyntheticHomotopyTheory.Circle.Induction.html#15424" class="Bound">ua</a> <a id="16782" class="Symbol">(</a><a id="16783" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16787" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="16790" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="16792" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a><a id="16795" class="Symbol">)</a> <a id="16797" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a><a id="16800" class="Symbol">)</a> <a id="16802" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>

<a id="16806" class="Markup">\end{code}</a><a id="16816" class="Background">

      Using the second computation rule for 𝕊¹-rec

</a><a id="16870" class="Markup">\begin{code}</a>

      <a id="16890" href="SyntheticHomotopyTheory.Circle.Induction.html#16890" class="Function">IV</a>  <a id="16894" class="Symbol">=</a> <a id="16896" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="16899" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="16907" class="Symbol">((</a><a id="16909" href="UF.Base.html#16880" class="Function">transport-along-＝</a> <a id="16927" href="SyntheticHomotopyTheory.Circle.Induction.html#16532" class="Function">cob</a> <a id="16931" href="SyntheticHomotopyTheory.Circle.Induction.html#16557" class="Function">acl</a><a id="16934" class="Symbol">)</a> <a id="16936" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
                       <a id="16962" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="16964" class="Symbol">(</a><a id="16965" href="SyntheticHomotopyTheory.Circle.Induction.html#3799" class="Function">𝕊¹-rec-on-loop</a> <a id="16980" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="16982" href="SyntheticHomotopyTheory.Circle.Induction.html#15465" class="Function">succ-ℤ-＝</a><a id="16990" class="Symbol">))</a>
      <a id="16999" href="SyntheticHomotopyTheory.Circle.Induction.html#16999" class="Function">V</a>   <a id="17003" class="Symbol">=</a> <a id="17005" href="UF.Univalence.html#1668" class="Function">Idtofun-eqtoid</a> <a id="17020" href="SyntheticHomotopyTheory.Circle.Induction.html#15424" class="Bound">ua</a> <a id="17023" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#1381" class="Function">succ-ℤ-≃</a>

   <a id="17036" href="SyntheticHomotopyTheory.Circle.Induction.html#17036" class="Function">transport-code-loop⁻¹-is-pred-ℤ</a> <a id="17068" class="Symbol">:</a> <a id="17070" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
                                   <a id="17120" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17122" href="MLTT.Id.html#735" class="Function">transport</a> <a id="17132" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="17137" class="Symbol">(</a><a id="17138" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="17143" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="17145" class="Symbol">)</a>
                                   <a id="17182" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17184" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
                                   <a id="17234" href="MLTT.Id.html#1889" class="Function Operator">∼</a> <a id="17236" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a>
   <a id="17246" href="SyntheticHomotopyTheory.Circle.Induction.html#17036" class="Function">transport-code-loop⁻¹-is-pred-ℤ</a> <a id="17278" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a> <a id="17280" class="Symbol">=</a> <a id="17282" href="UF.Equiv.html#1141" class="Function">equivs-are-lc</a> <a id="17296" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a> <a id="17303" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#1233" class="Function">succ-ℤ-is-equiv</a> <a id="17319" href="SyntheticHomotopyTheory.Circle.Induction.html#17336" class="Function">γ</a>
    <a id="17325" class="Keyword">where</a>
     <a id="17336" href="SyntheticHomotopyTheory.Circle.Induction.html#17336" class="Function">γ</a> <a id="17338" class="Symbol">:</a> <a id="17340" class="Symbol">(</a><a id="17341" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a> <a id="17348" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17350" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a> <a id="17365" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17367" href="MLTT.Id.html#735" class="Function">transport</a> <a id="17377" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="17382" class="Symbol">(</a><a id="17383" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="17388" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="17390" class="Symbol">)</a> <a id="17392" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17394" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a><a id="17408" class="Symbol">)</a> <a id="17410" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>
       <a id="17419" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="17421" class="Symbol">(</a><a id="17422" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a> <a id="17429" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17431" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a><a id="17437" class="Symbol">)</a> <a id="17439" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>
     <a id="17446" href="SyntheticHomotopyTheory.Circle.Induction.html#17336" class="Function">γ</a> <a id="17448" class="Symbol">=</a> <a id="17450" class="Symbol">(</a><a id="17451" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a> <a id="17458" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17460" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17462" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17464" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17468" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17470" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a><a id="17471" class="Symbol">)</a> <a id="17473" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>    <a id="17478" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="17481" href="SyntheticHomotopyTheory.Circle.Induction.html#17852" class="Function">I</a>   <a id="17485" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="17496" class="Symbol">(</a><a id="17497" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17499" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17501" href="SyntheticHomotopyTheory.Circle.Induction.html#17819" class="Function">t</a> <a id="17503" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17505" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a> <a id="17507" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17509" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17511" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17513" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17517" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17519" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a><a id="17520" class="Symbol">)</a> <a id="17522" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a> <a id="17524" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="17527" href="SyntheticHomotopyTheory.Circle.Induction.html#17925" class="Function">II</a>  <a id="17531" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="17542" class="Symbol">(</a><a id="17543" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17545" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17547" href="SyntheticHomotopyTheory.Circle.Induction.html#17819" class="Function">t</a> <a id="17549" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17551" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17555" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17557" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a><a id="17558" class="Symbol">)</a> <a id="17560" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>         <a id="17570" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="17573" href="SyntheticHomotopyTheory.Circle.Induction.html#17992" class="Function">III</a> <a id="17577" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="17588" class="Symbol">(</a><a id="17589" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17591" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17593" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a><a id="17594" class="Symbol">)</a> <a id="17596" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>                   <a id="17616" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="17619" href="SyntheticHomotopyTheory.Circle.Induction.html#18042" class="Function">IV</a>  <a id="17623" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="17634" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>                           <a id="17662" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="17665" href="SyntheticHomotopyTheory.Circle.Induction.html#18089" class="Function">V</a>   <a id="17669" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
         <a id="17680" class="Symbol">(</a><a id="17681" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#536" class="Function">succ-ℤ</a> <a id="17688" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17690" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a><a id="17696" class="Symbol">)</a> <a id="17698" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>         <a id="17708" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="17716" class="Keyword">where</a>
       <a id="17729" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a> <a id="17731" class="Symbol">=</a> <a id="17733" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
       <a id="17755" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17757" class="Symbol">=</a> <a id="17759" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
       <a id="17781" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17785" class="Symbol">=</a> <a id="17787" href="MLTT.Id.html#735" class="Function">transport</a> <a id="17797" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="17802" class="Symbol">(</a><a id="17803" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="17808" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="17810" class="Symbol">)</a>
       <a id="17819" href="SyntheticHomotopyTheory.Circle.Induction.html#17819" class="Function">t</a>   <a id="17823" class="Symbol">=</a> <a id="17825" href="MLTT.Id.html#735" class="Function">transport</a> <a id="17835" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="17840" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
       <a id="17852" href="SyntheticHomotopyTheory.Circle.Induction.html#17852" class="Function">I</a>   <a id="17856" class="Symbol">=</a> <a id="17858" href="UF.Base.html#11014" class="Function">happly</a> <a id="17865" class="Symbol">(</a><a id="17866" href="SyntheticHomotopyTheory.Circle.Induction.html#15881" class="Function">transport-code-loop-is-succ-ℤ</a> <a id="17896" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="17898" class="Symbol">)</a> <a id="17900" class="Symbol">((</a><a id="17902" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17904" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17906" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17910" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17912" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a><a id="17913" class="Symbol">)</a> <a id="17915" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a><a id="17916" class="Symbol">)</a>
       <a id="17925" href="SyntheticHomotopyTheory.Circle.Induction.html#17925" class="Function">II</a>  <a id="17929" class="Symbol">=</a> <a id="17931" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="17934" class="Symbol">(</a><a id="17935" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="17937" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17939" href="SyntheticHomotopyTheory.Circle.Induction.html#17819" class="Function">t</a><a id="17940" class="Symbol">)</a> <a id="17942" class="Symbol">(</a><a id="17943" href="UF.Base.html#2480" class="Function">Idtofun-section</a> <a id="17959" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="17972" class="Symbol">(</a><a id="17973" href="SyntheticHomotopyTheory.Circle.Induction.html#17781" class="Function">t⁻¹</a> <a id="17977" class="Symbol">(</a><a id="17978" href="SyntheticHomotopyTheory.Circle.Induction.html#17729" class="Function">ε</a> <a id="17980" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a><a id="17981" class="Symbol">)))</a>
       <a id="17992" href="SyntheticHomotopyTheory.Circle.Induction.html#17992" class="Function">III</a> <a id="17996" class="Symbol">=</a> <a id="17998" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="18001" href="SyntheticHomotopyTheory.Circle.Induction.html#17755" class="Function">δ</a> <a id="18003" class="Symbol">(</a><a id="18004" href="UF.Base.html#2872" class="Function">back-and-forth-transport</a> <a id="18029" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="18033" class="Symbol">)</a>
       <a id="18042" href="SyntheticHomotopyTheory.Circle.Induction.html#18042" class="Function">IV</a>  <a id="18046" class="Symbol">=</a> <a id="18048" href="UF.Base.html#2366" class="Function">Idtofun-retraction</a> <a id="18067" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="18080" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a>
       <a id="18089" href="SyntheticHomotopyTheory.Circle.Induction.html#18089" class="Function">V</a>   <a id="18093" class="Symbol">=</a> <a id="18095" class="Symbol">(</a><a id="18096" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#814" class="Function">succ-ℤ-is-retraction</a> <a id="18117" href="SyntheticHomotopyTheory.Circle.Induction.html#17278" class="Bound">x</a><a id="18118" class="Symbol">)</a> <a id="18120" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>

   <a id="18127" href="SyntheticHomotopyTheory.Circle.Induction.html#18127" class="Function">transport-code-loop⁻¹-is-pred-ℤ&#39;</a> <a id="18160" class="Symbol">:</a> <a id="18162" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18172" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18177" class="Symbol">(</a><a id="18178" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18183" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18185" class="Symbol">)</a>
                                    <a id="18223" href="MLTT.Id.html#1889" class="Function Operator">∼</a> <a id="18225" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="18240" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18242" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="18249" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18251" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
   <a id="18269" href="SyntheticHomotopyTheory.Circle.Induction.html#18127" class="Function">transport-code-loop⁻¹-is-pred-ℤ&#39;</a> <a id="18302" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a> <a id="18304" class="Symbol">=</a>
    <a id="18310" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18320" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18325" class="Symbol">(</a><a id="18326" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18331" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18333" class="Symbol">)</a> <a id="18335" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a>                   <a id="18355" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="18358" href="SyntheticHomotopyTheory.Circle.Induction.html#18598" class="Function">I</a>   <a id="18362" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="18368" class="Symbol">(</a><a id="18369" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18371" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18373" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a> <a id="18375" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18377" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18387" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18392" class="Symbol">(</a><a id="18393" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18398" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18400" class="Symbol">))</a> <a id="18403" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a>         <a id="18413" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="18416" href="SyntheticHomotopyTheory.Circle.Induction.html#18673" class="Function">II</a>  <a id="18420" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="18426" class="Symbol">(</a><a id="18427" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18429" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18431" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a> <a id="18433" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18435" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18445" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18450" class="Symbol">(</a><a id="18451" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18456" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18458" class="Symbol">)</a> <a id="18460" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18462" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18464" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18466" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a><a id="18467" class="Symbol">)</a> <a id="18469" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a> <a id="18471" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="18474" href="SyntheticHomotopyTheory.Circle.Induction.html#18774" class="Function">III</a> <a id="18478" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
    <a id="18484" class="Symbol">(</a><a id="18485" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18487" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18489" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="18496" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18498" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a><a id="18499" class="Symbol">)</a> <a id="18501" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a>                           <a id="18529" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
     <a id="18536" class="Keyword">where</a>
      <a id="18548" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18550" class="Symbol">=</a> <a id="18552" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
      <a id="18573" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a> <a id="18575" class="Symbol">=</a> <a id="18577" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
      <a id="18598" href="SyntheticHomotopyTheory.Circle.Induction.html#18598" class="Function">I</a>   <a id="18602" class="Symbol">=</a> <a id="18604" class="Symbol">(</a><a id="18605" href="UF.Base.html#2480" class="Function">Idtofun-section</a> <a id="18621" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="18634" class="Symbol">(</a><a id="18635" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18645" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18650" class="Symbol">(</a><a id="18651" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18656" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18658" class="Symbol">)</a> <a id="18660" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a><a id="18661" class="Symbol">))</a> <a id="18664" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
      <a id="18673" href="SyntheticHomotopyTheory.Circle.Induction.html#18673" class="Function">II</a>  <a id="18677" class="Symbol">=</a> <a id="18679" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="18682" class="Symbol">(</a><a id="18683" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18685" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18687" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a> <a id="18689" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="18691" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18701" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18706" class="Symbol">(</a><a id="18707" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="18712" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18714" class="Symbol">))</a>
             <a id="18730" class="Symbol">((</a><a id="18732" href="UF.Base.html#2480" class="Function">Idtofun-section</a> <a id="18748" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="18761" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a><a id="18762" class="Symbol">)</a> <a id="18764" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="18766" class="Symbol">)</a>
      <a id="18774" href="SyntheticHomotopyTheory.Circle.Induction.html#18774" class="Function">III</a> <a id="18778" class="Symbol">=</a> <a id="18780" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="18783" href="SyntheticHomotopyTheory.Circle.Induction.html#18548" class="Function">ε</a> <a id="18785" class="Symbol">(</a><a id="18786" href="SyntheticHomotopyTheory.Circle.Induction.html#17036" class="Function">transport-code-loop⁻¹-is-pred-ℤ</a> <a id="18818" class="Symbol">(</a><a id="18819" href="SyntheticHomotopyTheory.Circle.Induction.html#18573" class="Function">δ</a> <a id="18821" href="SyntheticHomotopyTheory.Circle.Induction.html#18302" class="Bound">x</a><a id="18822" class="Symbol">))</a>

   <a id="18829" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="18836" class="Symbol">:</a> <a id="18838" class="Symbol">(</a><a id="18839" href="SyntheticHomotopyTheory.Circle.Induction.html#18839" class="Bound">x</a> <a id="18841" class="Symbol">:</a> <a id="18843" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="18845" class="Symbol">)</a> <a id="18847" class="Symbol">→</a> <a id="18849" class="Symbol">(</a><a id="18850" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="18855" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18857" href="SyntheticHomotopyTheory.Circle.Induction.html#18839" class="Bound">x</a><a id="18858" class="Symbol">)</a> <a id="18860" class="Symbol">→</a> <a id="18862" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18867" href="SyntheticHomotopyTheory.Circle.Induction.html#18839" class="Bound">x</a>
   <a id="18872" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="18879" href="SyntheticHomotopyTheory.Circle.Induction.html#18879" class="Bound">x</a> <a id="18881" href="SyntheticHomotopyTheory.Circle.Induction.html#18881" class="Bound">p</a> <a id="18883" class="Symbol">=</a> <a id="18885" href="MLTT.Id.html#735" class="Function">transport</a> <a id="18895" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="18900" href="SyntheticHomotopyTheory.Circle.Induction.html#18881" class="Bound">p</a> <a id="18902" class="Symbol">(</a><a id="18903" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="18918" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="18919" class="Symbol">)</a>

   <a id="18925" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="18939" class="Symbol">:</a> <a id="18941" class="Symbol">{</a><a id="18942" href="SyntheticHomotopyTheory.Circle.Induction.html#18942" class="Bound">X</a> <a id="18944" class="Symbol">:</a> <a id="18946" href="MLTT.Universes.html#3838" class="Generalizable">𝓦</a> <a id="18948" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="18950" class="Symbol">}</a> <a id="18952" class="Symbol">{</a><a id="18953" href="SyntheticHomotopyTheory.Circle.Induction.html#18953" class="Bound">x</a> <a id="18955" class="Symbol">:</a> <a id="18957" href="SyntheticHomotopyTheory.Circle.Induction.html#18942" class="Bound">X</a><a id="18958" class="Symbol">}</a> <a id="18960" class="Symbol">→</a> <a id="18962" href="SyntheticHomotopyTheory.Circle.Induction.html#18953" class="Bound">x</a> <a id="18964" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18966" href="SyntheticHomotopyTheory.Circle.Induction.html#18953" class="Bound">x</a> <a id="18968" class="Symbol">→</a> <a id="18970" href="MLTT.Natural-Numbers-Type.html#96" class="Datatype">ℕ</a> <a id="18972" class="Symbol">→</a> <a id="18974" href="SyntheticHomotopyTheory.Circle.Induction.html#18953" class="Bound">x</a> <a id="18976" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18978" href="SyntheticHomotopyTheory.Circle.Induction.html#18953" class="Bound">x</a>
   <a id="18983" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="18997" href="SyntheticHomotopyTheory.Circle.Induction.html#18997" class="Bound">p</a> <a id="18999" href="MLTT.Natural-Numbers-Type.html#113" class="InductiveConstructor">zero</a>     <a id="19008" class="Symbol">=</a> <a id="19010" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
   <a id="19018" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19032" href="SyntheticHomotopyTheory.Circle.Induction.html#19032" class="Bound">p</a> <a id="19034" class="Symbol">(</a><a id="19035" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="19040" href="SyntheticHomotopyTheory.Circle.Induction.html#19040" class="Bound">n</a><a id="19041" class="Symbol">)</a> <a id="19043" class="Symbol">=</a> <a id="19045" href="SyntheticHomotopyTheory.Circle.Induction.html#19032" class="Bound">p</a> <a id="19047" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19049" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19063" href="SyntheticHomotopyTheory.Circle.Induction.html#19032" class="Bound">p</a> <a id="19065" href="SyntheticHomotopyTheory.Circle.Induction.html#19040" class="Bound">n</a>

   <a id="19071" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="19090" class="Symbol">:</a> <a id="19092" class="Symbol">{</a><a id="19093" href="SyntheticHomotopyTheory.Circle.Induction.html#19093" class="Bound">X</a> <a id="19095" class="Symbol">:</a> <a id="19097" href="MLTT.Universes.html#3838" class="Generalizable">𝓦</a> <a id="19099" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="19101" class="Symbol">}</a> <a id="19103" class="Symbol">{</a><a id="19104" href="SyntheticHomotopyTheory.Circle.Induction.html#19104" class="Bound">x</a> <a id="19106" class="Symbol">:</a> <a id="19108" href="SyntheticHomotopyTheory.Circle.Induction.html#19093" class="Bound">X</a><a id="19109" class="Symbol">}</a> <a id="19111" class="Symbol">(</a><a id="19112" href="SyntheticHomotopyTheory.Circle.Induction.html#19112" class="Bound">p</a> <a id="19114" class="Symbol">:</a> <a id="19116" href="SyntheticHomotopyTheory.Circle.Induction.html#19104" class="Bound">x</a> <a id="19118" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19120" href="SyntheticHomotopyTheory.Circle.Induction.html#19104" class="Bound">x</a><a id="19121" class="Symbol">)</a> <a id="19123" class="Symbol">(</a><a id="19124" href="SyntheticHomotopyTheory.Circle.Induction.html#19124" class="Bound">n</a> <a id="19126" class="Symbol">:</a> <a id="19128" href="MLTT.Natural-Numbers-Type.html#96" class="Datatype">ℕ</a><a id="19129" class="Symbol">)</a>
                      <a id="19153" class="Symbol">→</a> <a id="19155" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19169" href="SyntheticHomotopyTheory.Circle.Induction.html#19112" class="Bound">p</a> <a id="19171" href="SyntheticHomotopyTheory.Circle.Induction.html#19124" class="Bound">n</a> <a id="19173" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19175" href="SyntheticHomotopyTheory.Circle.Induction.html#19112" class="Bound">p</a> <a id="19177" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19179" href="SyntheticHomotopyTheory.Circle.Induction.html#19112" class="Bound">p</a> <a id="19181" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19183" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19197" href="SyntheticHomotopyTheory.Circle.Induction.html#19112" class="Bound">p</a> <a id="19199" href="SyntheticHomotopyTheory.Circle.Induction.html#19124" class="Bound">n</a>
   <a id="19204" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="19223" href="SyntheticHomotopyTheory.Circle.Induction.html#19223" class="Bound">p</a> <a id="19225" href="MLTT.Natural-Numbers-Type.html#113" class="InductiveConstructor">zero</a> <a id="19230" class="Symbol">=</a> <a id="19232" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="19237" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19239" href="SyntheticHomotopyTheory.Circle.Induction.html#19223" class="Bound">p</a> <a id="19241" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="19244" href="UF.Base.html#10546" class="Function">refl-left-neutral</a> <a id="19262" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                               <a id="19295" href="SyntheticHomotopyTheory.Circle.Induction.html#19223" class="Bound">p</a>        <a id="19304" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="19307" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>              <a id="19325" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                               <a id="19358" href="SyntheticHomotopyTheory.Circle.Induction.html#19223" class="Bound">p</a> <a id="19360" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19362" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="19367" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
   <a id="19372" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="19391" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19393" class="Symbol">(</a><a id="19394" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="19399" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a><a id="19400" class="Symbol">)</a> <a id="19402" class="Symbol">=</a> <a id="19404" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19406" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19408" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19422" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19424" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a> <a id="19426" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19428" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a>   <a id="19432" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="19435" href="SyntheticHomotopyTheory.Circle.Induction.html#19591" class="Function">I</a>  <a id="19438" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                                   <a id="19475" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19477" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19479" class="Symbol">(</a><a id="19480" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19494" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19496" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a> <a id="19498" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19500" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a><a id="19501" class="Symbol">)</a> <a id="19503" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="19506" href="SyntheticHomotopyTheory.Circle.Induction.html#19633" class="Function">II</a> <a id="19509" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
                                   <a id="19546" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19548" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19550" class="Symbol">(</a><a id="19551" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19553" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="19555" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19569" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19571" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a><a id="19572" class="Symbol">)</a> <a id="19574" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
    <a id="19580" class="Keyword">where</a>
     <a id="19591" href="SyntheticHomotopyTheory.Circle.Induction.html#19591" class="Function">I</a>  <a id="19594" class="Symbol">=</a>  <a id="19597" href="UF.Base.html#10779" class="Function">∙assoc</a> <a id="19604" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19606" class="Symbol">(</a><a id="19607" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19621" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19623" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a><a id="19624" class="Symbol">)</a> <a id="19626" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a>
     <a id="19633" href="SyntheticHomotopyTheory.Circle.Induction.html#19633" class="Function">II</a> <a id="19636" class="Symbol">=</a> <a id="19638" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="19641" class="Symbol">(</a><a id="19642" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19644" href="MLTT.Id.html#968" class="Function Operator">∙_</a><a id="19646" class="Symbol">)</a> <a id="19648" class="Symbol">(</a><a id="19649" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="19668" href="SyntheticHomotopyTheory.Circle.Induction.html#19391" class="Bound">p</a> <a id="19670" href="SyntheticHomotopyTheory.Circle.Induction.html#19399" class="Bound">n</a><a id="19671" class="Symbol">)</a>

   <a id="19677" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="19683" class="Symbol">:</a> <a id="19685" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="19687" class="Symbol">→</a> <a id="19689" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="19694" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19696" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>
   <a id="19704" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="19710" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a>       <a id="19718" class="Symbol">=</a> <a id="19720" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
   <a id="19728" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="19734" class="Symbol">(</a><a id="19735" href="SyntheticHomotopyTheory.Circle.Integers.html#607" class="InductiveConstructor">pos</a> <a id="19739" href="SyntheticHomotopyTheory.Circle.Induction.html#19739" class="Bound">n</a><a id="19740" class="Symbol">)</a> <a id="19742" class="Symbol">=</a> <a id="19744" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19758" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="19763" class="Symbol">(</a><a id="19764" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="19769" href="SyntheticHomotopyTheory.Circle.Induction.html#19739" class="Bound">n</a><a id="19770" class="Symbol">)</a>
   <a id="19775" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="19781" class="Symbol">(</a><a id="19782" href="SyntheticHomotopyTheory.Circle.Integers.html#635" class="InductiveConstructor">neg</a> <a id="19786" href="SyntheticHomotopyTheory.Circle.Induction.html#19786" class="Bound">n</a><a id="19787" class="Symbol">)</a> <a id="19789" class="Symbol">=</a> <a id="19791" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="19805" class="Symbol">(</a><a id="19806" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="19811" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="19813" class="Symbol">)</a> <a id="19815" class="Symbol">(</a><a id="19816" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="19821" href="SyntheticHomotopyTheory.Circle.Induction.html#19786" class="Bound">n</a><a id="19822" class="Symbol">)</a>

   <a id="19828" class="Keyword">module</a> <a id="19835" href="SyntheticHomotopyTheory.Circle.Induction.html#19835" class="Module">_</a>
           <a id="19848" class="Symbol">(</a><a id="19849" href="SyntheticHomotopyTheory.Circle.Induction.html#19849" class="Bound">fe</a> <a id="19852" class="Symbol">:</a> <a id="19854" href="UF.FunExt.html#850" class="Function">funext</a> <a id="19861" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="19864" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="19865" class="Symbol">)</a>
          <a id="19877" class="Keyword">where</a>

    <a id="19888" class="Keyword">open</a> <a id="19893" class="Keyword">import</a> <a id="19900" href="UF.Lower-FunExt.html" class="Module">UF.Lower-FunExt</a>

    <a id="19921" href="SyntheticHomotopyTheory.Circle.Induction.html#19921" class="Function">loops-lemma</a> <a id="19933" class="Symbol">:</a> <a id="19935" class="Symbol">(</a><a id="19936" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="19939" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="19943" class="Symbol">)</a> <a id="19945" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="19947" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="19953" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="19955" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="19962" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19964" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a>
    <a id="19974" href="SyntheticHomotopyTheory.Circle.Induction.html#19921" class="Function">loops-lemma</a> <a id="19986" class="Symbol">=</a> <a id="19988" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="19996" href="SyntheticHomotopyTheory.Circle.Induction.html#19849" class="Bound">fe</a> <a id="19999" href="SyntheticHomotopyTheory.Circle.Induction.html#20018" class="Function">h</a>
     <a id="20006" class="Keyword">where</a>
      <a id="20018" href="SyntheticHomotopyTheory.Circle.Induction.html#20018" class="Function">h</a> <a id="20020" class="Symbol">:</a> <a id="20022" class="Symbol">(</a><a id="20023" href="SyntheticHomotopyTheory.Circle.Induction.html#20023" class="Bound">k</a> <a id="20025" class="Symbol">:</a> <a id="20027" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a><a id="20028" class="Symbol">)</a> <a id="20030" class="Symbol">→</a> <a id="20032" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="20038" class="Symbol">(</a><a id="20039" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="20046" href="SyntheticHomotopyTheory.Circle.Induction.html#20023" class="Bound">k</a><a id="20047" class="Symbol">)</a> <a id="20049" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20051" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20056" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20058" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="20064" href="SyntheticHomotopyTheory.Circle.Induction.html#20023" class="Bound">k</a>
      <a id="20072" href="SyntheticHomotopyTheory.Circle.Induction.html#20018" class="Function">h</a> <a id="20074" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a> <a id="20076" class="Symbol">=</a> <a id="20078" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20083" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20086" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20088" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="20093" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20095" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20100" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="20103" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>              <a id="20121" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
            <a id="20135" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20140" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20143" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20145" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>        <a id="20157" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="20160" href="UF.Base.html#11795" class="Function">left-inverse</a> <a id="20173" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20178" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
            <a id="20192" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>                  <a id="20214" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="20222" href="SyntheticHomotopyTheory.Circle.Induction.html#20018" class="Function">h</a> <a id="20224" class="Symbol">(</a><a id="20225" href="SyntheticHomotopyTheory.Circle.Integers.html#607" class="InductiveConstructor">pos</a> <a id="20229" href="SyntheticHomotopyTheory.Circle.Induction.html#20229" class="Bound">n</a><a id="20230" class="Symbol">)</a> <a id="20232" class="Symbol">=</a> <a id="20234" href="SyntheticHomotopyTheory.Circle.Induction.html#20259" class="Function">g</a> <a id="20236" href="SyntheticHomotopyTheory.Circle.Induction.html#20229" class="Bound">n</a>
       <a id="20245" class="Keyword">where</a>
        <a id="20259" href="SyntheticHomotopyTheory.Circle.Induction.html#20259" class="Function">g</a> <a id="20261" class="Symbol">:</a> <a id="20263" class="Symbol">(</a><a id="20264" href="SyntheticHomotopyTheory.Circle.Induction.html#20264" class="Bound">n</a> <a id="20266" class="Symbol">:</a> <a id="20268" href="MLTT.Natural-Numbers-Type.html#96" class="Datatype">ℕ</a><a id="20269" class="Symbol">)</a> <a id="20271" class="Symbol">→</a> <a id="20273" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="20279" class="Symbol">(</a><a id="20280" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="20287" class="Symbol">(</a><a id="20288" href="SyntheticHomotopyTheory.Circle.Integers.html#607" class="InductiveConstructor">pos</a> <a id="20292" href="SyntheticHomotopyTheory.Circle.Induction.html#20264" class="Bound">n</a><a id="20293" class="Symbol">))</a> <a id="20296" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20298" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20303" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20305" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="20311" class="Symbol">(</a><a id="20312" href="SyntheticHomotopyTheory.Circle.Integers.html#607" class="InductiveConstructor">pos</a> <a id="20316" href="SyntheticHomotopyTheory.Circle.Induction.html#20264" class="Bound">n</a><a id="20317" class="Symbol">)</a>
        <a id="20327" href="SyntheticHomotopyTheory.Circle.Induction.html#20259" class="Function">g</a> <a id="20329" href="MLTT.Natural-Numbers-Type.html#113" class="InductiveConstructor">zero</a>     <a id="20338" class="Symbol">=</a> <a id="20340" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="20359" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20364" href="MLTT.Natural-Numbers-Type.html#113" class="InductiveConstructor">zero</a>
        <a id="20377" href="SyntheticHomotopyTheory.Circle.Induction.html#20259" class="Function">g</a> <a id="20379" class="Symbol">(</a><a id="20380" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="20385" href="SyntheticHomotopyTheory.Circle.Induction.html#20385" class="Bound">n</a><a id="20386" class="Symbol">)</a> <a id="20388" class="Symbol">=</a> <a id="20390" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="20409" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20414" class="Symbol">(</a><a id="20415" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="20420" href="SyntheticHomotopyTheory.Circle.Induction.html#20385" class="Bound">n</a><a id="20421" class="Symbol">)</a>
      <a id="20429" href="SyntheticHomotopyTheory.Circle.Induction.html#20018" class="Function">h</a> <a id="20431" class="Symbol">(</a><a id="20432" href="SyntheticHomotopyTheory.Circle.Integers.html#635" class="InductiveConstructor">neg</a> <a id="20436" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="20437" class="Symbol">)</a> <a id="20439" class="Symbol">=</a>
       <a id="20448" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20453" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20456" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20458" class="Symbol">(</a><a id="20459" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20464" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20467" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20469" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20483" class="Symbol">(</a><a id="20484" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20489" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20491" class="Symbol">)</a> <a id="20493" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="20494" class="Symbol">)</a> <a id="20496" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20498" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20503" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="20506" href="SyntheticHomotopyTheory.Circle.Induction.html#20744" class="Function">I&#39;</a>   <a id="20511" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
       <a id="20520" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20525" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20528" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20530" class="Symbol">(</a><a id="20531" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20545" class="Symbol">(</a><a id="20546" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20551" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20553" class="Symbol">)</a> <a id="20555" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a> <a id="20557" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20559" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20564" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20566" class="Symbol">)</a> <a id="20568" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20570" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20575" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="20578" href="SyntheticHomotopyTheory.Circle.Induction.html#20845" class="Function">II&#39;</a>  <a id="20583" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
       <a id="20592" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20597" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20600" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20602" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20616" class="Symbol">(</a><a id="20617" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20622" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20624" class="Symbol">)</a> <a id="20626" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a> <a id="20628" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20630" class="Symbol">(</a><a id="20631" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20636" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20639" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20641" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="20645" class="Symbol">)</a> <a id="20647" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="20650" href="SyntheticHomotopyTheory.Circle.Induction.html#21123" class="Function">III&#39;</a> <a id="20655" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
       <a id="20664" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20669" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20672" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20674" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20688" class="Symbol">(</a><a id="20689" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20694" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20696" class="Symbol">)</a> <a id="20698" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a>                    <a id="20719" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
        <a id="20729" class="Keyword">where</a>
         <a id="20744" href="SyntheticHomotopyTheory.Circle.Induction.html#20744" class="Function">I&#39;</a>   <a id="20749" class="Symbol">=</a> <a id="20751" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20754" class="Symbol">(λ</a> <a id="20757" href="SyntheticHomotopyTheory.Circle.Induction.html#20757" class="Bound">-</a> <a id="20759" class="Symbol">→</a> <a id="20761" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20766" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20769" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20771" href="SyntheticHomotopyTheory.Circle.Induction.html#20757" class="Bound">-</a> <a id="20773" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20775" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="20779" class="Symbol">)</a>
                 <a id="20798" class="Symbol">((</a><a id="20800" href="SyntheticHomotopyTheory.Circle.Induction.html#19071" class="Function">iterated-path-comm</a> <a id="20819" class="Symbol">(</a><a id="20820" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20825" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20827" class="Symbol">)</a> <a id="20829" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="20830" class="Symbol">)</a> <a id="20832" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20834" class="Symbol">)</a>
         <a id="20845" href="SyntheticHomotopyTheory.Circle.Induction.html#20845" class="Function">II&#39;</a>  <a id="20850" class="Symbol">=</a> <a id="20852" href="UF.Base.html#10779" class="Function">∙assoc</a> <a id="20859" class="Symbol">(</a><a id="20860" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20865" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20867" class="Symbol">)</a> <a id="20869" class="Symbol">(</a><a id="20870" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20884" class="Symbol">(</a><a id="20885" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20890" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20892" class="Symbol">)</a> <a id="20894" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a> <a id="20896" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20898" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20903" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20905" class="Symbol">)</a> <a id="20907" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
              <a id="20926" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="20928" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20931" class="Symbol">(</a><a id="20932" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20937" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="20940" href="MLTT.Id.html#968" class="Function Operator">∙_</a><a id="20942" class="Symbol">)</a>
                 <a id="20961" class="Symbol">(</a><a id="20962" href="UF.Base.html#10779" class="Function">∙assoc</a> <a id="20969" class="Symbol">(</a><a id="20970" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="20984" class="Symbol">(</a><a id="20985" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="20990" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20992" class="Symbol">)</a> <a id="20994" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="20995" class="Symbol">)</a> <a id="20997" class="Symbol">(</a><a id="20998" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21003" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21005" class="Symbol">)</a> <a id="21007" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21011" class="Symbol">)</a>
              <a id="21027" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="21029" class="Symbol">(</a><a id="21030" href="UF.Base.html#10779" class="Function">∙assoc</a> <a id="21037" class="Symbol">(</a><a id="21038" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21043" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21045" class="Symbol">)</a> <a id="21047" class="Symbol">(</a><a id="21048" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="21062" class="Symbol">(</a><a id="21063" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21068" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21070" class="Symbol">)</a> <a id="21072" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="21073" class="Symbol">)</a>
                  <a id="21093" class="Symbol">(</a><a id="21094" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21099" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="21102" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="21104" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21108" class="Symbol">))</a> <a id="21111" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
         <a id="21123" href="SyntheticHomotopyTheory.Circle.Induction.html#21123" class="Function">III&#39;</a> <a id="21128" class="Symbol">=</a> <a id="21130" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="21133" class="Symbol">((</a><a id="21135" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21140" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="21143" href="MLTT.Id.html#968" class="Function Operator">∙</a> <a id="21145" href="SyntheticHomotopyTheory.Circle.Induction.html#18925" class="Function">iterated-path</a> <a id="21159" class="Symbol">(</a><a id="21160" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21165" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21167" class="Symbol">)</a> <a id="21169" href="SyntheticHomotopyTheory.Circle.Induction.html#20436" class="Bound">n</a><a id="21170" class="Symbol">)</a> <a id="21172" href="MLTT.Id.html#968" class="Function Operator">∙_</a><a id="21174" class="Symbol">)</a>
                 <a id="21193" class="Symbol">(</a><a id="21194" href="UF.Base.html#11795" class="Function">left-inverse</a> <a id="21207" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21211" class="Symbol">)</a>

    <a id="21218" href="SyntheticHomotopyTheory.Circle.Induction.html#21218" class="Function">transport-loops-lemma</a> <a id="21240" class="Symbol">:</a> <a id="21242" href="MLTT.Id.html#735" class="Function">transport</a> <a id="21252" class="Symbol">(λ</a> <a id="21255" href="SyntheticHomotopyTheory.Circle.Induction.html#21255" class="Bound">-</a> <a id="21257" class="Symbol">→</a> <a id="21259" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21264" href="SyntheticHomotopyTheory.Circle.Induction.html#21255" class="Bound">-</a> <a id="21266" class="Symbol">→</a> <a id="21268" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="21273" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="21275" href="SyntheticHomotopyTheory.Circle.Induction.html#21255" class="Bound">-</a><a id="21276" class="Symbol">)</a> <a id="21278" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a>
                             <a id="21312" class="Symbol">(</a><a id="21313" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="21319" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21321" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a><a id="21335" class="Symbol">)</a>
                          <a id="21363" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="21365" class="Symbol">(</a><a id="21366" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="21372" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21374" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a><a id="21388" class="Symbol">)</a>
    <a id="21394" href="SyntheticHomotopyTheory.Circle.Induction.html#21218" class="Function">transport-loops-lemma</a> <a id="21416" class="Symbol">=</a>
     <a id="21423" href="MLTT.Id.html#735" class="Function">transport</a> <a id="21433" class="Symbol">(λ</a> <a id="21436" href="SyntheticHomotopyTheory.Circle.Induction.html#21436" class="Bound">-</a> <a id="21438" class="Symbol">→</a> <a id="21440" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21445" href="SyntheticHomotopyTheory.Circle.Induction.html#21436" class="Bound">-</a> <a id="21447" class="Symbol">→</a> <a id="21449" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="21454" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="21456" href="SyntheticHomotopyTheory.Circle.Induction.html#21436" class="Bound">-</a><a id="21457" class="Symbol">)</a> <a id="21459" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21464" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a>                     <a id="21486" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="21489" href="SyntheticHomotopyTheory.Circle.Induction.html#22050" class="Function">I</a>   <a id="21493" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="21500" href="MLTT.Id.html#735" class="Function">transport</a> <a id="21510" class="Symbol">(λ</a> <a id="21513" href="SyntheticHomotopyTheory.Circle.Induction.html#21513" class="Bound">-</a> <a id="21515" class="Symbol">→</a> <a id="21517" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="21522" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="21524" href="SyntheticHomotopyTheory.Circle.Induction.html#21513" class="Bound">-</a><a id="21525" class="Symbol">)</a> <a id="21527" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21532" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21534" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a> <a id="21536" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21538" href="MLTT.Id.html#735" class="Function">transport</a> <a id="21548" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21553" class="Symbol">(</a><a id="21554" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21559" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21561" class="Symbol">)</a> <a id="21563" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="21566" href="SyntheticHomotopyTheory.Circle.Induction.html#22104" class="Function">II</a>  <a id="21570" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="21577" class="Symbol">(</a><a id="21578" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="21581" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21585" class="Symbol">)</a> <a id="21587" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21589" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a> <a id="21591" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21593" href="MLTT.Id.html#735" class="Function">transport</a> <a id="21603" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21608" class="Symbol">(</a><a id="21609" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="21614" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="21616" class="Symbol">)</a>                       <a id="21640" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="21643" href="SyntheticHomotopyTheory.Circle.Induction.html#22122" class="Function">III</a> <a id="21647" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="21654" class="Symbol">(</a><a id="21655" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="21658" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21662" class="Symbol">)</a> <a id="21664" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21666" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="21672" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21674" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a> <a id="21676" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21678" href="SyntheticHomotopyTheory.Circle.Induction.html#21892" class="Function">ε</a> <a id="21680" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21682" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="21689" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21691" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a>                         <a id="21717" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="21720" href="SyntheticHomotopyTheory.Circle.Induction.html#22237" class="Function">IV</a>  <a id="21724" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="21731" class="Symbol">(</a><a id="21732" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="21735" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="21739" class="Symbol">)</a> <a id="21741" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21743" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="21749" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21751" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="21758" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21760" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a>                                 <a id="21794" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="21797" href="SyntheticHomotopyTheory.Circle.Induction.html#22377" class="Function">V</a>   <a id="21801" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="21808" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="21814" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="21816" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a>                                                      <a id="21871" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="21879" class="Keyword">where</a>
       <a id="21892" href="SyntheticHomotopyTheory.Circle.Induction.html#21892" class="Function">ε</a> <a id="21894" class="Symbol">:</a> <a id="21896" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a> <a id="21898" class="Symbol">→</a> <a id="21900" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21905" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>
       <a id="21917" href="SyntheticHomotopyTheory.Circle.Induction.html#21892" class="Function">ε</a> <a id="21919" class="Symbol">=</a> <a id="21921" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a>
       <a id="21943" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a> <a id="21945" class="Symbol">:</a> <a id="21947" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="21952" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="21957" class="Symbol">→</a> <a id="21959" href="SyntheticHomotopyTheory.Circle.Integers.html#553" class="Function">ℤ</a>
       <a id="21968" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a> <a id="21970" class="Symbol">=</a> <a id="21972" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a>
       <a id="21994" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a> <a id="21996" class="Symbol">:</a> <a id="21998" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="22003" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="22008" class="Symbol">→</a> <a id="22010" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="22015" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="22017" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a>
       <a id="22029" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a> <a id="22031" class="Symbol">=</a> <a id="22033" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="22039" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22041" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a>
       <a id="22050" href="SyntheticHomotopyTheory.Circle.Induction.html#22050" class="Function">I</a>   <a id="22054" class="Symbol">=</a> <a id="22056" href="UF.Base.html#17229" class="Function">transport-along-→</a> <a id="22074" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="22079" class="Symbol">(</a><a id="22080" href="MLTT.Id.html#193" class="Datatype Operator">_＝_</a> <a id="22084" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="22088" class="Symbol">)</a> <a id="22090" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="22095" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a>
       <a id="22104" href="SyntheticHomotopyTheory.Circle.Induction.html#22104" class="Function">II</a>  <a id="22108" class="Symbol">=</a> <a id="22110" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>
       <a id="22122" href="SyntheticHomotopyTheory.Circle.Induction.html#22122" class="Function">III</a> <a id="22126" class="Symbol">=</a> <a id="22128" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="22131" class="Symbol">((</a><a id="22133" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="22136" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="22140" class="Symbol">)</a> <a id="22142" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22144" href="SyntheticHomotopyTheory.Circle.Induction.html#21994" class="Function">f</a> <a id="22146" href="MLTT.Pi.html#513" class="Function Operator">∘_</a><a id="22148" class="Symbol">)</a>
              <a id="22164" class="Symbol">(</a><a id="22165" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="22173" class="Symbol">(</a><a id="22174" href="UF.Lower-FunExt.html#1138" class="Function">lower-funext</a> <a id="22187" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="22190" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a> <a id="22192" href="SyntheticHomotopyTheory.Circle.Induction.html#19849" class="Bound">fe</a><a id="22194" class="Symbol">)</a> <a id="22196" href="SyntheticHomotopyTheory.Circle.Induction.html#18127" class="Function">transport-code-loop⁻¹-is-pred-ℤ&#39;</a><a id="22228" class="Symbol">)</a>
       <a id="22237" href="SyntheticHomotopyTheory.Circle.Induction.html#22237" class="Function">IV</a>  <a id="22241" class="Symbol">=</a> <a id="22243" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="22246" class="Symbol">(λ</a> <a id="22249" href="SyntheticHomotopyTheory.Circle.Induction.html#22249" class="Bound">-</a> <a id="22251" class="Symbol">→</a> <a id="22253" class="Symbol">(</a><a id="22254" href="MLTT.Id.html#968" class="Function Operator">_∙</a> <a id="22257" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="22261" class="Symbol">)</a> <a id="22263" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22265" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="22271" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22273" href="SyntheticHomotopyTheory.Circle.Induction.html#22249" class="Bound">-</a> <a id="22275" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22277" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#675" class="Function">pred-ℤ</a> <a id="22284" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22286" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a><a id="22287" class="Symbol">)</a>
              <a id="22303" class="Symbol">(</a><a id="22304" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="22312" class="Symbol">(</a><a id="22313" href="UF.Lower-FunExt.html#1138" class="Function">lower-funext</a> <a id="22326" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="22329" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a> <a id="22331" href="SyntheticHomotopyTheory.Circle.Induction.html#19849" class="Bound">fe</a><a id="22333" class="Symbol">)</a> <a id="22335" class="Symbol">(</a><a id="22336" href="UF.Base.html#2366" class="Function">Idtofun-retraction</a> <a id="22355" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a><a id="22367" class="Symbol">))</a>
       <a id="22377" href="SyntheticHomotopyTheory.Circle.Induction.html#22377" class="Function">V</a>   <a id="22381" class="Symbol">=</a> <a id="22383" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="22386" class="Symbol">(</a><a id="22387" href="MLTT.Pi.html#513" class="Function Operator">_∘</a> <a id="22390" href="SyntheticHomotopyTheory.Circle.Induction.html#21943" class="Function">δ</a><a id="22391" class="Symbol">)</a> <a id="22393" href="SyntheticHomotopyTheory.Circle.Induction.html#19921" class="Function">loops-lemma</a>


    <a id="22411" class="Keyword">open</a> <a id="22416" href="SyntheticHomotopyTheory.Circle.Induction.html#4362" class="Module">𝕊¹-induction</a> <a id="22429" class="Symbol">(λ</a> <a id="22432" href="SyntheticHomotopyTheory.Circle.Induction.html#22432" class="Bound">-</a> <a id="22434" class="Symbol">→</a> <a id="22436" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="22441" href="SyntheticHomotopyTheory.Circle.Induction.html#22432" class="Bound">-</a> <a id="22443" class="Symbol">→</a> <a id="22445" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="22450" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="22452" href="SyntheticHomotopyTheory.Circle.Induction.html#22432" class="Bound">-</a><a id="22453" class="Symbol">)</a>
                      <a id="22477" class="Symbol">(</a><a id="22478" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="22484" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="22486" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a><a id="22500" class="Symbol">)</a>
                      <a id="22524" href="SyntheticHomotopyTheory.Circle.Induction.html#21218" class="Function">transport-loops-lemma</a>

    <a id="22551" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22558" class="Symbol">:</a> <a id="22560" class="Symbol">(</a><a id="22561" href="SyntheticHomotopyTheory.Circle.Induction.html#22561" class="Bound">x</a> <a id="22563" class="Symbol">:</a> <a id="22565" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="22567" class="Symbol">)</a> <a id="22569" class="Symbol">→</a> <a id="22571" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="22576" href="SyntheticHomotopyTheory.Circle.Induction.html#22561" class="Bound">x</a> <a id="22578" class="Symbol">→</a> <a id="22580" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="22585" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="22587" href="SyntheticHomotopyTheory.Circle.Induction.html#22561" class="Bound">x</a>
    <a id="22593" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22600" class="Symbol">=</a> <a id="22602" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a>

    <a id="22620" href="SyntheticHomotopyTheory.Circle.Induction.html#22620" class="Function">decode-encode</a> <a id="22634" class="Symbol">:</a> <a id="22636" class="Symbol">(</a><a id="22637" href="SyntheticHomotopyTheory.Circle.Induction.html#22637" class="Bound">x</a> <a id="22639" class="Symbol">:</a> <a id="22641" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a><a id="22643" class="Symbol">)</a> <a id="22645" class="Symbol">(</a><a id="22646" href="SyntheticHomotopyTheory.Circle.Induction.html#22646" class="Bound">p</a> <a id="22648" class="Symbol">:</a> <a id="22650" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="22655" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="22657" href="SyntheticHomotopyTheory.Circle.Induction.html#22637" class="Bound">x</a><a id="22658" class="Symbol">)</a> <a id="22660" class="Symbol">→</a> <a id="22662" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22669" href="SyntheticHomotopyTheory.Circle.Induction.html#22637" class="Bound">x</a> <a id="22671" class="Symbol">(</a><a id="22672" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="22679" href="SyntheticHomotopyTheory.Circle.Induction.html#22637" class="Bound">x</a> <a id="22681" href="SyntheticHomotopyTheory.Circle.Induction.html#22646" class="Bound">p</a><a id="22682" class="Symbol">)</a> <a id="22684" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="22686" href="SyntheticHomotopyTheory.Circle.Induction.html#22646" class="Bound">p</a>
    <a id="22692" href="SyntheticHomotopyTheory.Circle.Induction.html#22620" class="Function">decode-encode</a> <a id="22706" href="SyntheticHomotopyTheory.Circle.Induction.html#22706" class="Bound">base</a> <a id="22711" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="22716" class="Symbol">=</a>
     <a id="22723" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22730" href="SyntheticHomotopyTheory.Circle.Induction.html#22706" class="Bound">base</a> <a id="22735" class="Symbol">(</a><a id="22736" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="22743" href="SyntheticHomotopyTheory.Circle.Induction.html#22706" class="Bound">base</a> <a id="22748" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="22752" class="Symbol">)</a>                       <a id="22776" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="22779" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="22784" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="22791" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22798" href="SyntheticHomotopyTheory.Circle.Induction.html#22706" class="Bound">base</a> <a id="22803" class="Symbol">(</a><a id="22804" href="MLTT.Id.html#735" class="Function">transport</a> <a id="22814" href="SyntheticHomotopyTheory.Circle.Induction.html#15523" class="Function">code</a> <a id="22819" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="22824" class="Symbol">(</a><a id="22825" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="22840" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="22841" class="Symbol">))</a> <a id="22844" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="22847" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="22852" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="22859" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="22866" href="SyntheticHomotopyTheory.Circle.Induction.html#22706" class="Bound">base</a> <a id="22871" class="Symbol">(</a><a id="22872" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="22887" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="22888" class="Symbol">)</a>                       <a id="22912" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="22915" href="SyntheticHomotopyTheory.Circle.Induction.html#23222" class="Function">I</a>    <a id="22920" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="22927" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="22933" class="Symbol">(</a><a id="22934" href="SyntheticHomotopyTheory.Circle.Induction.html#15805" class="Function">code-base-to-ℤ</a> <a id="22949" class="Symbol">(</a><a id="22950" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="22965" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="22966" class="Symbol">))</a>            <a id="22980" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="22983" href="SyntheticHomotopyTheory.Circle.Induction.html#23281" class="Function">II</a>   <a id="22988" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="22995" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="23001" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a>                                              <a id="23048" href="MLTT.Id.html#2703" class="Function Operator">＝⟨</a> <a id="23051" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="23056" href="MLTT.Id.html#2703" class="Function Operator">⟩</a>
     <a id="23063" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>                                                 <a id="23116" href="MLTT.Id.html#2785" class="Function Operator">∎</a>
      <a id="23124" class="Keyword">where</a>

<a id="23131" class="Markup">\end{code}</a><a id="23141" class="Background">

       Using the first computation rule for 𝕊¹-induction

</a><a id="23201" class="Markup">\begin{code}</a>

       <a id="23222" href="SyntheticHomotopyTheory.Circle.Induction.html#23222" class="Function">I</a>  <a id="23225" class="Symbol">=</a> <a id="23227" href="UF.Base.html#11014" class="Function">happly</a> <a id="23234" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="23255" class="Symbol">(</a><a id="23256" href="SyntheticHomotopyTheory.Circle.Induction.html#15724" class="Function">ℤ-to-code-base</a> <a id="23271" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="23272" class="Symbol">)</a>
       <a id="23281" href="SyntheticHomotopyTheory.Circle.Induction.html#23281" class="Function">II</a> <a id="23284" class="Symbol">=</a> <a id="23286" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="23289" href="SyntheticHomotopyTheory.Circle.Induction.html#19677" class="Function">loops</a> <a id="23295" class="Symbol">(</a><a id="23296" href="UF.Base.html#2366" class="Function">Idtofun-retraction</a> <a id="23315" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="23328" href="SyntheticHomotopyTheory.Circle.Integers.html#585" class="InductiveConstructor">𝟎</a><a id="23329" class="Symbol">)</a>

    <a id="23336" class="Keyword">open</a> <a id="23341" class="Keyword">import</a> <a id="23348" href="UF.Retracts.html" class="Module">UF.Retracts</a>

    <a id="23365" href="SyntheticHomotopyTheory.Circle.Induction.html#23365" class="Function">Ω𝕊¹-is-set</a> <a id="23376" class="Symbol">:</a> <a id="23378" href="UF.Sets.html#709" class="Function">is-set</a> <a id="23385" class="Symbol">(</a><a id="23386" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="23391" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="23393" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23397" class="Symbol">)</a>
    <a id="23403" href="SyntheticHomotopyTheory.Circle.Induction.html#23365" class="Function">Ω𝕊¹-is-set</a> <a id="23414" class="Symbol">=</a> <a id="23416" href="UF.Sets-Properties.html#352" class="Function">subtypes-of-sets-are-sets&#39;</a> <a id="23443" class="Symbol">(</a><a id="23444" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="23451" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23455" class="Symbol">)</a>
                  <a id="23475" class="Symbol">(</a><a id="23476" href="UF.Retracts.html#1119" class="Function">sections-are-lc</a> <a id="23492" class="Symbol">(</a><a id="23493" href="SyntheticHomotopyTheory.Circle.Induction.html#18829" class="Function">encode</a> <a id="23500" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23504" class="Symbol">)</a>
                   <a id="23525" class="Symbol">((</a><a id="23527" href="SyntheticHomotopyTheory.Circle.Induction.html#22551" class="Function">decode</a> <a id="23534" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23538" class="Symbol">)</a> <a id="23540" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="23542" class="Symbol">(</a><a id="23543" href="SyntheticHomotopyTheory.Circle.Induction.html#22620" class="Function">decode-encode</a> <a id="23557" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23561" class="Symbol">)))</a>
                   <a id="23584" class="Symbol">(</a><a id="23585" href="MLTT.Id.html#735" class="Function">transport</a> <a id="23595" href="UF.Sets.html#709" class="Function">is-set</a> <a id="23602" class="Symbol">(</a><a id="23603" href="SyntheticHomotopyTheory.Circle.Induction.html#15647" class="Function">code-on-base</a> <a id="23616" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="23618" class="Symbol">)</a> <a id="23620" href="SyntheticHomotopyTheory.Circle.Integers-Properties.html#413" class="Function">ℤ-is-set</a><a id="23628" class="Symbol">)</a>

  <a id="23633" class="Keyword">module</a> <a id="23640" href="SyntheticHomotopyTheory.Circle.Induction.html#23640" class="Module">𝕊¹-induction&#39;</a>
          <a id="23664" class="Symbol">{</a><a id="23665" href="SyntheticHomotopyTheory.Circle.Induction.html#23665" class="Bound">𝓥</a> <a id="23667" class="Symbol">:</a> <a id="23669" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="23677" class="Symbol">}</a>
          <a id="23689" class="Symbol">(</a><a id="23690" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="23692" class="Symbol">:</a> <a id="23694" href="SyntheticHomotopyTheory.Circle.Induction.html#2357" class="Bound">𝕊¹</a> <a id="23697" class="Symbol">→</a> <a id="23699" href="SyntheticHomotopyTheory.Circle.Induction.html#23665" class="Bound">𝓥</a> <a id="23701" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="23703" class="Symbol">)</a>
          <a id="23715" class="Symbol">(</a><a id="23716" href="SyntheticHomotopyTheory.Circle.Induction.html#23716" class="Bound">a</a> <a id="23718" class="Symbol">:</a> <a id="23720" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="23722" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a><a id="23726" class="Symbol">)</a>
          <a id="23738" class="Symbol">(</a><a id="23739" href="SyntheticHomotopyTheory.Circle.Induction.html#23739" class="Bound">l</a> <a id="23741" class="Symbol">:</a> <a id="23743" href="MLTT.Id.html#735" class="Function">transport</a> <a id="23753" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="23755" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="23760" href="SyntheticHomotopyTheory.Circle.Induction.html#23716" class="Bound">a</a> <a id="23762" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="23764" href="SyntheticHomotopyTheory.Circle.Induction.html#23716" class="Bound">a</a><a id="23765" class="Symbol">)</a>
          <a id="23777" class="Symbol">(</a><a id="23778" href="SyntheticHomotopyTheory.Circle.Induction.html#23778" class="Bound">fe</a> <a id="23781" class="Symbol">:</a> <a id="23783" href="UF.FunExt.html#850" class="Function">funext</a> <a id="23790" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="23793" href="SyntheticHomotopyTheory.Circle.Induction.html#2362" class="Bound">𝓤</a><a id="23794" class="Symbol">)</a>
          <a id="23806" class="Symbol">(</a><a id="23807" href="SyntheticHomotopyTheory.Circle.Induction.html#23807" class="Bound">ua</a> <a id="23810" class="Symbol">:</a> <a id="23812" href="UF.Univalence.html#412" class="Function">is-univalent</a> <a id="23825" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a><a id="23827" class="Symbol">)</a>
         <a id="23838" class="Keyword">where</a>

   <a id="23848" class="Keyword">open</a> <a id="23853" href="SyntheticHomotopyTheory.Circle.Induction.html#4362" class="Module">𝕊¹-induction</a> <a id="23866" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="23868" href="SyntheticHomotopyTheory.Circle.Induction.html#23716" class="Bound">a</a> <a id="23870" href="SyntheticHomotopyTheory.Circle.Induction.html#23739" class="Bound">l</a>

   <a id="23876" href="SyntheticHomotopyTheory.Circle.Induction.html#23876" class="Function">𝕊¹-induction-on-loop&#39;</a> <a id="23898" class="Symbol">:</a> <a id="23900" href="MLTT.Id.html#735" class="Function">transport</a> <a id="23910" class="Symbol">(λ</a> <a id="23913" href="SyntheticHomotopyTheory.Circle.Induction.html#23913" class="Bound">-</a> <a id="23915" class="Symbol">→</a> <a id="23917" href="MLTT.Id.html#735" class="Function">transport</a> <a id="23927" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="23929" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="23934" href="SyntheticHomotopyTheory.Circle.Induction.html#23913" class="Bound">-</a> <a id="23936" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="23938" href="SyntheticHomotopyTheory.Circle.Induction.html#23913" class="Bound">-</a><a id="23939" class="Symbol">)</a>
                            <a id="23969" href="SyntheticHomotopyTheory.Circle.Induction.html#11116" class="Function">𝕊¹-induction-on-base</a> <a id="23990" class="Symbol">(</a><a id="23991" href="UF.Base.html#7318" class="Function">apd</a> <a id="23995" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="24008" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="24012" class="Symbol">)</a>
                         <a id="24039" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="24041" href="SyntheticHomotopyTheory.Circle.Induction.html#23739" class="Bound">l</a>
   <a id="24046" href="SyntheticHomotopyTheory.Circle.Induction.html#23876" class="Function">𝕊¹-induction-on-loop&#39;</a> <a id="24068" class="Symbol">=</a> <a id="24070" href="SyntheticHomotopyTheory.Circle.Induction.html#14226" class="Function">𝕊¹-induction-on-loop</a> <a id="24091" class="Symbol">(</a><a id="24092" href="SyntheticHomotopyTheory.Circle.Induction.html#23365" class="Function">Ω𝕊¹-is-set</a> <a id="24103" href="SyntheticHomotopyTheory.Circle.Induction.html#23807" class="Bound">ua</a> <a id="24106" href="SyntheticHomotopyTheory.Circle.Induction.html#23778" class="Bound">fe</a><a id="24108" class="Symbol">)</a>

   <a id="24114" href="SyntheticHomotopyTheory.Circle.Induction.html#24114" class="Function">𝕊¹-induction-comp&#39;</a> <a id="24133" class="Symbol">:</a> <a id="24135" class="Symbol">(</a><a id="24136" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="24149" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="24154" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="24156" href="UF.Base.html#7318" class="Function">apd</a> <a id="24160" href="SyntheticHomotopyTheory.Circle.Induction.html#5503" class="Function">𝕊¹-induction</a> <a id="24173" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a><a id="24177" class="Symbol">)</a>
                      <a id="24201" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="24204" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="24206" href="SyntheticHomotopyTheory.Circle.Induction.html#24206" class="Bound">y</a> <a id="24208" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="24210" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="24212" href="SyntheticHomotopyTheory.Circle.Induction.html#2377" class="Bound">base</a> <a id="24217" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="24219" href="MLTT.Id.html#735" class="Function">transport</a> <a id="24229" href="SyntheticHomotopyTheory.Circle.Induction.html#23690" class="Bound">A</a> <a id="24231" href="SyntheticHomotopyTheory.Circle.Induction.html#2397" class="Bound">loop</a> <a id="24236" href="SyntheticHomotopyTheory.Circle.Induction.html#24206" class="Bound">y</a> <a id="24238" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="24240" href="SyntheticHomotopyTheory.Circle.Induction.html#24206" class="Bound">y</a> <a id="24242" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="24244" class="Symbol">(</a><a id="24245" href="SyntheticHomotopyTheory.Circle.Induction.html#23716" class="Bound">a</a> <a id="24247" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="24249" href="SyntheticHomotopyTheory.Circle.Induction.html#23739" class="Bound">l</a><a id="24250" class="Symbol">)</a>
   <a id="24255" href="SyntheticHomotopyTheory.Circle.Induction.html#24114" class="Function">𝕊¹-induction-comp&#39;</a> <a id="24274" class="Symbol">=</a> <a id="24276" href="SyntheticHomotopyTheory.Circle.Induction.html#14630" class="Function">𝕊¹-induction-comp</a> <a id="24294" class="Symbol">(</a><a id="24295" href="SyntheticHomotopyTheory.Circle.Induction.html#23365" class="Function">Ω𝕊¹-is-set</a> <a id="24306" href="SyntheticHomotopyTheory.Circle.Induction.html#23807" class="Bound">ua</a> <a id="24309" href="SyntheticHomotopyTheory.Circle.Induction.html#23778" class="Bound">fe</a><a id="24311" class="Symbol">)</a>

<a id="24314" class="Markup">\end{code}</a><a id="24324" class="Background">
</a></pre></body></html>