<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Iterative.Sets</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Martin Escardo &amp; Tom de Jong, June 2023.

Iterative sets.

We define the type of iterative sets as a subtype of that of multisets.

  * H. R. Gylterud, &quot;From multisets to sets in homotopy type theory&quot;.
    The Journal of Symbolic Logic, vol. 83, no. 3, pp. 1132–1146,
    2018. https://doi.org/10.1017/jsl.2017.84

See the module Iterative.index for further bibliographic references.

The previous module Iterative.Multisets doesn&#39;t make significant use
of univalence, and so we assumed it only for specific
constructions. But here the use of univalence is more pervasive, and
so we assume it globally.

</a><a id="605" class="Markup">\begin{code}</a>

<a id="619" class="Symbol">{-#</a> <a id="623" class="Keyword">OPTIONS</a> <a id="631" class="Pragma">--safe</a> <a id="638" class="Pragma">--without-K</a> <a id="650" class="Pragma">--lossy-unification</a> <a id="670" class="Symbol">#-}</a>

<a id="675" class="Keyword">open</a> <a id="680" class="Keyword">import</a> <a id="687" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="700" class="Keyword">open</a> <a id="705" class="Keyword">import</a> <a id="712" href="UF.Univalence.html" class="Module">UF.Univalence</a>

<a id="727" class="Keyword">module</a> <a id="734" href="Iterative.Sets.html" class="Module">Iterative.Sets</a>
        <a id="757" class="Symbol">(</a><a id="758" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="761" class="Symbol">:</a> <a id="763" href="UF.Univalence.html#494" class="Function">Univalence</a><a id="773" class="Symbol">)</a>
        <a id="783" class="Symbol">(</a><a id="784" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="786" class="Symbol">:</a> <a id="788" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="796" class="Symbol">)</a>
       <a id="805" class="Keyword">where</a>

<a id="812" class="Keyword">open</a> <a id="817" class="Keyword">import</a> <a id="824" href="UF.FunExt.html" class="Module">UF.FunExt</a>
<a id="834" class="Keyword">open</a> <a id="839" class="Keyword">import</a> <a id="846" href="UF.UA-FunExt.html" class="Module">UF.UA-FunExt</a>

<a id="860" class="Keyword">private</a>
 <a id="𝓤⁺"></a><a id="869" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="872" class="Symbol">:</a> <a id="874" href="Agda.Primitive.html#742" class="Postulate">Universe</a>
 <a id="884" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="887" class="Symbol">=</a> <a id="889" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="891" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a>

 <a id="fe"></a><a id="895" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="898" class="Symbol">:</a> <a id="900" href="UF.FunExt.html#1047" class="Function">Fun-Ext</a>
 <a id="909" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="912" class="Symbol">=</a> <a id="914" href="UF.UA-FunExt.html#2577" class="Function">Univalence-gives-Fun-Ext</a> <a id="939" href="Iterative.Sets.html#758" class="Bound">ua</a>

 <a id="fe&#39;"></a><a id="944" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="948" class="Symbol">:</a> <a id="950" href="UF.FunExt.html#995" class="Function">FunExt</a>
 <a id="958" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="962" href="Iterative.Sets.html#962" class="Bound">𝓤</a> <a id="964" href="Iterative.Sets.html#964" class="Bound">𝓥</a> <a id="966" class="Symbol">=</a> <a id="968" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="971" class="Symbol">{</a><a id="972" href="Iterative.Sets.html#962" class="Bound">𝓤</a><a id="973" class="Symbol">}</a> <a id="975" class="Symbol">{</a><a id="976" href="Iterative.Sets.html#964" class="Bound">𝓥</a><a id="977" class="Symbol">}</a>

<a id="980" class="Keyword">open</a> <a id="985" class="Keyword">import</a> <a id="992" href="Iterative.Multisets.html" class="Module">Iterative.Multisets</a> <a id="1012" href="Iterative.Sets.html#784" class="Bound">𝓤</a>
<a id="1014" class="Keyword">open</a> <a id="1019" class="Keyword">import</a> <a id="1026" href="Ordinals.Notions.html" class="Module">Ordinals.Notions</a>
<a id="1043" class="Keyword">open</a> <a id="1048" class="Keyword">import</a> <a id="1055" href="UF.Base.html" class="Module">UF.Base</a>
<a id="1063" class="Keyword">open</a> <a id="1068" class="Keyword">import</a> <a id="1075" href="UF.DiscreteAndSeparated.html" class="Module">UF.DiscreteAndSeparated</a>
<a id="1099" class="Keyword">open</a> <a id="1104" class="Keyword">import</a> <a id="1111" href="UF.Embeddings.html" class="Module">UF.Embeddings</a>
<a id="1125" class="Keyword">open</a> <a id="1130" class="Keyword">import</a> <a id="1137" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="1146" class="Keyword">open</a> <a id="1151" class="Keyword">import</a> <a id="1158" href="UF.EquivalenceExamples.html" class="Module">UF.EquivalenceExamples</a>
<a id="1181" class="Keyword">open</a> <a id="1186" class="Keyword">import</a> <a id="1193" href="UF.PairFun.html" class="Module">UF.PairFun</a>
<a id="1204" class="Keyword">open</a> <a id="1209" class="Keyword">import</a> <a id="1216" href="UF.Retracts.html" class="Module">UF.Retracts</a>
<a id="1228" class="Keyword">open</a> <a id="1233" class="Keyword">import</a> <a id="1240" href="UF.Sets.html" class="Module">UF.Sets</a>
<a id="1248" class="Keyword">open</a> <a id="1253" class="Keyword">import</a> <a id="1260" href="UF.Size.html" class="Module">UF.Size</a>
<a id="1268" class="Keyword">open</a> <a id="1273" class="Keyword">import</a> <a id="1280" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>
<a id="1297" class="Keyword">open</a> <a id="1302" class="Keyword">import</a> <a id="1309" href="UF.Subsingletons-FunExt.html" class="Module">UF.Subsingletons-FunExt</a>
<a id="1333" class="Keyword">open</a> <a id="1338" class="Keyword">import</a> <a id="1345" href="W.Type.html" class="Module">W.Type</a>

<a id="1353" class="Markup">\end{code}</a><a id="1363" class="Background">

An iterative set is a multiset whose subforests are all
embeddings. The effect of that is that the membership relation on
iterative sets is proposition-valued, rather than just type-valued, as
is the case for general multisets.

</a><a id="1594" class="Markup">\begin{code}</a>

<a id="is-iterative-set"></a><a id="1608" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1625" class="Symbol">:</a> <a id="1627" href="Iterative.Multisets.html#690" class="Function">𝕄</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="1634" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="1636" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1653" class="Symbol">(</a><a id="1654" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="1659" href="Iterative.Sets.html#1659" class="Bound">X</a> <a id="1661" href="Iterative.Sets.html#1661" class="Bound">φ</a><a id="1662" class="Symbol">)</a> <a id="1664" class="Symbol">=</a> <a id="1666" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="1679" href="Iterative.Sets.html#1661" class="Bound">φ</a>
                            <a id="1709" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="1711" class="Symbol">((</a><a id="1713" href="Iterative.Sets.html#1713" class="Bound">x</a> <a id="1715" class="Symbol">:</a> <a id="1717" href="Iterative.Sets.html#1659" class="Bound">X</a><a id="1718" class="Symbol">)</a> <a id="1720" class="Symbol">→</a> <a id="1722" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1739" class="Symbol">(</a><a id="1740" href="Iterative.Sets.html#1661" class="Bound">φ</a> <a id="1742" href="Iterative.Sets.html#1713" class="Bound">x</a><a id="1743" class="Symbol">))</a>
<a id="1746" class="Markup">\end{code}</a><a id="1756" class="Background">

It is convenient to name the projections for the sake of clarity:

</a><a id="1825" class="Markup">\begin{code}</a>

<a id="𝕄-forest-is-embedding"></a><a id="1839" href="Iterative.Sets.html#1839" class="Function">𝕄-forest-is-embedding</a> <a id="1861" class="Symbol">:</a> <a id="1863" class="Symbol">(</a><a id="1864" href="Iterative.Sets.html#1864" class="Bound">M</a> <a id="1866" class="Symbol">:</a> <a id="1868" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="1869" class="Symbol">)</a>
                      <a id="1893" class="Symbol">→</a> <a id="1895" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1912" href="Iterative.Sets.html#1864" class="Bound">M</a>
                      <a id="1936" class="Symbol">→</a> <a id="1938" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="1951" class="Symbol">(</a><a id="1952" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="1961" href="Iterative.Sets.html#1864" class="Bound">M</a><a id="1962" class="Symbol">)</a>
<a id="1964" href="Iterative.Sets.html#1839" class="Function">𝕄-forest-is-embedding</a> <a id="1986" class="Symbol">(</a><a id="1987" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="1992" class="Symbol">_</a> <a id="1994" class="Symbol">_)</a> <a id="1997" class="Symbol">=</a> <a id="1999" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a>

<a id="𝕄-subtrees-are-iterative"></a><a id="2004" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a> <a id="2029" class="Symbol">:</a> <a id="2031" class="Symbol">(</a><a id="2032" href="Iterative.Sets.html#2032" class="Bound">M</a> <a id="2034" class="Symbol">:</a> <a id="2036" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="2037" class="Symbol">)</a>
                         <a id="2064" class="Symbol">→</a> <a id="2066" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2083" href="Iterative.Sets.html#2032" class="Bound">M</a>
                         <a id="2110" class="Symbol">→</a> <a id="2112" class="Symbol">(</a><a id="2113" href="Iterative.Sets.html#2113" class="Bound">x</a> <a id="2115" class="Symbol">:</a> <a id="2117" href="Iterative.Multisets.html#1707" class="Function">𝕄-root</a> <a id="2124" href="Iterative.Sets.html#2032" class="Bound">M</a><a id="2125" class="Symbol">)</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2146" class="Symbol">(</a><a id="2147" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="2156" href="Iterative.Sets.html#2032" class="Bound">M</a> <a id="2158" href="Iterative.Sets.html#2113" class="Bound">x</a><a id="2159" class="Symbol">)</a>
<a id="2161" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a> <a id="2186" class="Symbol">(</a><a id="2187" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="2192" class="Symbol">_</a> <a id="2194" class="Symbol">_)</a> <a id="2197" class="Symbol">=</a> <a id="2199" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a>

<a id="2204" class="Markup">\end{code}</a><a id="2214" class="Background">

It is crucial that the notion of iterative set is property rather than
data:

</a><a id="2294" class="Markup">\begin{code}</a>

<a id="being-iset-is-prop"></a><a id="2308" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2327" class="Symbol">:</a> <a id="2329" class="Symbol">(</a><a id="2330" href="Iterative.Sets.html#2330" class="Bound">M</a> <a id="2332" class="Symbol">:</a> <a id="2334" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="2335" class="Symbol">)</a> <a id="2337" class="Symbol">→</a> <a id="2339" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2365" href="Iterative.Sets.html#2330" class="Bound">M</a><a id="2366" class="Symbol">)</a>
<a id="2368" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2387" class="Symbol">(</a><a id="2388" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="2393" href="Iterative.Sets.html#2393" class="Bound">X</a> <a id="2395" href="Iterative.Sets.html#2395" class="Bound">φ</a><a id="2396" class="Symbol">)</a> <a id="2398" class="Symbol">=</a>
 <a id="2401" href="UF.Subsingletons.html#4801" class="Function">×-is-prop</a>
  <a id="2413" class="Symbol">(</a><a id="2414" href="UF.Embeddings.html#691" class="Function">being-embedding-is-prop</a> <a id="2438" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="2441" href="Iterative.Sets.html#2395" class="Bound">φ</a><a id="2442" class="Symbol">)</a>
  <a id="2446" class="Symbol">(</a><a id="2447" href="UF.Subsingletons-FunExt.html#614" class="Function">Π-is-prop</a> <a id="2457" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="2460" class="Symbol">(λ</a> <a id="2463" href="Iterative.Sets.html#2463" class="Bound">x</a> <a id="2465" class="Symbol">→</a> <a id="2467" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2486" class="Symbol">(</a><a id="2487" href="Iterative.Sets.html#2395" class="Bound">φ</a> <a id="2489" href="Iterative.Sets.html#2463" class="Bound">x</a><a id="2490" class="Symbol">)))</a>

<a id="2495" class="Markup">\end{code}</a><a id="2505" class="Background">

The type of iterative sets as a subtype of that of iterative
multisets:

</a><a id="2580" class="Markup">\begin{code}</a>

<a id="𝕍"></a><a id="2594" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2596" class="Symbol">:</a> <a id="2598" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="2601" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="2603" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2605" class="Symbol">=</a> <a id="2607" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="2609" href="Iterative.Sets.html#2609" class="Bound">M</a> <a id="2611" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="2613" href="Iterative.Multisets.html#690" class="Function">𝕄</a> <a id="2615" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="2617" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2634" href="Iterative.Sets.html#2609" class="Bound">M</a>

<a id="𝕍-is-locally-small"></a><a id="2637" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="2656" class="Symbol">:</a> <a id="2658" href="UF.Size.html#27103" class="Function">is-locally-small</a> <a id="2675" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="2677" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="2696" class="Symbol">=</a> <a id="2698" href="UF.Size.html#29493" class="Function">subtype-is-locally-small</a>
                      <a id="2745" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>
                      <a id="2786" class="Symbol">(</a><a id="2787" href="Iterative.Multisets.html#7443" class="Function">𝕄-is-locally-small</a> <a id="2806" href="Iterative.Sets.html#758" class="Bound">ua</a><a id="2808" class="Symbol">)</a>
<a id="2810" class="Markup">\end{code}</a><a id="2820" class="Background">

We again name the projections for the sake of clarity:

</a><a id="2878" class="Markup">\begin{code}</a>

<a id="underlying-mset"></a><a id="2892" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="2908" class="Symbol">:</a> <a id="2910" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2912" class="Symbol">→</a> <a id="2914" href="Iterative.Multisets.html#690" class="Function">𝕄</a>
<a id="2916" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="2932" class="Symbol">=</a> <a id="2934" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a>

<a id="isets-are-iterative"></a><a id="2939" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="2959" class="Symbol">:</a> <a id="2961" class="Symbol">(</a><a id="2962" href="Iterative.Sets.html#2962" class="Bound">A</a> <a id="2964" class="Symbol">:</a> <a id="2966" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="2967" class="Symbol">)</a> <a id="2969" class="Symbol">→</a> <a id="2971" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2988" class="Symbol">(</a><a id="2989" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3005" href="Iterative.Sets.html#2962" class="Bound">A</a><a id="3006" class="Symbol">)</a>
<a id="3008" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="3028" class="Symbol">=</a> <a id="3030" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a>

<a id="3035" class="Markup">\end{code}</a><a id="3045" class="Background">

Because the notion of iterative set is property, we get that 𝕍 is
indeed a subtype of 𝕄.

</a><a id="3137" class="Markup">\begin{code}</a>

<a id="underlying-mset-is-embedding"></a><a id="3151" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a> <a id="3180" class="Symbol">:</a> <a id="3182" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="3195" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a>
<a id="3211" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a> <a id="3240" class="Symbol">=</a> <a id="3242" href="UF.Embeddings.html#8620" class="Function">pr₁-is-embedding</a> <a id="3259" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>

<a id="3279" class="Markup">\end{code}</a><a id="3289" class="Background">

We define the root and the forest of an iterative set in terms of
those for multisets, but we need to add a &quot;proof obligation&quot; in the
case of the forest.

</a><a id="3446" class="Markup">\begin{code}</a>

<a id="𝕍-root"></a><a id="3460" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3467" class="Symbol">:</a> <a id="3469" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="3471" class="Symbol">→</a> <a id="3473" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="3475" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="3477" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3484" href="Iterative.Sets.html#3484" class="Bound">A</a> <a id="3486" class="Symbol">=</a> <a id="3488" href="Iterative.Multisets.html#1707" class="Function">𝕄-root</a> <a id="3495" class="Symbol">(</a><a id="3496" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3512" href="Iterative.Sets.html#3484" class="Bound">A</a><a id="3513" class="Symbol">)</a>

<a id="𝕍-forest"></a><a id="3516" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="3525" class="Symbol">:</a> <a id="3527" class="Symbol">(</a><a id="3528" href="Iterative.Sets.html#3528" class="Bound">A</a> <a id="3530" class="Symbol">:</a> <a id="3532" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="3533" class="Symbol">)</a> <a id="3535" class="Symbol">→</a> <a id="3537" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3544" href="Iterative.Sets.html#3528" class="Bound">A</a> <a id="3546" class="Symbol">→</a> <a id="3548" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="3550" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="3559" href="Iterative.Sets.html#3559" class="Bound">A</a> <a id="3561" href="Iterative.Sets.html#3561" class="Bound">x</a> <a id="3563" class="Symbol">=</a> <a id="3565" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="3574" class="Symbol">(</a><a id="3575" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3591" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3592" class="Symbol">)</a> <a id="3594" href="Iterative.Sets.html#3561" class="Bound">x</a> <a id="3596" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
               <a id="3613" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a>
                <a id="3654" class="Symbol">(</a><a id="3655" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3671" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3672" class="Symbol">)</a>
                <a id="3690" class="Symbol">(</a><a id="3691" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="3711" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3712" class="Symbol">)</a>
                <a id="3730" href="Iterative.Sets.html#3561" class="Bound">x</a>

<a id="3733" class="Markup">\end{code}</a><a id="3743" class="Background">

A criterion for equality in 𝕍:

</a><a id="3777" class="Markup">\begin{code}</a>

<a id="to-𝕍-＝"></a><a id="3791" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="3798" class="Symbol">:</a> <a id="3800" class="Symbol">{</a><a id="3801" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3803" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3805" class="Symbol">:</a> <a id="3807" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="3809" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="3811" class="Symbol">}</a>
          <a id="3823" class="Symbol">{</a><a id="3824" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="3826" class="Symbol">:</a> <a id="3828" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3830" class="Symbol">→</a> <a id="3832" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="3833" class="Symbol">}</a>
          <a id="3845" class="Symbol">{</a><a id="3846" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="3848" class="Symbol">:</a> <a id="3850" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3852" class="Symbol">→</a> <a id="3854" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="3855" class="Symbol">}</a>
        <a id="3865" class="Symbol">→</a> <a id="3867" class="Symbol">(</a><a id="3868" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="3870" href="Iterative.Sets.html#3870" class="Bound">p</a> <a id="3872" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="3874" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3876" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3878" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3880" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="3882" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="3884" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3886" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="3888" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="3890" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="3898" href="Iterative.Sets.html#3870" class="Bound">p</a><a id="3899" class="Symbol">)</a>
        <a id="3909" class="Symbol">→</a> <a id="3911" class="Symbol">(</a><a id="3912" href="Iterative.Sets.html#3912" class="Bound">i</a> <a id="3914" class="Symbol">:</a> <a id="3916" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="3933" class="Symbol">(</a><a id="3934" class="InductiveConstructor">ssup</a> <a id="3939" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3941" href="Iterative.Sets.html#3824" class="Bound">φ</a><a id="3942" class="Symbol">))</a>
          <a id="3955" class="Symbol">(</a><a id="3956" href="Iterative.Sets.html#3956" class="Bound">j</a> <a id="3958" class="Symbol">:</a> <a id="3960" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="3977" class="Symbol">(</a><a id="3978" class="InductiveConstructor">ssup</a> <a id="3983" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3985" href="Iterative.Sets.html#3846" class="Bound">γ</a><a id="3986" class="Symbol">))</a>
        <a id="3997" class="Symbol">→</a> <a id="3999" class="Symbol">(</a><a id="4000" class="InductiveConstructor">ssup</a> <a id="4005" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="4007" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="4009" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4011" href="Iterative.Sets.html#3912" class="Bound">i</a><a id="4012" class="Symbol">)</a> <a id="4014" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="4017" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4019" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="4021" class="Symbol">(</a><a id="4022" class="InductiveConstructor">ssup</a> <a id="4027" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="4029" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="4031" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4033" href="Iterative.Sets.html#3956" class="Bound">j</a><a id="4034" class="Symbol">)</a>
<a id="4036" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="4043" href="Iterative.Sets.html#4043" class="Bound">σ</a> <a id="4045" href="Iterative.Sets.html#4045" class="Bound">i</a> <a id="4047" href="Iterative.Sets.html#4047" class="Bound">j</a> <a id="4049" class="Symbol">=</a> <a id="4051" href="UF.Subsingletons.html#4965" class="Function">to-subtype-＝</a> <a id="4064" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="4083" class="Symbol">(</a><a id="4084" href="Iterative.Multisets.html#3575" class="Function">to-𝕄-＝</a> <a id="4091" href="Iterative.Sets.html#4043" class="Bound">σ</a><a id="4092" class="Symbol">)</a>

<a id="4095" class="Markup">\end{code}</a><a id="4105" class="Background">

We define membership of iterative sets in terms of that for multisets:

</a><a id="4179" class="Markup">\begin{code}</a>

<a id="_∈_"></a><a id="4193" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="4197" class="Symbol">:</a> <a id="4199" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4201" class="Symbol">→</a> <a id="4203" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4205" class="Symbol">→</a> <a id="4207" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="4210" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="4212" href="Iterative.Sets.html#4212" class="Bound">A</a> <a id="4214" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4216" href="Iterative.Sets.html#4216" class="Bound">B</a> <a id="4218" class="Symbol">=</a> <a id="4220" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4236" href="Iterative.Sets.html#4212" class="Bound">A</a> <a id="4238" href="Iterative.Multisets.html#2315" class="Function Operator">⁅</a> <a id="4240" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4256" href="Iterative.Sets.html#4216" class="Bound">B</a>

<a id="4259" class="Markup">\end{code}</a><a id="4269" class="Background">

As is the case for iterative multisets, there is a resized down,
equivalent definition of membership.

</a><a id="4374" class="Markup">\begin{code}</a>

<a id="_∈⁻_"></a><a id="4388" href="Iterative.Sets.html#4388" class="Function Operator">_∈⁻_</a> <a id="4393" class="Symbol">:</a> <a id="4395" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4397" class="Symbol">→</a> <a id="4399" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4401" class="Symbol">→</a> <a id="4403" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="4405" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="4407" href="Iterative.Sets.html#4407" class="Bound">A</a> <a id="4409" href="Iterative.Sets.html#4388" class="Function Operator">∈⁻</a> <a id="4412" href="Iterative.Sets.html#4412" class="Bound">B</a> <a id="4414" class="Symbol">=</a> <a id="4416" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4432" href="Iterative.Sets.html#4407" class="Bound">A</a> <a id="4434" href="Iterative.Multisets.html#7730" class="Function Operator">⁅⁻</a> <a id="4437" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4453" href="Iterative.Sets.html#4412" class="Bound">B</a>

<a id="∈⁻≃∈"></a><a id="4456" href="Iterative.Sets.html#4456" class="Function">∈⁻≃∈</a> <a id="4461" class="Symbol">:</a> <a id="4463" class="Symbol">(</a><a id="4464" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4466" href="Iterative.Sets.html#4466" class="Bound">B</a> <a id="4468" class="Symbol">:</a> <a id="4470" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4471" class="Symbol">)</a> <a id="4473" class="Symbol">→</a> <a id="4475" class="Symbol">(</a><a id="4476" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4478" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4480" href="Iterative.Sets.html#4466" class="Bound">B</a><a id="4481" class="Symbol">)</a> <a id="4483" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="4485" class="Symbol">(</a><a id="4486" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4488" href="Iterative.Sets.html#4388" class="Function Operator">∈⁻</a> <a id="4491" href="Iterative.Sets.html#4466" class="Bound">B</a><a id="4492" class="Symbol">)</a>
<a id="4494" href="Iterative.Sets.html#4456" class="Function">∈⁻≃∈</a> <a id="4499" href="Iterative.Sets.html#4499" class="Bound">A</a> <a id="4501" href="Iterative.Sets.html#4501" class="Bound">B</a> <a id="4503" class="Symbol">=</a> <a id="4505" href="Iterative.Multisets.html#7794" class="Function">⁅⁻≃⁅</a> <a id="4510" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="4513" class="Symbol">(</a><a id="4514" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4530" href="Iterative.Sets.html#4499" class="Bound">A</a><a id="4531" class="Symbol">)</a> <a id="4533" class="Symbol">(</a><a id="4534" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4550" href="Iterative.Sets.html#4501" class="Bound">B</a><a id="4551" class="Symbol">)</a>

<a id="4554" class="Markup">\end{code}</a><a id="4564" class="Background">

As discussed above, the membership relation becomes a proposition
precisely because we required forests to be embeddings to define the
subtype of iterative sets.

</a><a id="4729" class="Markup">\begin{code}</a>

<a id="∈-is-prop-valued"></a><a id="4743" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="4760" class="Symbol">:</a> <a id="4762" class="Symbol">(</a><a id="4763" href="Iterative.Sets.html#4763" class="Bound">A</a> <a id="4765" href="Iterative.Sets.html#4765" class="Bound">B</a> <a id="4767" class="Symbol">:</a> <a id="4769" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4770" class="Symbol">)</a> <a id="4772" class="Symbol">→</a> <a id="4774" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="4782" class="Symbol">(</a><a id="4783" href="Iterative.Sets.html#4763" class="Bound">A</a> <a id="4785" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4787" href="Iterative.Sets.html#4765" class="Bound">B</a><a id="4788" class="Symbol">)</a>
<a id="4790" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="4807" class="Symbol">(</a><a id="4808" href="Iterative.Sets.html#4808" class="Bound">M</a> <a id="4810" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4812" class="Symbol">_)</a> <a id="4815" class="Symbol">(</a><a id="4816" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="4821" href="Iterative.Sets.html#4821" class="Bound">X</a> <a id="4823" href="Iterative.Sets.html#4823" class="Bound">φ</a> <a id="4825" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4827" href="Iterative.Sets.html#4827" class="Bound">φ-emb</a> <a id="4833" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4835" class="Symbol">_)</a> <a id="4838" class="Symbol">=</a> <a id="4840" href="Iterative.Sets.html#4827" class="Bound">φ-emb</a> <a id="4846" href="Iterative.Sets.html#4808" class="Bound">M</a>

<a id="𝕍-forest-∈"></a><a id="4849" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="4860" class="Symbol">:</a> <a id="4862" class="Symbol">(</a><a id="4863" href="Iterative.Sets.html#4863" class="Bound">A</a> <a id="4865" class="Symbol">:</a> <a id="4867" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4868" class="Symbol">)</a> <a id="4870" class="Symbol">(</a><a id="4871" href="Iterative.Sets.html#4871" class="Bound">x</a> <a id="4873" class="Symbol">:</a> <a id="4875" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="4882" href="Iterative.Sets.html#4863" class="Bound">A</a><a id="4883" class="Symbol">)</a> <a id="4885" class="Symbol">→</a> <a id="4887" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="4896" href="Iterative.Sets.html#4863" class="Bound">A</a> <a id="4898" href="Iterative.Sets.html#4871" class="Bound">x</a> <a id="4900" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4902" href="Iterative.Sets.html#4863" class="Bound">A</a>
<a id="4904" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="4915" href="Iterative.Sets.html#4915" class="Bound">A</a> <a id="4917" href="Iterative.Sets.html#4917" class="Bound">x</a> <a id="4919" class="Symbol">=</a> <a id="4921" href="Iterative.Multisets.html#2923" class="Function">𝕄-forest-⁅</a> <a id="4932" class="Symbol">(</a><a id="4933" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4949" href="Iterative.Sets.html#4915" class="Bound">A</a><a id="4950" class="Symbol">)</a> <a id="4952" href="Iterative.Sets.html#4917" class="Bound">x</a>

<a id="4955" class="Markup">\end{code}</a><a id="4965" class="Background">

The subset relation is defined in the usual way and is
proposition-valued:

</a><a id="5043" class="Markup">\begin{code}</a>

<a id="_⊆_"></a><a id="5057" href="Iterative.Sets.html#5057" class="Function Operator">_⊆_</a> <a id="5061" class="Symbol">:</a> <a id="5063" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="5065" class="Symbol">→</a> <a id="5067" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="5069" class="Symbol">→</a> <a id="5071" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="5074" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="5076" href="Iterative.Sets.html#5076" class="Bound">A</a> <a id="5078" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5080" href="Iterative.Sets.html#5080" class="Bound">B</a> <a id="5082" class="Symbol">=</a> <a id="5084" class="Symbol">(</a><a id="5085" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5087" class="Symbol">:</a> <a id="5089" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">→</a> <a id="5094" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5096" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="5098" href="Iterative.Sets.html#5076" class="Bound">A</a> <a id="5100" class="Symbol">→</a> <a id="5102" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5104" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="5106" href="Iterative.Sets.html#5080" class="Bound">B</a>

<a id="⊆-is-prop-valued"></a><a id="5109" href="Iterative.Sets.html#5109" class="Function">⊆-is-prop-valued</a> <a id="5126" class="Symbol">:</a> <a id="5128" class="Symbol">(</a><a id="5129" href="Iterative.Sets.html#5129" class="Bound">A</a> <a id="5131" href="Iterative.Sets.html#5131" class="Bound">B</a> <a id="5133" class="Symbol">:</a> <a id="5135" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5136" class="Symbol">)</a> <a id="5138" class="Symbol">→</a> <a id="5140" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="5148" class="Symbol">(</a><a id="5149" href="Iterative.Sets.html#5129" class="Bound">A</a> <a id="5151" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5153" href="Iterative.Sets.html#5131" class="Bound">B</a><a id="5154" class="Symbol">)</a>
<a id="5156" href="Iterative.Sets.html#5109" class="Function">⊆-is-prop-valued</a> <a id="5173" href="Iterative.Sets.html#5173" class="Bound">A</a> <a id="5175" href="Iterative.Sets.html#5175" class="Bound">B</a> <a id="5177" class="Symbol">=</a> <a id="5179" href="UF.Subsingletons-FunExt.html#6281" class="Function">Π₂-is-prop</a> <a id="5190" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="5193" class="Symbol">(λ</a> <a id="5196" href="Iterative.Sets.html#5196" class="Bound">C</a> <a id="5198" href="Iterative.Sets.html#5198" class="Bound">_</a> <a id="5200" class="Symbol">→</a> <a id="5202" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="5219" href="Iterative.Sets.html#5196" class="Bound">C</a> <a id="5221" href="Iterative.Sets.html#5175" class="Bound">B</a><a id="5222" class="Symbol">)</a>

<a id="5225" class="Markup">\end{code}</a><a id="5235" class="Background">

It is in the following that the univalence axiom is used for the first
time, to establish the extensionality axiom for iterative sets:

</a><a id="5373" class="Markup">\begin{code}</a>

<a id="∈-is-extensional"></a><a id="5387" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="5404" class="Symbol">:</a> <a id="5406" class="Symbol">(</a><a id="5407" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5409" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5411" class="Symbol">:</a> <a id="5413" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5414" class="Symbol">)</a> <a id="5416" class="Symbol">→</a> <a id="5418" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5420" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5422" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5424" class="Symbol">→</a> <a id="5426" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5428" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5430" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5436" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5438" href="Iterative.Sets.html#5409" class="Bound">B</a>
<a id="5440" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="5457" href="Iterative.Sets.html#5457" class="Bound">A</a><a id="5458" class="Symbol">@(</a><a id="5460" href="Iterative.Sets.html#5460" class="Bound">M</a><a id="5461" class="Symbol">@(</a><a id="5463" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="5468" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5470" href="Iterative.Sets.html#5470" class="Bound">φ</a><a id="5471" class="Symbol">)</a> <a id="5473" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5475" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a> <a id="5481" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5483" href="Iterative.Sets.html#5483" class="Bound">g</a><a id="5484" class="Symbol">)</a>
                 <a id="5503" href="Iterative.Sets.html#5503" class="Bound">B</a><a id="5504" class="Symbol">@(</a><a id="5506" href="Iterative.Sets.html#5506" class="Bound">N</a><a id="5507" class="Symbol">@(</a><a id="5509" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="5514" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5516" href="Iterative.Sets.html#5516" class="Bound">γ</a><a id="5517" class="Symbol">)</a> <a id="5519" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5521" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a> <a id="5527" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5529" href="Iterative.Sets.html#5529" class="Bound">h</a><a id="5530" class="Symbol">)</a> <a id="5532" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5534" href="Iterative.Sets.html#5534" class="Bound">v</a> <a id="5536" class="Symbol">=</a> <a id="5538" href="Iterative.Sets.html#6410" class="Function">V</a>
 <a id="5541" class="Keyword">where</a>
  <a id="5549" href="Iterative.Sets.html#5549" class="Function">have-uv</a> <a id="5557" class="Symbol">:</a> <a id="5559" class="Symbol">(</a><a id="5560" href="Iterative.Sets.html#5457" class="Bound">A</a> <a id="5562" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5564" href="Iterative.Sets.html#5503" class="Bound">B</a><a id="5565" class="Symbol">)</a> <a id="5567" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="5569" class="Symbol">(</a><a id="5570" href="Iterative.Sets.html#5503" class="Bound">B</a> <a id="5572" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5574" href="Iterative.Sets.html#5457" class="Bound">A</a><a id="5575" class="Symbol">)</a>
  <a id="5579" href="Iterative.Sets.html#5549" class="Function">have-uv</a> <a id="5587" class="Symbol">=</a> <a id="5589" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5591" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5593" href="Iterative.Sets.html#5534" class="Bound">v</a>

  <a id="5598" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5600" class="Symbol">:</a> <a id="5602" class="Symbol">(</a><a id="5603" href="Iterative.Sets.html#5603" class="Bound">x</a> <a id="5605" class="Symbol">:</a> <a id="5607" href="Iterative.Sets.html#5468" class="Bound">X</a><a id="5608" class="Symbol">)</a> <a id="5610" class="Symbol">→</a> <a id="5612" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="5614" href="Iterative.Sets.html#5614" class="Bound">y</a> <a id="5616" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="5618" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5620" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="5622" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5624" href="Iterative.Sets.html#5614" class="Bound">y</a> <a id="5626" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5628" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5630" href="Iterative.Sets.html#5603" class="Bound">x</a>
  <a id="5634" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5636" href="Iterative.Sets.html#5636" class="Bound">x</a> <a id="5638" class="Symbol">=</a> <a id="5640" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5642" class="Symbol">(</a><a id="5643" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5645" href="Iterative.Sets.html#5636" class="Bound">x</a> <a id="5647" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5649" href="Iterative.Sets.html#5483" class="Bound">g</a> <a id="5651" href="Iterative.Sets.html#5636" class="Bound">x</a><a id="5652" class="Symbol">)</a> <a id="5654" class="Symbol">(</a><a id="5655" href="Iterative.Multisets.html#2923" class="Function">𝕄-forest-⁅</a> <a id="5666" href="Iterative.Sets.html#5460" class="Bound">M</a> <a id="5668" href="Iterative.Sets.html#5636" class="Bound">x</a><a id="5669" class="Symbol">)</a>

  <a id="5674" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5677" class="Symbol">:</a> <a id="5679" class="Symbol">(</a><a id="5680" href="Iterative.Sets.html#5680" class="Bound">y</a> <a id="5682" class="Symbol">:</a> <a id="5684" href="Iterative.Sets.html#5514" class="Bound">Y</a><a id="5685" class="Symbol">)</a> <a id="5687" class="Symbol">→</a> <a id="5689" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="5691" href="Iterative.Sets.html#5691" class="Bound">x</a> <a id="5693" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="5695" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5697" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="5699" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5701" href="Iterative.Sets.html#5691" class="Bound">x</a> <a id="5703" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5705" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5707" href="Iterative.Sets.html#5680" class="Bound">y</a>
  <a id="5711" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5714" href="Iterative.Sets.html#5714" class="Bound">y</a> <a id="5716" class="Symbol">=</a> <a id="5718" href="Iterative.Sets.html#5534" class="Bound">v</a> <a id="5720" class="Symbol">(</a><a id="5721" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5723" href="Iterative.Sets.html#5714" class="Bound">y</a> <a id="5725" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5727" href="Iterative.Sets.html#5529" class="Bound">h</a> <a id="5729" href="Iterative.Sets.html#5714" class="Bound">y</a><a id="5730" class="Symbol">)</a> <a id="5732" class="Symbol">(</a><a id="5733" href="Iterative.Multisets.html#2923" class="Function">𝕄-forest-⁅</a> <a id="5744" href="Iterative.Sets.html#5506" class="Bound">N</a> <a id="5746" href="Iterative.Sets.html#5714" class="Bound">y</a><a id="5747" class="Symbol">)</a>

  <a id="5752" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5754" class="Symbol">:</a> <a id="5756" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5758" class="Symbol">→</a> <a id="5760" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="5764" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5766" href="Iterative.Sets.html#5766" class="Bound">x</a> <a id="5768" class="Symbol">=</a> <a id="5770" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5774" class="Symbol">(</a><a id="5775" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5777" href="Iterative.Sets.html#5766" class="Bound">x</a><a id="5778" class="Symbol">)</a>

  <a id="5783" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5787" class="Symbol">:</a> <a id="5789" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5791" class="Symbol">→</a> <a id="5793" href="Iterative.Sets.html#5468" class="Bound">X</a>
  <a id="5797" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5801" href="Iterative.Sets.html#5801" class="Bound">y</a> <a id="5803" class="Symbol">=</a> <a id="5805" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5809" class="Symbol">(</a><a id="5810" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5813" href="Iterative.Sets.html#5801" class="Bound">y</a><a id="5814" class="Symbol">)</a>

  <a id="5819" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="5821" class="Symbol">:</a> <a id="5823" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5827" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5829" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5831" href="MLTT.Id.html#1425" class="Function Operator">∼</a> <a id="5833" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="5838" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="5840" href="Iterative.Sets.html#5840" class="Bound">x</a> <a id="5842" class="Symbol">=</a> <a id="5844" href="UF.Embeddings.html#5107" class="Function">embeddings-are-lc</a> <a id="5862" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5864" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a>
         <a id="5879" class="Symbol">(</a><a id="5880" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5882" class="Symbol">(</a><a id="5883" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5887" class="Symbol">(</a><a id="5888" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5890" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5891" class="Symbol">))</a> <a id="5894" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="5897" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="5901" class="Symbol">(</a><a id="5902" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5905" class="Symbol">(</a><a id="5906" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5908" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5909" class="Symbol">))</a> <a id="5912" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
          <a id="5924" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5926" class="Symbol">(</a><a id="5927" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5929" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5930" class="Symbol">)</a>       <a id="5938" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="5941" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="5945" class="Symbol">(</a><a id="5946" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5948" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5949" class="Symbol">)</a> <a id="5951" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
          <a id="5963" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5965" href="Iterative.Sets.html#5840" class="Bound">x</a>           <a id="5977" href="MLTT.Id.html#2321" class="Function Operator">∎</a><a id="5978" class="Symbol">)</a>

  <a id="5983" href="Iterative.Sets.html#5983" class="Function">ε</a> <a id="5985" class="Symbol">:</a> <a id="5987" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5989" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5991" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5995" href="MLTT.Id.html#1425" class="Function Operator">∼</a> <a id="5997" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="6002" href="Iterative.Sets.html#5983" class="Function">ε</a> <a id="6004" href="Iterative.Sets.html#6004" class="Bound">y</a> <a id="6006" class="Symbol">=</a> <a id="6008" href="UF.Embeddings.html#5107" class="Function">embeddings-are-lc</a> <a id="6026" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6028" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a>
         <a id="6043" class="Symbol">(</a><a id="6044" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6046" class="Symbol">(</a><a id="6047" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6049" class="Symbol">(</a><a id="6050" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6054" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6055" class="Symbol">))</a> <a id="6058" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="6061" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6065" class="Symbol">(</a><a id="6066" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="6068" class="Symbol">(</a><a id="6069" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6073" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6074" class="Symbol">))</a> <a id="6077" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
          <a id="6089" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="6091" class="Symbol">(</a><a id="6092" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6096" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6097" class="Symbol">)</a>     <a id="6103" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="6106" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6110" class="Symbol">(</a><a id="6111" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="6114" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6115" class="Symbol">)</a> <a id="6117" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
          <a id="6129" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6131" href="Iterative.Sets.html#6004" class="Bound">y</a>           <a id="6143" href="MLTT.Id.html#2321" class="Function Operator">∎</a><a id="6144" class="Symbol">)</a>

  <a id="6149" href="Iterative.Sets.html#6149" class="Function">𝕗</a> <a id="6151" class="Symbol">:</a> <a id="6153" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6155" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="6157" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="6161" href="Iterative.Sets.html#6149" class="Function">𝕗</a> <a id="6163" class="Symbol">=</a> <a id="6165" href="UF.Equiv.html#7224" class="Function">qinveq</a> <a id="6172" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6174" class="Symbol">(</a><a id="6175" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6179" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6181" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="6183" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6185" href="Iterative.Sets.html#5983" class="Function">ε</a><a id="6186" class="Symbol">)</a>

  <a id="6191" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6193" class="Symbol">:</a> <a id="6195" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6197" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6199" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="6203" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6205" class="Symbol">=</a> <a id="6207" href="UF.Univalence.html#905" class="Function">eqtoid</a> <a id="6214" class="Symbol">(</a><a id="6215" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="6218" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="6219" class="Symbol">)</a> <a id="6221" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6223" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="6225" href="Iterative.Sets.html#6149" class="Function">𝕗</a>

  <a id="6230" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6234" class="Symbol">:</a> <a id="6236" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="6244" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6246" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6248" href="Iterative.Sets.html#5752" class="Function">f</a>
  <a id="6252" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6256" class="Symbol">=</a> <a id="6258" href="UF.Univalence.html#1668" class="Function">Idtofun-eqtoid</a> <a id="6273" class="Symbol">(</a><a id="6274" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="6277" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="6278" class="Symbol">)</a> <a id="6280" href="Iterative.Sets.html#6149" class="Function">𝕗</a>

  <a id="6285" href="Iterative.Sets.html#6285" class="Function">IV</a> <a id="6288" class="Symbol">=</a> <a id="6290" class="Symbol">λ</a> <a id="6292" href="Iterative.Sets.html#6292" class="Bound">x</a> <a id="6294" class="Symbol">→</a>
   <a id="6299" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="6301" href="Iterative.Sets.html#6292" class="Bound">x</a>             <a id="6315" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="6318" class="Symbol">(</a><a id="6319" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6323" class="Symbol">(</a><a id="6324" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="6326" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6327" class="Symbol">))</a><a id="6329" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="6332" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="6337" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6339" class="Symbol">(</a><a id="6340" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6342" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6343" class="Symbol">)</a>         <a id="6353" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="6356" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6359" class="Symbol">(λ</a> <a id="6362" href="Iterative.Sets.html#6362" class="Bound">-</a> <a id="6364" class="Symbol">→</a> <a id="6366" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6368" class="Symbol">(</a><a id="6369" href="Iterative.Sets.html#6362" class="Bound">-</a> <a id="6371" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6372" class="Symbol">))</a> <a id="6375" class="Symbol">(</a><a id="6376" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6380" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6382" class="Symbol">)</a> <a id="6384" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="6389" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6391" class="Symbol">(</a><a id="6392" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="6400" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6402" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6403" class="Symbol">)</a> <a id="6405" href="MLTT.Id.html#2321" class="Function Operator">∎</a>

  <a id="6410" href="Iterative.Sets.html#6410" class="Function">V</a> <a id="6412" class="Symbol">:</a> <a id="6414" href="Iterative.Sets.html#5457" class="Bound">A</a> <a id="6416" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6418" href="Iterative.Sets.html#5503" class="Bound">B</a>
  <a id="6422" href="Iterative.Sets.html#6410" class="Function">V</a> <a id="6424" class="Symbol">=</a> <a id="6426" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="6433" class="Symbol">(</a><a id="6434" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6436" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6438" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="6446" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="6449" href="Iterative.Sets.html#6285" class="Function">IV</a><a id="6451" class="Symbol">)</a> <a id="6453" class="Symbol">(</a><a id="6454" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a> <a id="6460" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6462" href="Iterative.Sets.html#5483" class="Bound">g</a><a id="6463" class="Symbol">)</a> <a id="6465" class="Symbol">(</a><a id="6466" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a> <a id="6472" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6474" href="Iterative.Sets.html#5529" class="Bound">h</a><a id="6475" class="Symbol">)</a>

<a id="6478" class="Markup">\end{code}</a><a id="6488" class="Background">

It follows that 𝕍 is 0-type, or set, in the sense of the HoTT
book. But notice that we now have two notions of set in this
discussion: the &quot;material&quot; (iterative set) one and the &quot;structural&quot;
one (0-type or set). The reader should keep this distinction in mind
for the comments and code below.

The following uses the fact that any type with an extensional order is
automatically a set.

</a><a id="6877" class="Markup">\begin{code}</a>

<a id="𝕍-is-set"></a><a id="6891" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="6900" class="Symbol">:</a> <a id="6902" href="UF.Sets.html#709" class="Function">is-set</a> <a id="6909" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="6911" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="6920" class="Symbol">=</a> <a id="6922" href="Ordinals.Notions.html#7553" class="Function">extensionally-ordered-types-are-sets</a> <a id="6959" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="6963" href="Iterative.Sets.html#944" class="Function">fe&#39;</a>
            <a id="6979" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a>
            <a id="7008" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a>

<a id="7026" class="Markup">\end{code}</a><a id="7036" class="Background">

Here is a second, more direct, proof of this fact.

The following says that ssup φ ＝ M is a proposition for every M : 𝕄
if φ is an embedding.

The following doesn&#39;t seem to have been observed before in the
literature.

</a><a id="7257" class="Markup">\begin{code}</a>

<a id="𝕄-ssup-is-h-isolated"></a><a id="7271" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="7292" class="Symbol">:</a> <a id="7294" class="Symbol">(</a><a id="7295" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7297" class="Symbol">:</a> <a id="7299" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="7301" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="7303" class="Symbol">)</a> <a id="7305" class="Symbol">(</a><a id="7306" href="Iterative.Sets.html#7306" class="Bound">φ</a> <a id="7308" class="Symbol">:</a> <a id="7310" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7312" class="Symbol">→</a> <a id="7314" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="7315" class="Symbol">)</a>
                     <a id="7338" class="Symbol">→</a> <a id="7340" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="7353" href="Iterative.Sets.html#7306" class="Bound">φ</a>
                     <a id="7376" class="Symbol">→</a> <a id="7378" href="UF.Sets.html#402" class="Function">is-h-isolated</a> <a id="7392" class="Symbol">(</a><a id="7393" class="InductiveConstructor">ssup</a> <a id="7398" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7400" href="Iterative.Sets.html#7306" class="Bound">φ</a><a id="7401" class="Symbol">)</a>
<a id="7403" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="7424" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7426" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7428" href="Iterative.Sets.html#7428" class="Bound">φ-emb</a> <a id="7434" class="Symbol">{</a><a id="7435" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7436" class="Symbol">}</a> <a id="7438" class="Symbol">=</a> <a id="7440" href="Iterative.Sets.html#7771" class="Function">III</a>
 <a id="7445" class="Keyword">where</a>
  <a id="7453" href="Iterative.Sets.html#7453" class="Function">I</a> <a id="7455" class="Symbol">=</a> <a id="7457" class="Symbol">(</a><a id="7458" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7463" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7465" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7467" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7469" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7470" class="Symbol">)</a>                        <a id="7495" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="7498" href="UF.EquivalenceExamples.html#25192" class="Function">＝-flip</a> <a id="7505" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="7513" class="Symbol">(</a><a id="7514" href="Iterative.Sets.html#7435" class="Bound">M</a> <a id="7516" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7518" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7523" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7525" href="Iterative.Sets.html#7426" class="Bound">φ</a><a id="7526" class="Symbol">)</a>                        <a id="7551" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="7554" href="Iterative.Multisets.html#4446" class="Function">𝕄-＝&#39;</a> <a id="7559" href="Iterative.Sets.html#7435" class="Bound">M</a> <a id="7561" class="Symbol">(</a><a id="7562" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7567" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7569" href="Iterative.Sets.html#7426" class="Bound">φ</a><a id="7570" class="Symbol">)</a> <a id="7572" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="7580" href="Notation.General.html#398" class="Function">fiber</a> <a id="7586" class="Symbol">((</a><a id="7588" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7590" href="MLTT.Pi.html#513" class="Function Operator">∘_</a><a id="7592" class="Symbol">)</a> <a id="7594" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7596" href="UF.Base.html#2303" class="Function">Idtofun</a><a id="7603" class="Symbol">)</a> <a id="7605" class="Symbol">(</a><a id="7606" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="7615" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7616" class="Symbol">)</a>  <a id="7619" href="UF.Equiv.html#2815" class="Function Operator">■</a>

  <a id="7624" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7627" class="Symbol">:</a> <a id="7629" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="7642" class="Symbol">((</a><a id="7644" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7646" href="MLTT.Pi.html#513" class="Function Operator">∘_</a><a id="7648" class="Symbol">)</a> <a id="7650" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7652" href="UF.Base.html#2303" class="Function">Idtofun</a><a id="7659" class="Symbol">)</a>
  <a id="7663" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7666" class="Symbol">=</a> <a id="7668" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a>
        <a id="7691" class="Symbol">(</a><a id="7692" href="UF.Embeddings.html#19914" class="Function">Idtofun-is-embedding</a> <a id="7713" class="Symbol">(</a><a id="7714" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="7717" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="7718" class="Symbol">)</a> <a id="7720" href="Iterative.Sets.html#895" class="Function">fe</a><a id="7722" class="Symbol">)</a>
        <a id="7732" class="Symbol">(</a><a id="7733" href="UF.Embeddings.html#12977" class="Function">postcomp-is-embedding</a> <a id="7755" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="7759" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7761" href="Iterative.Sets.html#7428" class="Bound">φ-emb</a><a id="7766" class="Symbol">)</a>

  <a id="7771" href="Iterative.Sets.html#7771" class="Function">III</a> <a id="7775" class="Symbol">:</a> <a id="7777" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="7785" class="Symbol">(</a><a id="7786" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7791" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7793" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7795" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7797" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7798" class="Symbol">)</a>
  <a id="7802" href="Iterative.Sets.html#7771" class="Function">III</a> <a id="7806" class="Symbol">=</a> <a id="7808" href="UF.Equiv.html#8620" class="Function">equiv-to-prop</a> <a id="7822" href="Iterative.Sets.html#7453" class="Function">I</a> <a id="7824" class="Symbol">(</a><a id="7825" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7828" class="Symbol">(</a><a id="7829" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="7838" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7839" class="Symbol">))</a>

<a id="7843" class="Markup">\end{code}</a><a id="7853" class="Background">

And a particular case of this is that if M is an iterative set then
M ＝ N is a proposition for every *multiset* N.

</a><a id="7971" class="Markup">\begin{code}</a>

<a id="isets-are-h-isolated"></a><a id="7985" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8006" class="Symbol">:</a> <a id="8008" class="Symbol">(</a><a id="8009" href="Iterative.Sets.html#8009" class="Bound">M</a> <a id="8011" class="Symbol">:</a> <a id="8013" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="8014" class="Symbol">)</a>
                     <a id="8037" class="Symbol">→</a> <a id="8039" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="8056" href="Iterative.Sets.html#8009" class="Bound">M</a>
                     <a id="8079" class="Symbol">→</a> <a id="8081" href="UF.Sets.html#402" class="Function">is-h-isolated</a> <a id="8095" href="Iterative.Sets.html#8009" class="Bound">M</a>
<a id="8097" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8118" class="Symbol">(</a><a id="8119" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="8124" href="Iterative.Sets.html#8124" class="Bound">X</a> <a id="8126" href="Iterative.Sets.html#8126" class="Bound">φ</a><a id="8127" class="Symbol">)</a> <a id="8129" class="Symbol">(</a><a id="8130" href="Iterative.Sets.html#8130" class="Bound">φ-emb</a> <a id="8136" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8138" class="Symbol">_)</a> <a id="8141" class="Symbol">=</a> <a id="8143" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="8164" href="Iterative.Sets.html#8124" class="Bound">X</a> <a id="8166" href="Iterative.Sets.html#8126" class="Bound">φ</a> <a id="8168" href="Iterative.Sets.html#8130" class="Bound">φ-emb</a>

<a id="8175" class="Markup">\end{code}</a><a id="8185" class="Background">

Because a subtype of any type whatsoever consisting of h-isolated
elements is a 0-type, we get a second proof that the type of iterative
sets is a 0-type.

</a><a id="8343" class="Markup">\begin{code}</a>

<a id="𝕍-is-set&#39;"></a><a id="8357" href="Iterative.Sets.html#8357" class="Function">𝕍-is-set&#39;</a> <a id="8367" class="Symbol">:</a> <a id="8369" href="UF.Sets.html#709" class="Function">is-set</a> <a id="8376" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="8378" href="Iterative.Sets.html#8357" class="Function">𝕍-is-set&#39;</a> <a id="8388" class="Symbol">{</a><a id="8389" href="Iterative.Sets.html#8389" class="Bound">M</a> <a id="8391" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8393" href="Iterative.Sets.html#8393" class="Bound">M-is-is-set</a><a id="8404" class="Symbol">}</a> <a id="8406" class="Symbol">=</a>
 <a id="8409" href="UF.Equiv.html#8620" class="Function">equiv-to-prop</a>
  <a id="8425" class="Symbol">(</a><a id="8426" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="8432" class="Symbol">(</a><a id="8433" href="UF.Embeddings.html#8921" class="Function">to-subtype-＝-≃</a> <a id="8448" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a><a id="8466" class="Symbol">))</a>
  <a id="8471" class="Symbol">(</a><a id="8472" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8493" href="Iterative.Sets.html#8389" class="Bound">M</a> <a id="8495" href="Iterative.Sets.html#8393" class="Bound">M-is-is-set</a><a id="8506" class="Symbol">)</a>

<a id="8509" class="Markup">\end{code}</a><a id="8519" class="Background">

By definition, an iterative multiset is an iterative set if its
𝕄-forests are all embeddings. The 𝕍-forests are also embeddings:

</a><a id="8651" class="Markup">\begin{code}</a>

<a id="𝕍-forest-is-embedding"></a><a id="8665" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="8687" class="Symbol">:</a> <a id="8689" class="Symbol">(</a><a id="8690" href="Iterative.Sets.html#8690" class="Bound">A</a> <a id="8692" class="Symbol">:</a> <a id="8694" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="8695" class="Symbol">)</a> <a id="8697" class="Symbol">→</a> <a id="8699" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="8712" class="Symbol">(</a><a id="8713" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="8722" href="Iterative.Sets.html#8690" class="Bound">A</a><a id="8723" class="Symbol">)</a>
<a id="8725" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="8747" href="Iterative.Sets.html#8747" class="Bound">A</a><a id="8748" class="Symbol">@(</a><a id="8750" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="8755" href="Iterative.Sets.html#8755" class="Bound">X</a> <a id="8757" href="Iterative.Sets.html#8757" class="Bound">φ</a> <a id="8759" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8761" href="Iterative.Sets.html#8761" class="Bound">φ-emb</a> <a id="8767" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8769" href="Iterative.Sets.html#8769" class="Bound">φ-iter</a><a id="8775" class="Symbol">)</a> <a id="8777" class="Symbol">=</a>
 <a id="8780" href="UF.PairFun.html#5312" class="Function">pair-fun-is-embedding-special</a> <a id="8810" href="Iterative.Sets.html#8757" class="Bound">φ</a> <a id="8812" href="Iterative.Sets.html#8769" class="Bound">φ-iter</a> <a id="8819" href="Iterative.Sets.html#8761" class="Bound">φ-emb</a> <a id="8825" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>

<a id="8845" class="Markup">\end{code}</a><a id="8855" class="Background">

We construct elements of 𝕄 using the constructor ssup. We now
introduce a corresponding constructor 𝕍-ssup to construct elements of
the type 𝕍.

</a><a id="9002" class="Markup">\begin{code}</a>

<a id="𝕍-ssup"></a><a id="9016" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9023" class="Symbol">:</a> <a id="9025" class="Symbol">(</a><a id="9026" href="Iterative.Sets.html#9026" class="Bound">X</a> <a id="9028" class="Symbol">:</a> <a id="9030" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9032" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="9034" class="Symbol">)</a> <a id="9036" class="Symbol">(</a><a id="9037" href="Iterative.Sets.html#9037" class="Bound">ϕ</a> <a id="9039" class="Symbol">:</a> <a id="9041" href="Iterative.Sets.html#9026" class="Bound">X</a> <a id="9043" class="Symbol">→</a> <a id="9045" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9046" class="Symbol">)</a> <a id="9048" class="Symbol">→</a> <a id="9050" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9063" href="Iterative.Sets.html#9037" class="Bound">ϕ</a> <a id="9065" class="Symbol">→</a> <a id="9067" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="9069" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9076" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9078" href="Iterative.Sets.html#9078" class="Bound">ϕ</a> <a id="9080" href="Iterative.Sets.html#9080" class="Bound">ϕ-emb</a> <a id="9086" class="Symbol">=</a> <a id="9088" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="9093" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9095" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9097" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9099" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9105" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9107" href="Iterative.Sets.html#9162" class="Function">φ-iset</a>
 <a id="9115" class="Keyword">where</a>
  <a id="9123" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9125" class="Symbol">:</a> <a id="9127" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9129" class="Symbol">→</a> <a id="9131" href="Iterative.Multisets.html#690" class="Function">𝕄</a>
  <a id="9135" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9137" class="Symbol">=</a> <a id="9139" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="9155" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9157" href="Iterative.Sets.html#9078" class="Bound">ϕ</a>

  <a id="9162" href="Iterative.Sets.html#9162" class="Function">φ-iset</a> <a id="9169" class="Symbol">:</a> <a id="9171" class="Symbol">(</a><a id="9172" href="Iterative.Sets.html#9172" class="Bound">x</a> <a id="9174" class="Symbol">:</a> <a id="9176" href="Iterative.Sets.html#9076" class="Bound">X</a><a id="9177" class="Symbol">)</a> <a id="9179" class="Symbol">→</a> <a id="9181" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="9198" class="Symbol">(</a><a id="9199" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9201" href="Iterative.Sets.html#9172" class="Bound">x</a><a id="9202" class="Symbol">)</a>
  <a id="9206" href="Iterative.Sets.html#9162" class="Function">φ-iset</a> <a id="9213" class="Symbol">=</a> <a id="9215" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="9235" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9237" href="Iterative.Sets.html#9078" class="Bound">ϕ</a>

  <a id="9242" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9248" class="Symbol">:</a> <a id="9250" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9263" href="Iterative.Sets.html#9123" class="Function">φ</a>
  <a id="9267" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9273" class="Symbol">=</a> <a id="9275" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a> <a id="9290" href="Iterative.Sets.html#9080" class="Bound">ϕ-emb</a> <a id="9296" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a>

<a id="9326" class="Markup">\end{code}</a><a id="9336" class="Background">

It behaves as expected with respect to the corresponding destructors:

</a><a id="9409" class="Markup">\begin{code}</a>

<a id="𝕍-ssup-root"></a><a id="9423" href="Iterative.Sets.html#9423" class="Function">𝕍-ssup-root</a> <a id="9435" class="Symbol">:</a> <a id="9437" class="Symbol">(</a><a id="9438" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9440" class="Symbol">:</a> <a id="9442" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9444" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="9446" class="Symbol">)</a> <a id="9448" class="Symbol">(</a><a id="9449" href="Iterative.Sets.html#9449" class="Bound">ϕ</a> <a id="9451" class="Symbol">:</a> <a id="9453" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9455" class="Symbol">→</a> <a id="9457" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9458" class="Symbol">)</a> <a id="9460" class="Symbol">(</a><a id="9461" href="Iterative.Sets.html#9461" class="Bound">e</a> <a id="9463" class="Symbol">:</a> <a id="9465" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9478" href="Iterative.Sets.html#9449" class="Bound">ϕ</a><a id="9479" class="Symbol">)</a>
            <a id="9493" class="Symbol">→</a> <a id="9495" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="9502" class="Symbol">(</a><a id="9503" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9510" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9512" href="Iterative.Sets.html#9449" class="Bound">ϕ</a> <a id="9514" href="Iterative.Sets.html#9461" class="Bound">e</a><a id="9515" class="Symbol">)</a> <a id="9517" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="9519" href="Iterative.Sets.html#9438" class="Bound">X</a>
<a id="9521" href="Iterative.Sets.html#9423" class="Function">𝕍-ssup-root</a> <a id="9533" href="Iterative.Sets.html#9533" class="Bound">X</a> <a id="9535" href="Iterative.Sets.html#9535" class="Bound">ϕ</a> <a id="9537" href="Iterative.Sets.html#9537" class="Bound">e</a> <a id="9539" class="Symbol">=</a> <a id="9541" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-ssup-forest"></a><a id="9547" href="Iterative.Sets.html#9547" class="Function">𝕍-ssup-forest</a> <a id="9561" class="Symbol">:</a> <a id="9563" class="Symbol">(</a><a id="9564" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9566" class="Symbol">:</a> <a id="9568" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9570" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="9572" class="Symbol">)</a> <a id="9574" class="Symbol">(</a><a id="9575" href="Iterative.Sets.html#9575" class="Bound">ϕ</a> <a id="9577" class="Symbol">:</a> <a id="9579" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9581" class="Symbol">→</a> <a id="9583" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9584" class="Symbol">)</a> <a id="9586" class="Symbol">(</a><a id="9587" href="Iterative.Sets.html#9587" class="Bound">e</a> <a id="9589" class="Symbol">:</a> <a id="9591" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9604" href="Iterative.Sets.html#9575" class="Bound">ϕ</a><a id="9605" class="Symbol">)</a>
              <a id="9621" class="Symbol">→</a> <a id="9623" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9632" class="Symbol">(</a><a id="9633" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9640" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9642" href="Iterative.Sets.html#9575" class="Bound">ϕ</a> <a id="9644" href="Iterative.Sets.html#9587" class="Bound">e</a><a id="9645" class="Symbol">)</a> <a id="9647" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="9649" href="Iterative.Sets.html#9575" class="Bound">ϕ</a>
<a id="9651" href="Iterative.Sets.html#9547" class="Function">𝕍-ssup-forest</a> <a id="9665" href="Iterative.Sets.html#9665" class="Bound">X</a> <a id="9667" href="Iterative.Sets.html#9667" class="Bound">ϕ</a> <a id="9669" href="Iterative.Sets.html#9669" class="Bound">e</a> <a id="9671" class="Symbol">=</a> <a id="9673" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="9679" class="Markup">\end{code}</a><a id="9689" class="Background">

Notice that the identifications are definitional.

We have the following η rules for 𝕍, where the first is more general
and the second is more natural. In both cases the identifications are
not definitional.

</a><a id="9900" class="Markup">\begin{code}</a>

<a id="𝕍-η&#39;"></a><a id="9914" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="9919" class="Symbol">:</a> <a id="9921" class="Symbol">(</a><a id="9922" href="Iterative.Sets.html#9922" class="Bound">A</a> <a id="9924" class="Symbol">:</a> <a id="9926" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9927" class="Symbol">)</a> <a id="9929" class="Symbol">(</a><a id="9930" href="Iterative.Sets.html#9930" class="Bound">e</a> <a id="9932" class="Symbol">:</a> <a id="9934" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9947" class="Symbol">(</a><a id="9948" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9957" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9958" class="Symbol">))</a>
     <a id="9966" class="Symbol">→</a> <a id="9968" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9975" class="Symbol">(</a><a id="9976" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="9983" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9984" class="Symbol">)</a> <a id="9986" class="Symbol">(</a><a id="9987" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9996" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9997" class="Symbol">)</a> <a id="9999" href="Iterative.Sets.html#9930" class="Bound">e</a> <a id="10001" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10003" href="Iterative.Sets.html#9922" class="Bound">A</a>
<a id="10005" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="10010" class="Symbol">(</a><a id="10011" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="10016" class="Symbol">_</a> <a id="10018" class="Symbol">_</a> <a id="10020" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10022" class="Symbol">_)</a> <a id="10025" class="Symbol">_</a> <a id="10027" class="Symbol">=</a> <a id="10029" href="UF.Subsingletons.html#4965" class="Function">to-subtype-＝</a> <a id="10042" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="10061" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-η"></a><a id="10067" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10071" class="Symbol">:</a> <a id="10073" class="Symbol">(</a><a id="10074" href="Iterative.Sets.html#10074" class="Bound">A</a> <a id="10076" class="Symbol">:</a> <a id="10078" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10079" class="Symbol">)</a> <a id="10081" class="Symbol">→</a> <a id="10083" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10090" class="Symbol">(</a><a id="10091" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10098" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10099" class="Symbol">)</a> <a id="10101" class="Symbol">(</a><a id="10102" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10111" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10112" class="Symbol">)</a> <a id="10114" class="Symbol">(</a><a id="10115" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="10137" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10138" class="Symbol">)</a> <a id="10140" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10142" href="Iterative.Sets.html#10074" class="Bound">A</a>
<a id="10144" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10148" href="Iterative.Sets.html#10148" class="Bound">A</a> <a id="10150" class="Symbol">=</a> <a id="10152" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="10157" href="Iterative.Sets.html#10148" class="Bound">A</a> <a id="10159" class="Symbol">(</a><a id="10160" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="10182" href="Iterative.Sets.html#10148" class="Bound">A</a><a id="10183" class="Symbol">)</a>

<a id="10186" class="Markup">\end{code}</a><a id="10196" class="Background">

Here are two characterizations of the membership relation:

</a><a id="10258" class="Markup">\begin{code}</a>

<a id="∈-behaviour"></a><a id="10272" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="10284" class="Symbol">:</a> <a id="10286" class="Symbol">(</a><a id="10287" href="Iterative.Sets.html#10287" class="Bound">A</a> <a id="10289" class="Symbol">:</a> <a id="10291" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10292" class="Symbol">)</a> <a id="10294" class="Symbol">(</a><a id="10295" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10297" class="Symbol">:</a> <a id="10299" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="10301" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="10303" class="Symbol">)</a> <a id="10305" class="Symbol">(</a><a id="10306" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10308" class="Symbol">:</a> <a id="10310" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10312" class="Symbol">→</a> <a id="10314" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10315" class="Symbol">)</a> <a id="10317" class="Symbol">(</a><a id="10318" href="Iterative.Sets.html#10318" class="Bound">e</a> <a id="10320" class="Symbol">:</a> <a id="10322" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="10335" href="Iterative.Sets.html#10306" class="Bound">ϕ</a><a id="10336" class="Symbol">)</a>
            <a id="10350" class="Symbol">→</a> <a id="10352" href="Iterative.Sets.html#10287" class="Bound">A</a> <a id="10354" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10356" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10363" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10365" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10367" href="Iterative.Sets.html#10318" class="Bound">e</a> <a id="10369" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10371" class="Symbol">(</a><a id="10372" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10374" href="Iterative.Sets.html#10374" class="Bound">x</a> <a id="10376" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10378" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10380" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10382" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10384" href="Iterative.Sets.html#10374" class="Bound">x</a> <a id="10386" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10388" href="Iterative.Sets.html#10287" class="Bound">A</a><a id="10389" class="Symbol">)</a>
<a id="10391" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="10403" href="Iterative.Sets.html#10403" class="Bound">A</a> <a id="10405" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10407" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10409" href="Iterative.Sets.html#10409" class="Bound">e</a> <a id="10411" class="Symbol">=</a>
 <a id="10414" class="Symbol">(</a><a id="10415" href="Iterative.Sets.html#10403" class="Bound">A</a> <a id="10417" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10419" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10426" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10428" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10430" href="Iterative.Sets.html#10409" class="Bound">e</a><a id="10431" class="Symbol">)</a>                                     <a id="10469" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="10472" href="UF.Equiv.html#1517" class="Function">≃-refl</a> <a id="10479" class="Symbol">_</a> <a id="10481" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
 <a id="10484" class="Symbol">(</a><a id="10485" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10487" href="Iterative.Sets.html#10487" class="Bound">x</a> <a id="10489" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10491" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10493" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10495" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10511" class="Symbol">(</a><a id="10512" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10514" href="Iterative.Sets.html#10487" class="Bound">x</a><a id="10515" class="Symbol">)</a> <a id="10517" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10519" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10535" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10536" class="Symbol">)</a> <a id="10538" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="10541" href="UF.EquivalenceExamples.html#3378" class="Function">Σ-cong</a> <a id="10548" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10550" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
 <a id="10553" class="Symbol">(</a><a id="10554" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10556" href="Iterative.Sets.html#10556" class="Bound">x</a> <a id="10558" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10560" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10562" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10564" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10566" href="Iterative.Sets.html#10556" class="Bound">x</a> <a id="10568" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10570" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10571" class="Symbol">)</a>                                   <a id="10607" href="UF.Equiv.html#2815" class="Function Operator">■</a>
  <a id="10611" class="Keyword">where</a>
   <a id="10620" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10622" class="Symbol">:</a> <a id="10624" class="Symbol">(</a><a id="10625" href="Iterative.Sets.html#10625" class="Bound">x</a> <a id="10627" class="Symbol">:</a> <a id="10629" href="Iterative.Sets.html#10405" class="Bound">X</a><a id="10630" class="Symbol">)</a> <a id="10632" class="Symbol">→</a> <a id="10634" class="Symbol">(</a><a id="10635" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10651" class="Symbol">(</a><a id="10652" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10654" href="Iterative.Sets.html#10625" class="Bound">x</a><a id="10655" class="Symbol">)</a> <a id="10657" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10659" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10675" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10676" class="Symbol">)</a> <a id="10678" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10680" class="Symbol">(</a><a id="10681" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10683" href="Iterative.Sets.html#10625" class="Bound">x</a> <a id="10685" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10687" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10688" class="Symbol">)</a>
   <a id="10693" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10695" href="Iterative.Sets.html#10695" class="Bound">x</a> <a id="10697" class="Symbol">=</a> <a id="10699" href="UF.Embeddings.html#7365" class="Function">embedding-criterion-converse</a>
          <a id="10738" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a>
          <a id="10764" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a>
          <a id="10803" class="Symbol">(</a><a id="10804" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10806" href="Iterative.Sets.html#10695" class="Bound">x</a><a id="10807" class="Symbol">)</a>
          <a id="10819" href="Iterative.Sets.html#10403" class="Bound">A</a>

<a id="∈-behaviour&#39;"></a><a id="10822" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="10835" class="Symbol">:</a> <a id="10837" class="Symbol">(</a><a id="10838" href="Iterative.Sets.html#10838" class="Bound">A</a> <a id="10840" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10842" class="Symbol">:</a> <a id="10844" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10845" class="Symbol">)</a> <a id="10847" class="Symbol">→</a> <a id="10849" href="Iterative.Sets.html#10838" class="Bound">A</a> <a id="10851" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10853" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10855" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10857" class="Symbol">(</a><a id="10858" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10860" href="Iterative.Sets.html#10860" class="Bound">x</a> <a id="10862" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10864" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10871" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10873" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10875" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10884" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10886" href="Iterative.Sets.html#10860" class="Bound">x</a> <a id="10888" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10890" href="Iterative.Sets.html#10838" class="Bound">A</a><a id="10891" class="Symbol">)</a>
<a id="10893" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="10906" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="10908" href="Iterative.Sets.html#10908" class="Bound">B</a> <a id="10910" class="Symbol">=</a>
 <a id="10913" href="MLTT.Id.html#735" class="Function">transport</a>
  <a id="10925" class="Symbol">(λ</a> <a id="10928" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10930" class="Symbol">→</a> <a id="10932" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="10934" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10936" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10938" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10940" class="Symbol">(</a><a id="10941" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10943" href="Iterative.Sets.html#10943" class="Bound">x</a> <a id="10945" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10947" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10954" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10956" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10958" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10967" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10969" href="Iterative.Sets.html#10943" class="Bound">x</a> <a id="10971" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10973" href="Iterative.Sets.html#10906" class="Bound">A</a><a id="10974" class="Symbol">))</a>
  <a id="10979" class="Symbol">(</a><a id="10980" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10984" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="10985" class="Symbol">)</a>
  <a id="10989" class="Symbol">(</a><a id="10990" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="11002" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="11004" class="Symbol">(</a><a id="11005" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="11012" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11013" class="Symbol">)</a> <a id="11015" class="Symbol">(</a><a id="11016" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11025" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11026" class="Symbol">)</a> <a id="11028" class="Symbol">(</a><a id="11029" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="11051" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11052" class="Symbol">))</a>

<a id="11056" class="Keyword">private</a>
 <a id="∈-remark"></a><a id="11065" href="Iterative.Sets.html#11065" class="Function">∈-remark</a> <a id="11074" class="Symbol">:</a> <a id="11076" class="Symbol">(</a><a id="11077" href="Iterative.Sets.html#11077" class="Bound">A</a> <a id="11079" href="Iterative.Sets.html#11079" class="Bound">B</a> <a id="11081" class="Symbol">:</a> <a id="11083" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="11084" class="Symbol">)</a> <a id="11086" class="Symbol">→</a> <a id="11088" href="Iterative.Sets.html#11077" class="Bound">A</a> <a id="11090" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="11092" href="Iterative.Sets.html#11079" class="Bound">B</a> <a id="11094" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="11096" href="Notation.General.html#398" class="Function">fiber</a> <a id="11102" class="Symbol">(</a><a id="11103" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11112" href="Iterative.Sets.html#11079" class="Bound">B</a><a id="11113" class="Symbol">)</a> <a id="11115" href="Iterative.Sets.html#11077" class="Bound">A</a>
 <a id="11118" href="Iterative.Sets.html#11065" class="Function">∈-remark</a> <a id="11127" class="Symbol">=</a> <a id="11129" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a>

<a id="11143" class="Markup">\end{code}</a><a id="11153" class="Background">

It also follows from the facts that 𝕍 is a set and that 𝕍-forest is an
embedding that the root of any iterative set is a 0-type:

</a><a id="11285" class="Markup">\begin{code}</a>

<a id="𝕍-root-is-set"></a><a id="11299" href="Iterative.Sets.html#11299" class="Function">𝕍-root-is-set</a> <a id="11313" class="Symbol">:</a> <a id="11315" class="Symbol">(</a><a id="11316" href="Iterative.Sets.html#11316" class="Bound">A</a> <a id="11318" class="Symbol">:</a> <a id="11320" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="11321" class="Symbol">)</a> <a id="11323" class="Symbol">→</a> <a id="11325" href="UF.Sets.html#709" class="Function">is-set</a> <a id="11332" class="Symbol">(</a><a id="11333" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="11340" href="Iterative.Sets.html#11316" class="Bound">A</a><a id="11341" class="Symbol">)</a>
<a id="11343" href="Iterative.Sets.html#11299" class="Function">𝕍-root-is-set</a> <a id="11357" href="Iterative.Sets.html#11357" class="Bound">A</a> <a id="11359" class="Symbol">=</a> <a id="11361" href="UF.Embeddings.html#5596" class="Function">subtypes-of-sets-are-sets</a>
                   <a id="11406" class="Symbol">(</a><a id="11407" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11416" href="Iterative.Sets.html#11357" class="Bound">A</a><a id="11417" class="Symbol">)</a>
                   <a id="11438" class="Symbol">(</a><a id="11439" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="11461" href="Iterative.Sets.html#11357" class="Bound">A</a><a id="11462" class="Symbol">)</a>
                   <a id="11483" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a>
<a id="11492" class="Markup">\end{code}</a><a id="11502" class="Background">

It would be nice if we could define 𝕍 inductively as follows:

 data 𝕍 : 𝓤⁺ ̇ where
  𝕍-ssup : (X : 𝓤 ̇ ) (φ : X → 𝕍) → is-embedding φ → 𝕍

However, this is not a strictly positive definition, for the criterion
of strict positivity adopted by Agda, and so it is not accepted.

Nevertheless, all iterative sets *are* generated by the &quot;constructor&quot;
𝕍-ssup, in the following sense, so that we can view 𝕍 as really
inductively defined by the above data declaration.

The following result, implementing the above idea, seems to be new.

</a><a id="12036" class="Markup">\begin{code}</a>

<a id="𝕍-Induction&#39;"></a><a id="12050" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a>
 <a id="12064" class="Symbol">:</a> <a id="12066" class="Symbol">(</a><a id="12067" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12069" class="Symbol">:</a> <a id="12071" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="12073" class="Symbol">→</a> <a id="12075" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="12077" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="12079" class="Symbol">)</a>
   <a id="12084" class="Symbol">(</a><a id="12085" href="Iterative.Sets.html#12085" class="Bound">f</a> <a id="12087" class="Symbol">:</a> <a id="12089" class="Symbol">(</a><a id="12090" href="Iterative.Sets.html#12090" class="Bound">A</a> <a id="12092" class="Symbol">:</a> <a id="12094" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12095" class="Symbol">)</a> <a id="12097" class="Symbol">→</a> <a id="12099" class="Symbol">((</a><a id="12101" href="Iterative.Sets.html#12101" class="Bound">x</a> <a id="12103" class="Symbol">:</a> <a id="12105" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="12112" href="Iterative.Sets.html#12090" class="Bound">A</a><a id="12113" class="Symbol">)</a> <a id="12115" class="Symbol">→</a> <a id="12117" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12119" class="Symbol">(</a><a id="12120" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12129" href="Iterative.Sets.html#12090" class="Bound">A</a> <a id="12131" href="Iterative.Sets.html#12101" class="Bound">x</a><a id="12132" class="Symbol">))</a> <a id="12135" class="Symbol">→</a> <a id="12137" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12139" href="Iterative.Sets.html#12090" class="Bound">A</a><a id="12140" class="Symbol">)</a>
 <a id="12143" class="Symbol">→</a> <a id="12145" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="12147" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12149" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="12151" class="Symbol">((</a><a id="12153" href="Iterative.Sets.html#12153" class="Bound">A</a> <a id="12155" class="Symbol">:</a> <a id="12157" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12158" class="Symbol">)</a> <a id="12160" class="Symbol">→</a> <a id="12162" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12164" href="Iterative.Sets.html#12153" class="Bound">A</a><a id="12165" class="Symbol">)</a>
       <a id="12174" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="12176" class="Symbol">((</a><a id="12178" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12180" class="Symbol">:</a> <a id="12182" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12183" class="Symbol">)</a> <a id="12185" class="Symbol">→</a> <a id="12187" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12189" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12191" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12193" href="Iterative.Sets.html#12085" class="Bound">f</a> <a id="12195" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12197" class="Symbol">(λ</a> <a id="12200" href="Iterative.Sets.html#12200" class="Bound">x</a> <a id="12202" class="Symbol">→</a> <a id="12204" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12206" class="Symbol">(</a><a id="12207" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12216" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12218" href="Iterative.Sets.html#12200" class="Bound">x</a><a id="12219" class="Symbol">)))</a>
<a id="12223" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="12236" href="Iterative.Sets.html#12236" class="Bound">P</a> <a id="12238" href="Iterative.Sets.html#12238" class="Bound">f</a> <a id="12240" class="Symbol">=</a> <a id="12242" class="Symbol">(λ</a> <a id="12245" class="Symbol">(</a><a id="12246" href="Iterative.Sets.html#12246" class="Bound">M</a> <a id="12248" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12250" href="Iterative.Sets.html#12250" class="Bound">i</a><a id="12251" class="Symbol">)</a> <a id="12253" class="Symbol">→</a> <a id="12255" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12257" href="Iterative.Sets.html#12246" class="Bound">M</a> <a id="12259" href="Iterative.Sets.html#12250" class="Bound">i</a><a id="12260" class="Symbol">)</a> <a id="12262" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12264" href="Iterative.Sets.html#12398" class="Function">p</a>
 <a id="12267" class="Keyword">where</a>
  <a id="12275" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12277" class="Symbol">:</a> <a id="12279" class="Symbol">(</a><a id="12280" href="Iterative.Sets.html#12280" class="Bound">M</a> <a id="12282" class="Symbol">:</a> <a id="12284" href="Iterative.Multisets.html#690" class="Function">𝕄</a><a id="12285" class="Symbol">)</a> <a id="12287" class="Symbol">(</a><a id="12288" href="Iterative.Sets.html#12288" class="Bound">i</a> <a id="12290" class="Symbol">:</a> <a id="12292" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="12309" href="Iterative.Sets.html#12280" class="Bound">M</a><a id="12310" class="Symbol">)</a> <a id="12312" class="Symbol">→</a> <a id="12314" href="Iterative.Sets.html#12236" class="Bound">P</a> <a id="12316" class="Symbol">(</a><a id="12317" href="Iterative.Sets.html#12280" class="Bound">M</a> <a id="12319" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12321" href="Iterative.Sets.html#12288" class="Bound">i</a><a id="12322" class="Symbol">)</a>
  <a id="12326" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12328" href="Iterative.Sets.html#12328" class="Bound">M</a><a id="12329" class="Symbol">@(</a><a id="12331" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12336" href="Iterative.Sets.html#12336" class="Bound">X</a> <a id="12338" href="Iterative.Sets.html#12338" class="Bound">φ</a><a id="12339" class="Symbol">)</a> <a id="12341" href="Iterative.Sets.html#12341" class="Bound">i</a><a id="12342" class="Symbol">@(_</a> <a id="12346" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12348" href="Iterative.Sets.html#12348" class="Bound">φ-iter</a><a id="12354" class="Symbol">)</a> <a id="12356" class="Symbol">=</a> <a id="12358" href="Iterative.Sets.html#12238" class="Bound">f</a> <a id="12360" class="Symbol">(</a><a id="12361" href="Iterative.Sets.html#12328" class="Bound">M</a> <a id="12363" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12365" href="Iterative.Sets.html#12341" class="Bound">i</a><a id="12366" class="Symbol">)</a> <a id="12368" class="Symbol">(λ</a> <a id="12371" href="Iterative.Sets.html#12371" class="Bound">x</a> <a id="12373" class="Symbol">→</a> <a id="12375" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12377" class="Symbol">(</a><a id="12378" href="Iterative.Sets.html#12338" class="Bound">φ</a> <a id="12380" href="Iterative.Sets.html#12371" class="Bound">x</a><a id="12381" class="Symbol">)</a> <a id="12383" class="Symbol">(</a><a id="12384" href="Iterative.Sets.html#12348" class="Bound">φ-iter</a> <a id="12391" href="Iterative.Sets.html#12371" class="Bound">x</a><a id="12392" class="Symbol">))</a>

  <a id="12398" href="Iterative.Sets.html#12398" class="Function">p</a> <a id="12400" class="Symbol">:</a> <a id="12402" class="Symbol">(</a><a id="12403" href="Iterative.Sets.html#12403" class="Bound">A</a> <a id="12405" class="Symbol">:</a> <a id="12407" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12408" class="Symbol">)</a> <a id="12410" class="Symbol">→</a> <a id="12412" class="Symbol">_</a> <a id="12414" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12416" class="Symbol">_</a>
  <a id="12420" href="Iterative.Sets.html#12398" class="Function">p</a> <a id="12422" class="Symbol">(</a><a id="12423" href="Iterative.Sets.html#12423" class="Bound">M</a><a id="12424" class="Symbol">@(</a><a id="12426" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12431" href="Iterative.Sets.html#12431" class="Bound">X</a> <a id="12433" href="Iterative.Sets.html#12433" class="Bound">φ</a><a id="12434" class="Symbol">)</a> <a id="12436" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12438" href="Iterative.Sets.html#12438" class="Bound">i</a><a id="12439" class="Symbol">@(_</a> <a id="12443" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12445" href="Iterative.Sets.html#12445" class="Bound">φ-iter</a><a id="12451" class="Symbol">))</a> <a id="12454" class="Symbol">=</a> <a id="12456" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-Induction"></a><a id="12462" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a>
 <a id="12475" class="Symbol">:</a> <a id="12477" class="Symbol">(</a><a id="12478" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12480" class="Symbol">:</a> <a id="12482" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="12484" class="Symbol">→</a> <a id="12486" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="12488" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="12490" class="Symbol">)</a>
 <a id="12493" class="Symbol">→</a> <a id="12495" class="Symbol">(</a><a id="12496" href="Iterative.Sets.html#12496" class="Bound">f</a> <a id="12498" class="Symbol">:</a> <a id="12500" class="Symbol">(</a><a id="12501" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12503" class="Symbol">:</a> <a id="12505" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="12507" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="12509" class="Symbol">)</a> <a id="12511" class="Symbol">(</a><a id="12512" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12514" class="Symbol">:</a> <a id="12516" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12518" class="Symbol">→</a> <a id="12520" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12521" class="Symbol">)</a> <a id="12523" class="Symbol">(</a><a id="12524" href="Iterative.Sets.html#12524" class="Bound">e</a> <a id="12526" class="Symbol">:</a> <a id="12528" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="12541" href="Iterative.Sets.html#12512" class="Bound">ϕ</a><a id="12542" class="Symbol">)</a>
      <a id="12550" class="Symbol">→</a> <a id="12552" class="Symbol">((</a><a id="12554" href="Iterative.Sets.html#12554" class="Bound">x</a> <a id="12556" class="Symbol">:</a> <a id="12558" href="Iterative.Sets.html#12501" class="Bound">X</a><a id="12559" class="Symbol">)</a> <a id="12561" class="Symbol">→</a> <a id="12563" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12565" class="Symbol">(</a><a id="12566" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12568" href="Iterative.Sets.html#12554" class="Bound">x</a><a id="12569" class="Symbol">))</a>
      <a id="12578" class="Symbol">→</a> <a id="12580" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12582" class="Symbol">(</a><a id="12583" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12590" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12592" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12594" href="Iterative.Sets.html#12524" class="Bound">e</a><a id="12595" class="Symbol">))</a>
 <a id="12599" class="Symbol">→</a> <a id="12601" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="12603" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12605" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="12607" class="Symbol">((</a><a id="12609" href="Iterative.Sets.html#12609" class="Bound">A</a> <a id="12611" class="Symbol">:</a> <a id="12613" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12614" class="Symbol">)</a> <a id="12616" class="Symbol">→</a> <a id="12618" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12620" href="Iterative.Sets.html#12609" class="Bound">A</a><a id="12621" class="Symbol">)</a>
       <a id="12630" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="12632" class="Symbol">((</a><a id="12634" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12636" class="Symbol">:</a> <a id="12638" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="12640" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="12642" class="Symbol">)</a> <a id="12644" class="Symbol">(</a><a id="12645" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12647" class="Symbol">:</a> <a id="12649" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12651" class="Symbol">→</a> <a id="12653" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12654" class="Symbol">)</a> <a id="12656" class="Symbol">(</a><a id="12657" href="Iterative.Sets.html#12657" class="Bound">e</a> <a id="12659" class="Symbol">:</a> <a id="12661" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="12674" href="Iterative.Sets.html#12645" class="Bound">ϕ</a><a id="12675" class="Symbol">)</a>
       <a id="12684" class="Symbol">→</a> <a id="12686" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12688" class="Symbol">(</a><a id="12689" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12696" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12698" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12700" href="Iterative.Sets.html#12657" class="Bound">e</a><a id="12701" class="Symbol">)</a> <a id="12703" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12705" href="Iterative.Sets.html#12496" class="Bound">f</a> <a id="12707" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12709" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12711" href="Iterative.Sets.html#12657" class="Bound">e</a> <a id="12713" class="Symbol">(λ</a> <a id="12716" href="Iterative.Sets.html#12716" class="Bound">x</a> <a id="12718" class="Symbol">→</a> <a id="12720" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12722" class="Symbol">(</a><a id="12723" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12725" href="Iterative.Sets.html#12716" class="Bound">x</a><a id="12726" class="Symbol">)))</a>
<a id="12730" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="12742" class="Symbol">{</a><a id="12743" href="Iterative.Sets.html#12743" class="Bound">𝓥</a><a id="12744" class="Symbol">}</a> <a id="12746" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12748" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="12750" class="Symbol">=</a> <a id="12752" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="12754" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12756" href="Iterative.Sets.html#13183" class="Function">IV</a>
 <a id="12760" class="Keyword">where</a>
  <a id="12768" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="12771" class="Symbol">:</a> <a id="12773" class="Symbol">(</a><a id="12774" href="Iterative.Sets.html#12774" class="Bound">A</a> <a id="12776" class="Symbol">:</a> <a id="12778" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12779" class="Symbol">)</a> <a id="12781" class="Symbol">→</a> <a id="12783" class="Symbol">((</a><a id="12785" href="Iterative.Sets.html#12785" class="Bound">x</a> <a id="12787" class="Symbol">:</a> <a id="12789" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="12796" href="Iterative.Sets.html#12774" class="Bound">A</a><a id="12797" class="Symbol">)</a> <a id="12799" class="Symbol">→</a> <a id="12801" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12803" class="Symbol">(</a><a id="12804" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12813" href="Iterative.Sets.html#12774" class="Bound">A</a> <a id="12815" href="Iterative.Sets.html#12785" class="Bound">x</a><a id="12816" class="Symbol">))</a> <a id="12819" class="Symbol">→</a> <a id="12821" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12823" href="Iterative.Sets.html#12774" class="Bound">A</a>
  <a id="12827" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="12830" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12831" class="Symbol">@(</a><a id="12833" href="Iterative.Sets.html#12833" class="Bound">M</a><a id="12834" class="Symbol">@(</a><a id="12836" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12841" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12843" href="Iterative.Sets.html#12843" class="Bound">φ</a><a id="12844" class="Symbol">)</a> <a id="12846" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12848" href="Iterative.Sets.html#12848" class="Bound">i</a><a id="12849" class="Symbol">@(</a><a id="12851" href="Iterative.Sets.html#12851" class="Bound">φ-emb</a> <a id="12857" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12859" href="Iterative.Sets.html#12859" class="Bound">φ-iter</a><a id="12865" class="Symbol">))</a> <a id="12868" href="Iterative.Sets.html#12868" class="Bound">g</a> <a id="12870" class="Symbol">=</a> <a id="12872" href="Iterative.Sets.html#13002" class="Function">II</a>
   <a id="12878" class="Keyword">where</a>
    <a id="12888" href="Iterative.Sets.html#12888" class="Function">I</a> <a id="12890" class="Symbol">:</a> <a id="12892" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12894" class="Symbol">(</a><a id="12895" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12902" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12904" class="Symbol">(</a><a id="12905" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12914" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12915" class="Symbol">)</a> <a id="12917" class="Symbol">(</a><a id="12918" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="12940" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12941" class="Symbol">))</a>
    <a id="12948" href="Iterative.Sets.html#12888" class="Function">I</a> <a id="12950" class="Symbol">=</a> <a id="12952" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="12954" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12956" class="Symbol">(</a><a id="12957" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12966" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12967" class="Symbol">)</a> <a id="12969" class="Symbol">(</a><a id="12970" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="12992" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12993" class="Symbol">)</a> <a id="12995" href="Iterative.Sets.html#12868" class="Bound">g</a>

    <a id="13002" href="Iterative.Sets.html#13002" class="Function">II</a> <a id="13005" class="Symbol">:</a> <a id="13007" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13009" href="Iterative.Sets.html#12830" class="Bound">A</a>
    <a id="13015" href="Iterative.Sets.html#13002" class="Function">II</a> <a id="13018" class="Symbol">=</a> <a id="13020" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13030" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13032" class="Symbol">(</a><a id="13033" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13037" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="13038" class="Symbol">)</a> <a id="13040" href="Iterative.Sets.html#12888" class="Function">I</a>

  <a id="13045" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13047" class="Symbol">:</a> <a id="13049" class="Symbol">(</a><a id="13050" href="Iterative.Sets.html#13050" class="Bound">A</a> <a id="13052" class="Symbol">:</a> <a id="13054" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13055" class="Symbol">)</a> <a id="13057" class="Symbol">→</a> <a id="13059" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13061" href="Iterative.Sets.html#13050" class="Bound">A</a>
  <a id="13065" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13067" class="Symbol">=</a> <a id="13069" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13073" class="Symbol">(</a><a id="13074" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="13087" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13089" href="Iterative.Sets.html#12768" class="Function">f&#39;</a><a id="13091" class="Symbol">)</a>

  <a id="13096" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13100" class="Symbol">:</a> <a id="13102" class="Symbol">(</a><a id="13103" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13105" class="Symbol">:</a> <a id="13107" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13108" class="Symbol">)</a> <a id="13110" class="Symbol">→</a> <a id="13112" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13114" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13116" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13118" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="13121" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13123" class="Symbol">(λ</a> <a id="13126" href="Iterative.Sets.html#13126" class="Bound">x</a> <a id="13128" class="Symbol">→</a> <a id="13130" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13132" class="Symbol">(</a><a id="13133" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="13142" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13144" href="Iterative.Sets.html#13126" class="Bound">x</a><a id="13145" class="Symbol">))</a>
  <a id="13150" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13154" class="Symbol">=</a> <a id="13156" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="13160" class="Symbol">(</a><a id="13161" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="13174" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13176" href="Iterative.Sets.html#12768" class="Function">f&#39;</a><a id="13178" class="Symbol">)</a>

  <a id="13183" href="Iterative.Sets.html#13183" class="Function">IV</a> <a id="13186" class="Symbol">:</a> <a id="13188" class="Symbol">(</a><a id="13189" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13191" class="Symbol">:</a> <a id="13193" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="13195" href="MLTT.Universes.html#3976" class="Function Operator">̇</a><a id="13196" class="Symbol">)</a> <a id="13198" class="Symbol">(</a><a id="13199" href="Iterative.Sets.html#13199" class="Bound">ϕ</a> <a id="13201" class="Symbol">:</a> <a id="13203" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13205" class="Symbol">→</a> <a id="13207" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13208" class="Symbol">)</a> <a id="13210" class="Symbol">(</a><a id="13211" href="Iterative.Sets.html#13211" class="Bound">e</a> <a id="13213" class="Symbol">:</a> <a id="13215" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="13228" href="Iterative.Sets.html#13199" class="Bound">ϕ</a><a id="13229" class="Symbol">)</a>
     <a id="13236" class="Symbol">→</a> <a id="13238" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13240" class="Symbol">(</a><a id="13241" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13248" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13250" href="Iterative.Sets.html#13199" class="Bound">ϕ</a> <a id="13252" href="Iterative.Sets.html#13211" class="Bound">e</a><a id="13253" class="Symbol">)</a> <a id="13255" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13257" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13259" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13261" href="Iterative.Sets.html#13199" class="Bound">ϕ</a> <a id="13263" href="Iterative.Sets.html#13211" class="Bound">e</a> <a id="13265" class="Symbol">(λ</a> <a id="13268" href="Iterative.Sets.html#13268" class="Bound">x</a> <a id="13270" class="Symbol">→</a> <a id="13272" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13274" class="Symbol">(</a><a id="13275" href="Iterative.Sets.html#13199" class="Bound">ϕ</a> <a id="13277" href="Iterative.Sets.html#13268" class="Bound">x</a><a id="13278" class="Symbol">))</a>
  <a id="13283" href="Iterative.Sets.html#13183" class="Function">IV</a> <a id="13286" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13288" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13290" href="Iterative.Sets.html#13290" class="Bound">e</a> <a id="13292" class="Symbol">=</a>
   <a id="13297" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13299" href="Iterative.Sets.html#13789" class="Function">A</a>                                                               <a id="13363" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="13366" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13370" href="Iterative.Sets.html#13789" class="Function">A</a> <a id="13372" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="13377" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="13380" href="Iterative.Sets.html#13789" class="Function">A</a> <a id="13382" class="Symbol">(λ</a> <a id="13385" href="Iterative.Sets.html#13385" class="Bound">x</a> <a id="13387" class="Symbol">→</a> <a id="13389" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13391" class="Symbol">(</a><a id="13392" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13394" href="Iterative.Sets.html#13385" class="Bound">x</a><a id="13395" class="Symbol">))</a>                                              <a id="13443" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="13446" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="13451" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="13456" href="Iterative.Sets.html#13770" class="Function">t</a> <a id="13458" href="Iterative.Sets.html#12746" class="Bound">P</a>                <a id="13475" class="Symbol">(</a><a id="13476" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13480" href="Iterative.Sets.html#13789" class="Function">A</a><a id="13481" class="Symbol">)</a>             <a id="13495" class="Symbol">(</a><a id="13496" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13498" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13500" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13502" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13505" class="Symbol">(λ</a> <a id="13508" href="Iterative.Sets.html#13508" class="Bound">x</a> <a id="13510" class="Symbol">→</a> <a id="13512" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13514" class="Symbol">(</a><a id="13515" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13517" href="Iterative.Sets.html#13508" class="Bound">x</a><a id="13518" class="Symbol">)))</a> <a id="13522" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="13525" href="Iterative.Sets.html#13965" class="Function">i</a> <a id="13527" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="13532" href="Iterative.Sets.html#13770" class="Function">t</a> <a id="13534" href="Iterative.Sets.html#12746" class="Bound">P</a>                <a id="13551" class="Symbol">(</a><a id="13552" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13555" class="Symbol">(</a><a id="13556" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13563" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13565" href="Iterative.Sets.html#13288" class="Bound">ϕ</a><a id="13566" class="Symbol">)</a> <a id="13568" href="Iterative.Sets.html#13847" class="Function">p</a><a id="13569" class="Symbol">)</a> <a id="13571" class="Symbol">(</a><a id="13572" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13574" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13576" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13578" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13581" class="Symbol">(λ</a> <a id="13584" href="Iterative.Sets.html#13584" class="Bound">x</a> <a id="13586" class="Symbol">→</a> <a id="13588" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13590" class="Symbol">(</a><a id="13591" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13593" href="Iterative.Sets.html#13584" class="Bound">x</a><a id="13594" class="Symbol">)))</a> <a id="13598" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="13601" href="Iterative.Sets.html#14022" class="Function">ii</a> <a id="13604" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="13609" href="Iterative.Sets.html#13770" class="Function">t</a> <a id="13611" class="Symbol">(</a><a id="13612" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13614" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="13616" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13623" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13625" href="Iterative.Sets.html#13288" class="Bound">ϕ</a><a id="13626" class="Symbol">)</a> <a id="13628" href="Iterative.Sets.html#13847" class="Function">p</a>                   <a id="13648" class="Symbol">(</a><a id="13649" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13651" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13653" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13655" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13658" class="Symbol">(λ</a> <a id="13661" href="Iterative.Sets.html#13661" class="Bound">x</a> <a id="13663" class="Symbol">→</a> <a id="13665" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13667" class="Symbol">(</a><a id="13668" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13670" href="Iterative.Sets.html#13661" class="Bound">x</a><a id="13671" class="Symbol">)))</a> <a id="13675" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="13678" href="Iterative.Sets.html#14067" class="Function">iii</a> <a id="13682" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
   <a id="13687" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13689" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13691" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13693" href="Iterative.Sets.html#13290" class="Bound">e</a> <a id="13695" class="Symbol">(λ</a> <a id="13698" href="Iterative.Sets.html#13698" class="Bound">x</a> <a id="13700" class="Symbol">→</a> <a id="13702" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13704" class="Symbol">(</a><a id="13705" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13707" href="Iterative.Sets.html#13698" class="Bound">x</a><a id="13708" class="Symbol">))</a>                                           <a id="13753" href="MLTT.Id.html#2321" class="Function Operator">∎</a>
    <a id="13759" class="Keyword">where</a>
     <a id="13770" href="Iterative.Sets.html#13770" class="Function">t</a> <a id="13772" class="Symbol">=</a> <a id="13774" href="MLTT.Id.html#735" class="Function">transport</a>
     <a id="13789" href="Iterative.Sets.html#13789" class="Function">A</a>  <a id="13792" class="Symbol">=</a> <a id="13794" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13801" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13803" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13805" href="Iterative.Sets.html#13290" class="Bound">e</a>
     <a id="13812" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13815" class="Symbol">=</a> <a id="13817" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="13839" href="Iterative.Sets.html#13789" class="Function">A</a>

     <a id="13847" href="Iterative.Sets.html#13847" class="Function">p</a> <a id="13849" class="Symbol">:</a> <a id="13851" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13854" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13856" href="Iterative.Sets.html#13290" class="Bound">e</a>
     <a id="13863" href="Iterative.Sets.html#13847" class="Function">p</a> <a id="13865" class="Symbol">=</a> <a id="13867" href="UF.Embeddings.html#691" class="Function">being-embedding-is-prop</a> <a id="13891" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="13894" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13896" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13899" href="Iterative.Sets.html#13290" class="Bound">e</a>

     <a id="13907" href="Iterative.Sets.html#13907" class="Function">q</a> <a id="13909" class="Symbol">:</a> <a id="13911" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13915" href="Iterative.Sets.html#13789" class="Function">A</a> <a id="13917" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13919" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13922" class="Symbol">(</a><a id="13923" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13930" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13932" href="Iterative.Sets.html#13288" class="Bound">ϕ</a><a id="13933" class="Symbol">)</a> <a id="13935" href="Iterative.Sets.html#13847" class="Function">p</a>
     <a id="13942" href="Iterative.Sets.html#13907" class="Function">q</a> <a id="13944" class="Symbol">=</a> <a id="13946" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="13955" class="Symbol">_</a> <a id="13957" class="Symbol">_</a>

     <a id="13965" href="Iterative.Sets.html#13965" class="Function">i</a>   <a id="13969" class="Symbol">=</a> <a id="13971" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13974" class="Symbol">(λ</a> <a id="13977" href="Iterative.Sets.html#13977" class="Bound">-</a> <a id="13979" class="Symbol">→</a> <a id="13981" href="Iterative.Sets.html#13770" class="Function">t</a> <a id="13983" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13985" href="Iterative.Sets.html#13977" class="Bound">-</a> <a id="13987" class="Symbol">(</a><a id="13988" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13990" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="13992" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="13994" href="Iterative.Sets.html#13812" class="Function">e&#39;</a> <a id="13997" class="Symbol">(λ</a> <a id="14000" href="Iterative.Sets.html#14000" class="Bound">x</a> <a id="14002" class="Symbol">→</a> <a id="14004" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="14006" class="Symbol">(</a><a id="14007" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="14009" href="Iterative.Sets.html#14000" class="Bound">x</a><a id="14010" class="Symbol">))))</a> <a id="14015" href="Iterative.Sets.html#13907" class="Function">q</a>
     <a id="14022" href="Iterative.Sets.html#14022" class="Function">ii</a>  <a id="14026" class="Symbol">=</a> <a id="14028" class="Symbol">(</a><a id="14029" href="UF.Base.html#4752" class="Function">transport-ap</a> <a id="14042" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="14044" class="Symbol">(</a><a id="14045" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14052" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="14054" href="Iterative.Sets.html#13288" class="Bound">ϕ</a><a id="14055" class="Symbol">)</a> <a id="14057" href="Iterative.Sets.html#13847" class="Function">p</a><a id="14058" class="Symbol">)</a><a id="14059" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
     <a id="14067" href="Iterative.Sets.html#14067" class="Function">iii</a> <a id="14071" class="Symbol">=</a> <a id="14073" href="UF.Base.html#6958" class="Function">apd</a> <a id="14077" class="Symbol">(λ</a> <a id="14080" href="Iterative.Sets.html#14080" class="Bound">-</a> <a id="14082" class="Symbol">→</a> <a id="14084" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="14086" href="Iterative.Sets.html#13286" class="Bound">X</a> <a id="14088" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="14090" href="Iterative.Sets.html#14080" class="Bound">-</a> <a id="14092" class="Symbol">(λ</a> <a id="14095" href="Iterative.Sets.html#14095" class="Bound">x</a> <a id="14097" class="Symbol">→</a> <a id="14099" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="14101" class="Symbol">(</a><a id="14102" href="Iterative.Sets.html#13288" class="Bound">ϕ</a> <a id="14104" href="Iterative.Sets.html#14095" class="Bound">x</a><a id="14105" class="Symbol">)))</a> <a id="14109" href="Iterative.Sets.html#13847" class="Function">p</a>

<a id="𝕍-induction"></a><a id="14112" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="14124" class="Symbol">:</a> <a id="14126" class="Symbol">(</a><a id="14127" href="Iterative.Sets.html#14127" class="Bound">P</a> <a id="14129" class="Symbol">:</a> <a id="14131" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14133" class="Symbol">→</a> <a id="14135" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="14137" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14139" class="Symbol">)</a>
            <a id="14153" class="Symbol">→</a> <a id="14155" class="Symbol">((</a><a id="14157" href="Iterative.Sets.html#14157" class="Bound">X</a> <a id="14159" class="Symbol">:</a> <a id="14161" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14163" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14165" class="Symbol">)</a> <a id="14167" class="Symbol">(</a><a id="14168" href="Iterative.Sets.html#14168" class="Bound">ϕ</a> <a id="14170" class="Symbol">:</a> <a id="14172" href="Iterative.Sets.html#14157" class="Bound">X</a> <a id="14174" class="Symbol">→</a> <a id="14176" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14177" class="Symbol">)</a> <a id="14179" class="Symbol">(</a><a id="14180" href="Iterative.Sets.html#14180" class="Bound">e</a> <a id="14182" class="Symbol">:</a> <a id="14184" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14197" href="Iterative.Sets.html#14168" class="Bound">ϕ</a><a id="14198" class="Symbol">)</a>
                  <a id="14218" class="Symbol">→</a> <a id="14220" class="Symbol">((</a><a id="14222" href="Iterative.Sets.html#14222" class="Bound">x</a> <a id="14224" class="Symbol">:</a> <a id="14226" href="Iterative.Sets.html#14157" class="Bound">X</a><a id="14227" class="Symbol">)</a> <a id="14229" class="Symbol">→</a> <a id="14231" href="Iterative.Sets.html#14127" class="Bound">P</a> <a id="14233" class="Symbol">(</a><a id="14234" href="Iterative.Sets.html#14168" class="Bound">ϕ</a> <a id="14236" href="Iterative.Sets.html#14222" class="Bound">x</a><a id="14237" class="Symbol">))</a>
                  <a id="14258" class="Symbol">→</a> <a id="14260" href="Iterative.Sets.html#14127" class="Bound">P</a> <a id="14262" class="Symbol">(</a><a id="14263" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14270" href="Iterative.Sets.html#14157" class="Bound">X</a> <a id="14272" href="Iterative.Sets.html#14168" class="Bound">ϕ</a> <a id="14274" href="Iterative.Sets.html#14180" class="Bound">e</a><a id="14275" class="Symbol">))</a>
            <a id="14290" class="Symbol">→</a> <a id="14292" class="Symbol">(</a><a id="14293" href="Iterative.Sets.html#14293" class="Bound">A</a> <a id="14295" class="Symbol">:</a> <a id="14297" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14298" class="Symbol">)</a> <a id="14300" class="Symbol">→</a> <a id="14302" href="Iterative.Sets.html#14127" class="Bound">P</a> <a id="14304" href="Iterative.Sets.html#14293" class="Bound">A</a>
<a id="14306" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="14318" href="Iterative.Sets.html#14318" class="Bound">P</a> <a id="14320" href="Iterative.Sets.html#14320" class="Bound">f</a> <a id="14322" class="Symbol">=</a> <a id="14324" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="14328" class="Symbol">(</a><a id="14329" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="14341" href="Iterative.Sets.html#14318" class="Bound">P</a> <a id="14343" href="Iterative.Sets.html#14320" class="Bound">f</a><a id="14344" class="Symbol">)</a>

<a id="𝕍-induction-behaviour"></a><a id="14347" href="Iterative.Sets.html#14347" class="Function">𝕍-induction-behaviour</a>
 <a id="14370" class="Symbol">:</a> <a id="14372" class="Symbol">(</a><a id="14373" href="Iterative.Sets.html#14373" class="Bound">P</a> <a id="14375" class="Symbol">:</a> <a id="14377" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14379" class="Symbol">→</a> <a id="14381" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="14383" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14385" class="Symbol">)</a>
 <a id="14388" class="Symbol">→</a> <a id="14390" class="Symbol">(</a><a id="14391" href="Iterative.Sets.html#14391" class="Bound">f</a> <a id="14393" class="Symbol">:</a> <a id="14395" class="Symbol">(</a><a id="14396" href="Iterative.Sets.html#14396" class="Bound">X</a> <a id="14398" class="Symbol">:</a> <a id="14400" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14402" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14404" class="Symbol">)</a> <a id="14406" class="Symbol">(</a><a id="14407" href="Iterative.Sets.html#14407" class="Bound">ϕ</a> <a id="14409" class="Symbol">:</a> <a id="14411" href="Iterative.Sets.html#14396" class="Bound">X</a> <a id="14413" class="Symbol">→</a> <a id="14415" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14416" class="Symbol">)</a> <a id="14418" class="Symbol">(</a><a id="14419" href="Iterative.Sets.html#14419" class="Bound">e</a> <a id="14421" class="Symbol">:</a> <a id="14423" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14436" href="Iterative.Sets.html#14407" class="Bound">ϕ</a><a id="14437" class="Symbol">)</a>
      <a id="14445" class="Symbol">→</a> <a id="14447" class="Symbol">((</a><a id="14449" href="Iterative.Sets.html#14449" class="Bound">x</a> <a id="14451" class="Symbol">:</a> <a id="14453" href="Iterative.Sets.html#14396" class="Bound">X</a><a id="14454" class="Symbol">)</a> <a id="14456" class="Symbol">→</a> <a id="14458" href="Iterative.Sets.html#14373" class="Bound">P</a> <a id="14460" class="Symbol">(</a><a id="14461" href="Iterative.Sets.html#14407" class="Bound">ϕ</a> <a id="14463" href="Iterative.Sets.html#14449" class="Bound">x</a><a id="14464" class="Symbol">))</a>
      <a id="14473" class="Symbol">→</a> <a id="14475" href="Iterative.Sets.html#14373" class="Bound">P</a> <a id="14477" class="Symbol">(</a><a id="14478" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14485" href="Iterative.Sets.html#14396" class="Bound">X</a> <a id="14487" href="Iterative.Sets.html#14407" class="Bound">ϕ</a> <a id="14489" href="Iterative.Sets.html#14419" class="Bound">e</a><a id="14490" class="Symbol">))</a>
 <a id="14494" class="Symbol">→</a> <a id="14496" class="Symbol">(</a><a id="14497" href="Iterative.Sets.html#14497" class="Bound">X</a> <a id="14499" class="Symbol">:</a> <a id="14501" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14503" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14505" class="Symbol">)</a> <a id="14507" class="Symbol">(</a><a id="14508" href="Iterative.Sets.html#14508" class="Bound">ϕ</a> <a id="14510" class="Symbol">:</a> <a id="14512" href="Iterative.Sets.html#14497" class="Bound">X</a> <a id="14514" class="Symbol">→</a> <a id="14516" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14517" class="Symbol">)</a> <a id="14519" class="Symbol">(</a><a id="14520" href="Iterative.Sets.html#14520" class="Bound">e</a> <a id="14522" class="Symbol">:</a> <a id="14524" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14537" href="Iterative.Sets.html#14508" class="Bound">ϕ</a><a id="14538" class="Symbol">)</a>
 <a id="14541" class="Symbol">→</a> <a id="14543" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="14555" href="Iterative.Sets.html#14373" class="Bound">P</a> <a id="14557" href="Iterative.Sets.html#14391" class="Bound">f</a> <a id="14559" class="Symbol">(</a><a id="14560" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14567" href="Iterative.Sets.html#14497" class="Bound">X</a> <a id="14569" href="Iterative.Sets.html#14508" class="Bound">ϕ</a> <a id="14571" href="Iterative.Sets.html#14520" class="Bound">e</a><a id="14572" class="Symbol">)</a> <a id="14574" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14576" href="Iterative.Sets.html#14391" class="Bound">f</a> <a id="14578" href="Iterative.Sets.html#14497" class="Bound">X</a> <a id="14580" href="Iterative.Sets.html#14508" class="Bound">ϕ</a> <a id="14582" href="Iterative.Sets.html#14520" class="Bound">e</a> <a id="14584" class="Symbol">(λ</a> <a id="14587" href="Iterative.Sets.html#14587" class="Bound">x</a> <a id="14589" class="Symbol">→</a> <a id="14591" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="14603" href="Iterative.Sets.html#14373" class="Bound">P</a> <a id="14605" href="Iterative.Sets.html#14391" class="Bound">f</a> <a id="14607" class="Symbol">(</a><a id="14608" href="Iterative.Sets.html#14508" class="Bound">ϕ</a> <a id="14610" href="Iterative.Sets.html#14587" class="Bound">x</a><a id="14611" class="Symbol">))</a>
<a id="14614" href="Iterative.Sets.html#14347" class="Function">𝕍-induction-behaviour</a> <a id="14636" href="Iterative.Sets.html#14636" class="Bound">P</a> <a id="14638" href="Iterative.Sets.html#14638" class="Bound">f</a> <a id="14640" class="Symbol">=</a> <a id="14642" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="14646" class="Symbol">(</a><a id="14647" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="14659" href="Iterative.Sets.html#14636" class="Bound">P</a> <a id="14661" href="Iterative.Sets.html#14638" class="Bound">f</a><a id="14662" class="Symbol">)</a>

<a id="𝕍-recursion"></a><a id="14665" href="Iterative.Sets.html#14665" class="Function">𝕍-recursion</a> <a id="14677" class="Symbol">:</a> <a id="14679" class="Symbol">(</a><a id="14680" href="Iterative.Sets.html#14680" class="Bound">P</a> <a id="14682" class="Symbol">:</a> <a id="14684" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="14686" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14688" class="Symbol">)</a>
            <a id="14702" class="Symbol">→</a> <a id="14704" class="Symbol">((</a><a id="14706" href="Iterative.Sets.html#14706" class="Bound">X</a> <a id="14708" class="Symbol">:</a> <a id="14710" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14712" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14714" class="Symbol">)</a> <a id="14716" class="Symbol">(</a><a id="14717" href="Iterative.Sets.html#14717" class="Bound">ϕ</a> <a id="14719" class="Symbol">:</a> <a id="14721" href="Iterative.Sets.html#14706" class="Bound">X</a> <a id="14723" class="Symbol">→</a> <a id="14725" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14726" class="Symbol">)</a>
                  <a id="14746" class="Symbol">→</a> <a id="14748" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14761" href="Iterative.Sets.html#14717" class="Bound">ϕ</a>
                  <a id="14781" class="Symbol">→</a> <a id="14783" class="Symbol">(</a><a id="14784" href="Iterative.Sets.html#14706" class="Bound">X</a> <a id="14786" class="Symbol">→</a> <a id="14788" href="Iterative.Sets.html#14680" class="Bound">P</a><a id="14789" class="Symbol">)</a>
                  <a id="14809" class="Symbol">→</a> <a id="14811" href="Iterative.Sets.html#14680" class="Bound">P</a><a id="14812" class="Symbol">)</a>
            <a id="14826" class="Symbol">→</a> <a id="14828" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14830" class="Symbol">→</a> <a id="14832" href="Iterative.Sets.html#14680" class="Bound">P</a>
<a id="14834" href="Iterative.Sets.html#14665" class="Function">𝕍-recursion</a> <a id="14846" href="Iterative.Sets.html#14846" class="Bound">P</a> <a id="14848" class="Symbol">=</a> <a id="14850" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="14862" class="Symbol">(λ</a> <a id="14865" href="Iterative.Sets.html#14865" class="Bound">_</a> <a id="14867" class="Symbol">→</a> <a id="14869" href="Iterative.Sets.html#14846" class="Bound">P</a><a id="14870" class="Symbol">)</a>

<a id="𝕍-recursion-behaviour"></a><a id="14873" href="Iterative.Sets.html#14873" class="Function">𝕍-recursion-behaviour</a>
 <a id="14896" class="Symbol">:</a> <a id="14898" class="Symbol">(</a><a id="14899" href="Iterative.Sets.html#14899" class="Bound">P</a> <a id="14901" class="Symbol">:</a> <a id="14903" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="14905" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14907" class="Symbol">)</a>
 <a id="14910" class="Symbol">→</a> <a id="14912" class="Symbol">(</a><a id="14913" href="Iterative.Sets.html#14913" class="Bound">f</a> <a id="14915" class="Symbol">:</a> <a id="14917" class="Symbol">(</a><a id="14918" href="Iterative.Sets.html#14918" class="Bound">X</a> <a id="14920" class="Symbol">:</a> <a id="14922" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14924" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="14926" class="Symbol">)</a> <a id="14928" class="Symbol">(</a><a id="14929" href="Iterative.Sets.html#14929" class="Bound">ϕ</a> <a id="14931" class="Symbol">:</a> <a id="14933" href="Iterative.Sets.html#14918" class="Bound">X</a> <a id="14935" class="Symbol">→</a> <a id="14937" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14938" class="Symbol">)</a> <a id="14940" class="Symbol">(</a><a id="14941" href="Iterative.Sets.html#14941" class="Bound">e</a> <a id="14943" class="Symbol">:</a> <a id="14945" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14958" href="Iterative.Sets.html#14929" class="Bound">ϕ</a><a id="14959" class="Symbol">)</a>
      <a id="14967" class="Symbol">→</a> <a id="14969" class="Symbol">(</a><a id="14970" href="Iterative.Sets.html#14918" class="Bound">X</a> <a id="14972" class="Symbol">→</a> <a id="14974" href="Iterative.Sets.html#14899" class="Bound">P</a><a id="14975" class="Symbol">)</a>
      <a id="14983" class="Symbol">→</a> <a id="14985" href="Iterative.Sets.html#14899" class="Bound">P</a><a id="14986" class="Symbol">)</a>
 <a id="14989" class="Symbol">→</a> <a id="14991" class="Symbol">(</a><a id="14992" href="Iterative.Sets.html#14992" class="Bound">X</a> <a id="14994" class="Symbol">:</a> <a id="14996" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14998" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15000" class="Symbol">)</a> <a id="15002" class="Symbol">(</a><a id="15003" href="Iterative.Sets.html#15003" class="Bound">ϕ</a> <a id="15005" class="Symbol">:</a> <a id="15007" href="Iterative.Sets.html#14992" class="Bound">X</a> <a id="15009" class="Symbol">→</a> <a id="15011" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15012" class="Symbol">)</a> <a id="15014" class="Symbol">(</a><a id="15015" href="Iterative.Sets.html#15015" class="Bound">e</a> <a id="15017" class="Symbol">:</a> <a id="15019" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="15032" href="Iterative.Sets.html#15003" class="Bound">ϕ</a><a id="15033" class="Symbol">)</a>
 <a id="15036" class="Symbol">→</a> <a id="15038" href="Iterative.Sets.html#14665" class="Function">𝕍-recursion</a> <a id="15050" href="Iterative.Sets.html#14899" class="Bound">P</a> <a id="15052" href="Iterative.Sets.html#14913" class="Bound">f</a> <a id="15054" class="Symbol">(</a><a id="15055" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="15062" href="Iterative.Sets.html#14992" class="Bound">X</a> <a id="15064" href="Iterative.Sets.html#15003" class="Bound">ϕ</a> <a id="15066" href="Iterative.Sets.html#15015" class="Bound">e</a><a id="15067" class="Symbol">)</a> <a id="15069" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15071" href="Iterative.Sets.html#14913" class="Bound">f</a> <a id="15073" href="Iterative.Sets.html#14992" class="Bound">X</a> <a id="15075" href="Iterative.Sets.html#15003" class="Bound">ϕ</a> <a id="15077" href="Iterative.Sets.html#15015" class="Bound">e</a> <a id="15079" class="Symbol">(λ</a> <a id="15082" href="Iterative.Sets.html#15082" class="Bound">x</a> <a id="15084" class="Symbol">→</a> <a id="15086" href="Iterative.Sets.html#14665" class="Function">𝕍-recursion</a> <a id="15098" href="Iterative.Sets.html#14899" class="Bound">P</a> <a id="15100" href="Iterative.Sets.html#14913" class="Bound">f</a> <a id="15102" class="Symbol">(</a><a id="15103" href="Iterative.Sets.html#15003" class="Bound">ϕ</a> <a id="15105" href="Iterative.Sets.html#15082" class="Bound">x</a><a id="15106" class="Symbol">))</a>
<a id="15109" href="Iterative.Sets.html#14873" class="Function">𝕍-recursion-behaviour</a> <a id="15131" href="Iterative.Sets.html#15131" class="Bound">P</a> <a id="15133" class="Symbol">=</a> <a id="15135" href="Iterative.Sets.html#14347" class="Function">𝕍-induction-behaviour</a> <a id="15157" class="Symbol">(λ</a> <a id="15160" href="Iterative.Sets.html#15160" class="Bound">_</a> <a id="15162" class="Symbol">→</a> <a id="15164" href="Iterative.Sets.html#15131" class="Bound">P</a><a id="15165" class="Symbol">)</a>

<a id="𝕍-iteration"></a><a id="15168" href="Iterative.Sets.html#15168" class="Function">𝕍-iteration</a> <a id="15180" class="Symbol">:</a> <a id="15182" class="Symbol">(</a><a id="15183" href="Iterative.Sets.html#15183" class="Bound">P</a> <a id="15185" class="Symbol">:</a> <a id="15187" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="15189" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15191" class="Symbol">)</a>
            <a id="15205" class="Symbol">→</a> <a id="15207" class="Symbol">((</a><a id="15209" href="Iterative.Sets.html#15209" class="Bound">X</a> <a id="15211" class="Symbol">:</a> <a id="15213" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15215" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15217" class="Symbol">)</a> <a id="15219" class="Symbol">→</a> <a id="15221" class="Symbol">(</a><a id="15222" href="Iterative.Sets.html#15209" class="Bound">X</a> <a id="15224" class="Symbol">→</a> <a id="15226" href="Iterative.Sets.html#15183" class="Bound">P</a><a id="15227" class="Symbol">)</a> <a id="15229" class="Symbol">→</a> <a id="15231" href="Iterative.Sets.html#15183" class="Bound">P</a><a id="15232" class="Symbol">)</a>
            <a id="15246" class="Symbol">→</a> <a id="15248" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="15250" class="Symbol">→</a> <a id="15252" href="Iterative.Sets.html#15183" class="Bound">P</a>
<a id="15254" href="Iterative.Sets.html#15168" class="Function">𝕍-iteration</a> <a id="15266" href="Iterative.Sets.html#15266" class="Bound">P</a> <a id="15268" href="Iterative.Sets.html#15268" class="Bound">f</a> <a id="15270" class="Symbol">=</a> <a id="15272" href="Iterative.Sets.html#14665" class="Function">𝕍-recursion</a> <a id="15284" href="Iterative.Sets.html#15266" class="Bound">P</a> <a id="15286" class="Symbol">(λ</a> <a id="15289" href="Iterative.Sets.html#15289" class="Bound">X</a> <a id="15291" href="Iterative.Sets.html#15291" class="Bound">ϕ</a> <a id="15293" href="Iterative.Sets.html#15293" class="Bound">e</a> <a id="15295" class="Symbol">→</a> <a id="15297" href="Iterative.Sets.html#15268" class="Bound">f</a> <a id="15299" href="Iterative.Sets.html#15289" class="Bound">X</a><a id="15300" class="Symbol">)</a>

<a id="𝕍-iteration-behaviour"></a><a id="15303" href="Iterative.Sets.html#15303" class="Function">𝕍-iteration-behaviour</a>
 <a id="15326" class="Symbol">:</a> <a id="15328" class="Symbol">(</a><a id="15329" href="Iterative.Sets.html#15329" class="Bound">P</a> <a id="15331" class="Symbol">:</a> <a id="15333" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="15335" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15337" class="Symbol">)</a>
 <a id="15340" class="Symbol">→</a> <a id="15342" class="Symbol">(</a><a id="15343" href="Iterative.Sets.html#15343" class="Bound">f</a> <a id="15345" class="Symbol">:</a> <a id="15347" class="Symbol">(</a><a id="15348" href="Iterative.Sets.html#15348" class="Bound">X</a> <a id="15350" class="Symbol">:</a> <a id="15352" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15354" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15356" class="Symbol">)</a> <a id="15358" class="Symbol">→</a> <a id="15360" class="Symbol">(</a><a id="15361" href="Iterative.Sets.html#15348" class="Bound">X</a> <a id="15363" class="Symbol">→</a> <a id="15365" href="Iterative.Sets.html#15329" class="Bound">P</a><a id="15366" class="Symbol">)</a> <a id="15368" class="Symbol">→</a> <a id="15370" href="Iterative.Sets.html#15329" class="Bound">P</a><a id="15371" class="Symbol">)</a>
 <a id="15374" class="Symbol">→</a> <a id="15376" class="Symbol">(</a><a id="15377" href="Iterative.Sets.html#15377" class="Bound">X</a> <a id="15379" class="Symbol">:</a> <a id="15381" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15383" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15385" class="Symbol">)</a> <a id="15387" class="Symbol">(</a><a id="15388" href="Iterative.Sets.html#15388" class="Bound">ϕ</a> <a id="15390" class="Symbol">:</a> <a id="15392" href="Iterative.Sets.html#15377" class="Bound">X</a> <a id="15394" class="Symbol">→</a> <a id="15396" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15397" class="Symbol">)</a> <a id="15399" class="Symbol">(</a><a id="15400" href="Iterative.Sets.html#15400" class="Bound">e</a> <a id="15402" class="Symbol">:</a> <a id="15404" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="15417" href="Iterative.Sets.html#15388" class="Bound">ϕ</a><a id="15418" class="Symbol">)</a>
 <a id="15421" class="Symbol">→</a> <a id="15423" href="Iterative.Sets.html#15168" class="Function">𝕍-iteration</a> <a id="15435" href="Iterative.Sets.html#15329" class="Bound">P</a> <a id="15437" href="Iterative.Sets.html#15343" class="Bound">f</a> <a id="15439" class="Symbol">(</a><a id="15440" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="15447" href="Iterative.Sets.html#15377" class="Bound">X</a> <a id="15449" href="Iterative.Sets.html#15388" class="Bound">ϕ</a> <a id="15451" href="Iterative.Sets.html#15400" class="Bound">e</a><a id="15452" class="Symbol">)</a> <a id="15454" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15456" href="Iterative.Sets.html#15343" class="Bound">f</a> <a id="15458" href="Iterative.Sets.html#15377" class="Bound">X</a> <a id="15460" class="Symbol">(λ</a> <a id="15463" href="Iterative.Sets.html#15463" class="Bound">x</a> <a id="15465" class="Symbol">→</a> <a id="15467" href="Iterative.Sets.html#15168" class="Function">𝕍-iteration</a> <a id="15479" href="Iterative.Sets.html#15329" class="Bound">P</a> <a id="15481" href="Iterative.Sets.html#15343" class="Bound">f</a> <a id="15483" class="Symbol">(</a><a id="15484" href="Iterative.Sets.html#15388" class="Bound">ϕ</a> <a id="15486" href="Iterative.Sets.html#15463" class="Bound">x</a><a id="15487" class="Symbol">))</a>
<a id="15490" href="Iterative.Sets.html#15303" class="Function">𝕍-iteration-behaviour</a> <a id="15512" href="Iterative.Sets.html#15512" class="Bound">P</a> <a id="15514" href="Iterative.Sets.html#15514" class="Bound">f</a> <a id="15516" class="Symbol">=</a> <a id="15518" href="Iterative.Sets.html#14873" class="Function">𝕍-recursion-behaviour</a> <a id="15540" href="Iterative.Sets.html#15512" class="Bound">P</a> <a id="15542" class="Symbol">(λ</a> <a id="15545" href="Iterative.Sets.html#15545" class="Bound">X</a> <a id="15547" href="Iterative.Sets.html#15547" class="Bound">ϕ</a> <a id="15549" href="Iterative.Sets.html#15549" class="Bound">e</a> <a id="15551" class="Symbol">→</a> <a id="15553" href="Iterative.Sets.html#15514" class="Bound">f</a> <a id="15555" href="Iterative.Sets.html#15545" class="Bound">X</a><a id="15556" class="Symbol">)</a>

<a id="15559" class="Markup">\end{code}</a><a id="15569" class="Background">

So we are essentially working with (an encoding) of the above
non-strictly positive data type.

The usual induction principle for iterative sets follows directly from
the above form of induction. This consequence is already in Gylterud [4].

</a><a id="15813" class="Markup">\begin{code}</a>

<a id="∈-induction"></a><a id="15827" href="Iterative.Sets.html#15827" class="Function">∈-induction</a> <a id="15839" class="Symbol">:</a> <a id="15841" class="Symbol">(</a><a id="15842" href="Iterative.Sets.html#15842" class="Bound">P</a> <a id="15844" class="Symbol">:</a> <a id="15846" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="15848" class="Symbol">→</a> <a id="15850" href="MLTT.Universes.html#3835" class="Generalizable">𝓥</a> <a id="15852" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="15854" class="Symbol">)</a>
            <a id="15868" class="Symbol">→</a> <a id="15870" class="Symbol">((</a><a id="15872" href="Iterative.Sets.html#15872" class="Bound">A</a> <a id="15874" class="Symbol">:</a> <a id="15876" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15877" class="Symbol">)</a> <a id="15879" class="Symbol">→</a> <a id="15881" class="Symbol">((</a><a id="15883" href="Iterative.Sets.html#15883" class="Bound">B</a> <a id="15885" class="Symbol">:</a> <a id="15887" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15888" class="Symbol">)</a> <a id="15890" class="Symbol">→</a> <a id="15892" href="Iterative.Sets.html#15883" class="Bound">B</a> <a id="15894" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="15896" href="Iterative.Sets.html#15872" class="Bound">A</a> <a id="15898" class="Symbol">→</a> <a id="15900" href="Iterative.Sets.html#15842" class="Bound">P</a> <a id="15902" href="Iterative.Sets.html#15883" class="Bound">B</a><a id="15903" class="Symbol">)</a> <a id="15905" class="Symbol">→</a> <a id="15907" href="Iterative.Sets.html#15842" class="Bound">P</a> <a id="15909" href="Iterative.Sets.html#15872" class="Bound">A</a><a id="15910" class="Symbol">)</a>
            <a id="15924" class="Symbol">→</a> <a id="15926" class="Symbol">(</a><a id="15927" href="Iterative.Sets.html#15927" class="Bound">A</a> <a id="15929" class="Symbol">:</a> <a id="15931" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15932" class="Symbol">)</a> <a id="15934" class="Symbol">→</a> <a id="15936" href="Iterative.Sets.html#15842" class="Bound">P</a> <a id="15938" href="Iterative.Sets.html#15927" class="Bound">A</a>
<a id="15940" href="Iterative.Sets.html#15827" class="Function">∈-induction</a> <a id="15952" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="15954" href="Iterative.Sets.html#15954" class="Bound">IH</a> <a id="15957" class="Symbol">=</a> <a id="15959" href="Iterative.Sets.html#14112" class="Function">𝕍-induction</a> <a id="15971" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="15973" href="Iterative.Sets.html#15984" class="Function">f</a>
 <a id="15976" class="Keyword">where</a>
  <a id="15984" href="Iterative.Sets.html#15984" class="Function">f</a> <a id="15986" class="Symbol">:</a> <a id="15988" class="Symbol">(</a><a id="15989" href="Iterative.Sets.html#15989" class="Bound">X</a> <a id="15991" class="Symbol">:</a> <a id="15993" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15995" href="MLTT.Universes.html#3976" class="Function Operator">̇</a><a id="15996" class="Symbol">)</a> <a id="15998" class="Symbol">(</a><a id="15999" href="Iterative.Sets.html#15999" class="Bound">ϕ</a> <a id="16001" class="Symbol">:</a> <a id="16003" href="Iterative.Sets.html#15989" class="Bound">X</a> <a id="16005" class="Symbol">→</a> <a id="16007" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16008" class="Symbol">)</a> <a id="16010" class="Symbol">(</a><a id="16011" href="Iterative.Sets.html#16011" class="Bound">e</a> <a id="16013" class="Symbol">:</a> <a id="16015" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="16028" href="Iterative.Sets.html#15999" class="Bound">ϕ</a><a id="16029" class="Symbol">)</a>
    <a id="16035" class="Symbol">→</a> <a id="16037" class="Symbol">((</a><a id="16039" href="Iterative.Sets.html#16039" class="Bound">x</a> <a id="16041" class="Symbol">:</a> <a id="16043" href="Iterative.Sets.html#15989" class="Bound">X</a><a id="16044" class="Symbol">)</a> <a id="16046" class="Symbol">→</a> <a id="16048" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16050" class="Symbol">(</a><a id="16051" href="Iterative.Sets.html#15999" class="Bound">ϕ</a> <a id="16053" href="Iterative.Sets.html#16039" class="Bound">x</a><a id="16054" class="Symbol">))</a>
    <a id="16061" class="Symbol">→</a> <a id="16063" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16065" class="Symbol">(</a><a id="16066" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16073" href="Iterative.Sets.html#15989" class="Bound">X</a> <a id="16075" href="Iterative.Sets.html#15999" class="Bound">ϕ</a> <a id="16077" href="Iterative.Sets.html#16011" class="Bound">e</a><a id="16078" class="Symbol">)</a>
  <a id="16082" href="Iterative.Sets.html#15984" class="Function">f</a> <a id="16084" href="Iterative.Sets.html#16084" class="Bound">X</a> <a id="16086" href="Iterative.Sets.html#16086" class="Bound">ϕ</a> <a id="16088" href="Iterative.Sets.html#16088" class="Bound">e</a> <a id="16090" href="Iterative.Sets.html#16090" class="Bound">IH&#39;</a> <a id="16094" class="Symbol">=</a> <a id="16096" href="Iterative.Sets.html#15954" class="Bound">IH</a> <a id="16099" href="Iterative.Sets.html#16116" class="Function">A</a> <a id="16101" href="Iterative.Sets.html#16148" class="Function">s</a>
   <a id="16106" class="Keyword">where</a>
    <a id="16116" href="Iterative.Sets.html#16116" class="Function">A</a> <a id="16118" class="Symbol">:</a> <a id="16120" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="16126" href="Iterative.Sets.html#16116" class="Function">A</a> <a id="16128" class="Symbol">=</a> <a id="16130" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16137" href="Iterative.Sets.html#16084" class="Bound">X</a> <a id="16139" href="Iterative.Sets.html#16086" class="Bound">ϕ</a> <a id="16141" href="Iterative.Sets.html#16088" class="Bound">e</a>

    <a id="16148" href="Iterative.Sets.html#16148" class="Function">s</a> <a id="16150" class="Symbol">:</a> <a id="16152" class="Symbol">(</a><a id="16153" href="Iterative.Sets.html#16153" class="Bound">B</a> <a id="16155" class="Symbol">:</a> <a id="16157" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16158" class="Symbol">)</a> <a id="16160" class="Symbol">→</a> <a id="16162" href="Iterative.Sets.html#16153" class="Bound">B</a> <a id="16164" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16166" href="Iterative.Sets.html#16116" class="Function">A</a> <a id="16168" class="Symbol">→</a> <a id="16170" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16172" href="Iterative.Sets.html#16153" class="Bound">B</a>
    <a id="16178" href="Iterative.Sets.html#16148" class="Function">s</a> <a id="16180" href="Iterative.Sets.html#16180" class="Bound">B</a><a id="16181" class="Symbol">@(</a><a id="16183" class="DottedPattern Symbol">.(</a><a id="16185" href="Iterative.Sets.html#2892" class="DottedPattern Function">underlying-mset</a> <a id="16201" class="DottedPattern Symbol">(</a><a id="16202" href="Iterative.Sets.html#16086" class="DottedPattern Bound">ϕ</a> <a id="16204" href="Iterative.Sets.html#16214" class="DottedPattern Bound">x</a><a id="16205" class="DottedPattern Symbol">))</a> <a id="16208" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16210" href="Iterative.Sets.html#16210" class="Bound">j</a><a id="16211" class="Symbol">)</a> <a id="16213" class="Symbol">(</a><a id="16214" href="Iterative.Sets.html#16214" class="Bound">x</a> <a id="16216" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16218" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="16222" class="Symbol">)</a> <a id="16224" class="Symbol">=</a> <a id="16226" href="Iterative.Sets.html#16281" class="Function">II</a>
     <a id="16234" class="Keyword">where</a>
      <a id="16246" href="Iterative.Sets.html#16246" class="Function">I</a> <a id="16248" class="Symbol">:</a> <a id="16250" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16252" class="Symbol">(</a><a id="16253" href="Iterative.Sets.html#16086" class="Bound">ϕ</a> <a id="16255" href="Iterative.Sets.html#16214" class="Bound">x</a><a id="16256" class="Symbol">)</a>
      <a id="16264" href="Iterative.Sets.html#16246" class="Function">I</a> <a id="16266" class="Symbol">=</a> <a id="16268" href="Iterative.Sets.html#16090" class="Bound">IH&#39;</a> <a id="16272" href="Iterative.Sets.html#16214" class="Bound">x</a>

      <a id="16281" href="Iterative.Sets.html#16281" class="Function">II</a> <a id="16284" class="Symbol">:</a> <a id="16286" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16288" class="Symbol">(</a><a id="16289" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="16305" class="Symbol">(</a><a id="16306" href="Iterative.Sets.html#16086" class="Bound">ϕ</a> <a id="16308" href="Iterative.Sets.html#16214" class="Bound">x</a><a id="16309" class="Symbol">)</a> <a id="16311" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16313" href="Iterative.Sets.html#16210" class="Bound">j</a><a id="16314" class="Symbol">)</a>
      <a id="16322" href="Iterative.Sets.html#16281" class="Function">II</a> <a id="16325" class="Symbol">=</a> <a id="16327" href="MLTT.Id.html#735" class="Function">transport</a> <a id="16337" href="Iterative.Sets.html#15952" class="Bound">P</a> <a id="16339" class="Symbol">(</a><a id="16340" href="UF.Subsingletons.html#4965" class="Function">to-subtype-＝</a> <a id="16353" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="16372" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="16376" class="Symbol">)</a> <a id="16378" href="Iterative.Sets.html#16246" class="Function">I</a>

<a id="16381" class="Markup">\end{code}</a><a id="16391" class="Background">

And then it follows immediately that the membership relation is
accessible:

</a><a id="16470" class="Markup">\begin{code}</a>

<a id="∈-is-accessible"></a><a id="16484" href="Iterative.Sets.html#16484" class="Function">∈-is-accessible</a> <a id="16500" class="Symbol">:</a> <a id="16502" class="Symbol">(</a><a id="16503" href="Iterative.Sets.html#16503" class="Bound">A</a> <a id="16505" class="Symbol">:</a> <a id="16507" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16508" class="Symbol">)</a> <a id="16510" class="Symbol">→</a> <a id="16512" href="Ordinals.Notions.html#701" class="Datatype">is-accessible</a> <a id="16526" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="16530" href="Iterative.Sets.html#16503" class="Bound">A</a>
<a id="16532" href="Iterative.Sets.html#16484" class="Function">∈-is-accessible</a> <a id="16548" class="Symbol">=</a> <a id="16550" href="Iterative.Sets.html#15827" class="Function">∈-induction</a> <a id="16562" class="Symbol">(</a><a id="16563" href="Ordinals.Notions.html#701" class="Datatype">is-accessible</a> <a id="16577" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a><a id="16580" class="Symbol">)</a> <a id="16582" class="Symbol">(λ</a> <a id="16585" href="Iterative.Sets.html#16585" class="Bound">_</a> <a id="16587" class="Symbol">→</a> <a id="16589" href="Ordinals.Notions.html#736" class="InductiveConstructor">acc</a><a id="16592" class="Symbol">)</a>

<a id="16595" class="Markup">\end{code}</a><a id="16605" class="Background">

Singleton sets can be constructed as follows.

</a><a id="16654" class="Markup">\begin{code}</a>

<a id="❴_❵"></a><a id="16668" href="Iterative.Sets.html#16668" class="Function Operator">❴_❵</a> <a id="16672" class="Symbol">:</a> <a id="16674" class="Symbol">(</a><a id="16675" href="Iterative.Sets.html#16675" class="Bound">A</a> <a id="16677" class="Symbol">:</a> <a id="16679" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16680" class="Symbol">)</a> <a id="16682" class="Symbol">→</a> <a id="16684" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="16686" href="Iterative.Sets.html#16668" class="Function Operator">❴</a> <a id="16688" href="Iterative.Sets.html#16688" class="Bound">A</a> <a id="16690" href="Iterative.Sets.html#16668" class="Function Operator">❵</a> <a id="16692" class="Symbol">=</a> <a id="16694" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16701" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="16703" class="Symbol">(λ</a> <a id="16706" href="Iterative.Sets.html#16706" class="Bound">_</a> <a id="16708" class="Symbol">→</a> <a id="16710" href="Iterative.Sets.html#16688" class="Bound">A</a><a id="16711" class="Symbol">)</a> <a id="16713" class="Symbol">(</a><a id="16714" href="UF.DiscreteAndSeparated.html#24056" class="Function">global-point-is-embedding</a> <a id="16740" class="Symbol">(λ</a> <a id="16743" href="Iterative.Sets.html#16743" class="Bound">_</a> <a id="16745" class="Symbol">→</a> <a id="16747" href="Iterative.Sets.html#16688" class="Bound">A</a><a id="16748" class="Symbol">)</a> <a id="16750" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a><a id="16758" class="Symbol">)</a>

<a id="❴❵-behaviour"></a><a id="16761" href="Iterative.Sets.html#16761" class="Function">❴❵-behaviour</a> <a id="16774" class="Symbol">:</a> <a id="16776" class="Symbol">(</a><a id="16777" href="Iterative.Sets.html#16777" class="Bound">A</a> <a id="16779" class="Symbol">:</a> <a id="16781" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16782" class="Symbol">)</a> <a id="16784" class="Symbol">(</a><a id="16785" href="Iterative.Sets.html#16785" class="Bound">B</a> <a id="16787" class="Symbol">:</a> <a id="16789" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16790" class="Symbol">)</a> <a id="16792" class="Symbol">→</a> <a id="16794" href="Iterative.Sets.html#16785" class="Bound">B</a> <a id="16796" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16798" href="Iterative.Sets.html#16668" class="Function Operator">❴</a> <a id="16800" href="Iterative.Sets.html#16777" class="Bound">A</a> <a id="16802" href="Iterative.Sets.html#16668" class="Function Operator">❵</a> <a id="16804" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="16806" class="Symbol">(</a><a id="16807" href="Iterative.Sets.html#16785" class="Bound">B</a> <a id="16809" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16811" href="Iterative.Sets.html#16777" class="Bound">A</a><a id="16812" class="Symbol">)</a>
<a id="16814" href="Iterative.Sets.html#16761" class="Function">❴❵-behaviour</a> <a id="16827" href="Iterative.Sets.html#16827" class="Bound">A</a> <a id="16829" href="Iterative.Sets.html#16829" class="Bound">B</a> <a id="16831" class="Symbol">=</a> <a id="16833" href="Iterative.Sets.html#16829" class="Bound">B</a> <a id="16835" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16837" href="Iterative.Sets.html#16668" class="Function Operator">❴</a> <a id="16839" href="Iterative.Sets.html#16827" class="Bound">A</a> <a id="16841" href="Iterative.Sets.html#16668" class="Function Operator">❵</a>    <a id="16846" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16849" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="16862" href="Iterative.Sets.html#16829" class="Bound">B</a> <a id="16864" href="Iterative.Sets.html#16668" class="Function Operator">❴</a> <a id="16866" href="Iterative.Sets.html#16827" class="Bound">A</a> <a id="16868" href="Iterative.Sets.html#16668" class="Function Operator">❵</a> <a id="16870" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16891" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="16893" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="16895" class="Symbol">(</a><a id="16896" href="Iterative.Sets.html#16827" class="Bound">A</a> <a id="16898" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16900" href="Iterative.Sets.html#16829" class="Bound">B</a><a id="16901" class="Symbol">)</a> <a id="16903" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16906" href="UF.EquivalenceExamples.html#7420" class="Function">𝟙-lneutral</a> <a id="16917" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16938" class="Symbol">(</a><a id="16939" href="Iterative.Sets.html#16827" class="Bound">A</a> <a id="16941" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16943" href="Iterative.Sets.html#16829" class="Bound">B</a><a id="16944" class="Symbol">)</a>     <a id="16950" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16953" href="UF.EquivalenceExamples.html#25192" class="Function">＝-flip</a> <a id="16960" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16981" class="Symbol">(</a><a id="16982" href="Iterative.Sets.html#16829" class="Bound">B</a> <a id="16984" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16986" href="Iterative.Sets.html#16827" class="Bound">A</a><a id="16987" class="Symbol">)</a>     <a id="16993" href="UF.Equiv.html#2815" class="Function Operator">■</a>

<a id="16996" class="Markup">\end{code}</a><a id="17006" class="Background">

Given a family of iterative sets indexed by a small type, we construct
its union as in [4].

We make use of propositional truncations (to define the image of a
map) and of set replacement (which follows from having set quotients).

</a><a id="17240" class="Markup">\begin{code}</a>

<a id="17254" class="Keyword">open</a> <a id="17259" class="Keyword">import</a> <a id="17266" href="UF.PropTrunc.html" class="Module">UF.PropTrunc</a>

<a id="17280" class="Keyword">module</a> <a id="17287" href="Iterative.Sets.html#17287" class="Module">_</a> <a id="17289" class="Symbol">(</a><a id="17290" href="Iterative.Sets.html#17290" class="Bound">pt</a> <a id="17293" class="Symbol">:</a> <a id="17295" href="UF.PropTrunc.html#486" class="Record">propositional-truncations-exist</a><a id="17326" class="Symbol">)</a> <a id="17328" class="Keyword">where</a>

 <a id="17336" class="Keyword">open</a> <a id="17341" href="UF.PropTrunc.html#792" class="Module">PropositionalTruncation</a> <a id="17365" href="Iterative.Sets.html#17290" class="Bound">pt</a>
 <a id="17369" class="Keyword">open</a> <a id="17374" class="Keyword">import</a> <a id="17381" href="UF.ImageAndSurjection.html" class="Module">UF.ImageAndSurjection</a> <a id="17403" href="Iterative.Sets.html#17290" class="Bound">pt</a>

 <a id="17408" class="Keyword">module</a> <a id="17415" href="Iterative.Sets.html#17415" class="Module">unions-of-iterative-sets</a> <a id="17440" class="Symbol">(</a><a id="17441" href="Iterative.Sets.html#17441" class="Bound">sr</a> <a id="17444" class="Symbol">:</a> <a id="17446" href="UF.Size.html#32946" class="Function">Set-Replacement</a> <a id="17462" href="Iterative.Sets.html#17290" class="Bound">pt</a><a id="17464" class="Symbol">)</a> <a id="17466" class="Keyword">where</a>

  <a id="17475" class="Keyword">private</a>
   <a id="17486" class="Keyword">module</a> <a id="17493" href="Iterative.Sets.html#17493" class="Module">union-construction</a>
          <a id="17522" class="Symbol">{</a><a id="17523" href="Iterative.Sets.html#17523" class="Bound">I</a> <a id="17525" class="Symbol">:</a> <a id="17527" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17529" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="17531" class="Symbol">}</a>
          <a id="17543" class="Symbol">(</a><a id="17544" href="Iterative.Sets.html#17544" class="Bound">𝓐</a> <a id="17546" class="Symbol">:</a> <a id="17548" href="Iterative.Sets.html#17523" class="Bound">I</a> <a id="17550" class="Symbol">→</a> <a id="17552" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="17553" class="Symbol">)</a>
         <a id="17564" class="Keyword">where</a>

    <a id="17575" href="Iterative.Sets.html#17575" class="Function">im</a> <a id="17578" class="Symbol">:</a> <a id="17580" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="17583" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
    <a id="17589" href="Iterative.Sets.html#17575" class="Function">im</a> <a id="17592" class="Symbol">=</a> <a id="17594" href="UF.ImageAndSurjection.html#939" class="Function">image</a> <a id="17600" href="Iterative.Sets.html#17544" class="Bound">𝓐</a>

    <a id="17607" href="Iterative.Sets.html#17607" class="Function">im-is-small</a> <a id="17619" class="Symbol">:</a> <a id="17621" href="UF.ImageAndSurjection.html#939" class="Function">image</a> <a id="17627" href="Iterative.Sets.html#17544" class="Bound">𝓐</a> <a id="17629" href="UF.Size.html#2097" class="Function Operator">is</a> <a id="17632" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17634" href="UF.Size.html#2097" class="Function Operator">small</a>
    <a id="17644" href="Iterative.Sets.html#17607" class="Function">im-is-small</a> <a id="17656" class="Symbol">=</a> <a id="17658" href="Iterative.Sets.html#17441" class="Bound">sr</a> <a id="17661" href="Iterative.Sets.html#17544" class="Bound">𝓐</a> <a id="17663" class="Symbol">(</a><a id="17664" href="Iterative.Sets.html#17523" class="Bound">I</a> <a id="17666" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="17668" href="UF.Equiv.html#1517" class="Function">≃-refl</a> <a id="17675" href="Iterative.Sets.html#17523" class="Bound">I</a><a id="17676" class="Symbol">)</a> <a id="17678" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="17697" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a>

    <a id="17711" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="17715" class="Symbol">:</a> <a id="17717" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17719" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
    <a id="17725" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="17729" class="Symbol">=</a> <a id="17731" href="UF.Size.html#2247" class="Function">resized</a> <a id="17739" href="Iterative.Sets.html#17575" class="Function">im</a> <a id="17742" href="Iterative.Sets.html#17607" class="Function">im-is-small</a>

    <a id="17759" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a> <a id="17768" class="Symbol">:</a> <a id="17770" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="17774" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="17776" href="Iterative.Sets.html#17575" class="Function">im</a>
    <a id="17783" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a> <a id="17792" class="Symbol">=</a> <a id="17794" href="UF.Size.html#2306" class="Function">resizing-condition</a> <a id="17813" href="Iterative.Sets.html#17607" class="Function">im-is-small</a>

    <a id="17830" href="Iterative.Sets.html#17830" class="Function">π</a> <a id="17832" class="Symbol">:</a> <a id="17834" href="Iterative.Sets.html#17575" class="Function">im</a> <a id="17837" class="Symbol">→</a> <a id="17839" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="17845" href="Iterative.Sets.html#17830" class="Function">π</a> <a id="17847" class="Symbol">=</a> <a id="17849" href="UF.ImageAndSurjection.html#1030" class="Function">restriction</a> <a id="17861" href="Iterative.Sets.html#17544" class="Bound">𝓐</a>

    <a id="17868" href="Iterative.Sets.html#17868" class="Function">π⁻</a> <a id="17871" class="Symbol">:</a> <a id="17873" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="17877" class="Symbol">→</a> <a id="17879" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="17885" href="Iterative.Sets.html#17868" class="Function">π⁻</a> <a id="17888" class="Symbol">=</a> <a id="17890" href="Iterative.Sets.html#17830" class="Function">π</a> <a id="17892" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17894" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="17896" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a> <a id="17905" href="UF.Equiv.html#2933" class="Function Operator">⌝</a>

    <a id="17912" href="Iterative.Sets.html#17912" class="Function">π-is-embedding</a> <a id="17927" class="Symbol">:</a> <a id="17929" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="17942" href="Iterative.Sets.html#17830" class="Function">π</a>
    <a id="17948" href="Iterative.Sets.html#17912" class="Function">π-is-embedding</a> <a id="17963" class="Symbol">=</a> <a id="17965" href="UF.ImageAndSurjection.html#1395" class="Function">restrictions-are-embeddings</a> <a id="17993" href="Iterative.Sets.html#17544" class="Bound">𝓐</a>

    <a id="18000" href="Iterative.Sets.html#18000" class="Function">π⁻-is-embedding</a> <a id="18016" class="Symbol">:</a> <a id="18018" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="18031" href="Iterative.Sets.html#17868" class="Function">π⁻</a>
    <a id="18038" href="Iterative.Sets.html#18000" class="Function">π⁻-is-embedding</a> <a id="18054" class="Symbol">=</a> <a id="18056" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a>
                       <a id="18094" class="Symbol">(</a><a id="18095" href="UF.Embeddings.html#3426" class="Function">equivs-are-embeddings</a>
                         <a id="18142" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="18144" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a> <a id="18153" href="UF.Equiv.html#2933" class="Function Operator">⌝</a>
                         <a id="18180" class="Symbol">(</a><a id="18181" href="UF.Equiv.html#3027" class="Function">⌜⌝-is-equiv</a> <a id="18193" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a><a id="18201" class="Symbol">))</a>
                       <a id="18227" href="Iterative.Sets.html#17912" class="Function">π-is-embedding</a>

  <a id="18245" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="18247" class="Symbol">:</a> <a id="18249" class="Symbol">{</a><a id="18250" href="Iterative.Sets.html#18250" class="Bound">I</a> <a id="18252" class="Symbol">:</a> <a id="18254" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="18256" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="18258" class="Symbol">}</a> <a id="18260" class="Symbol">(</a><a id="18261" href="Iterative.Sets.html#18261" class="Bound">𝓐</a> <a id="18263" class="Symbol">:</a> <a id="18265" href="Iterative.Sets.html#18250" class="Bound">I</a> <a id="18267" class="Symbol">→</a> <a id="18269" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18270" class="Symbol">)</a> <a id="18272" class="Symbol">→</a> <a id="18274" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
  <a id="18278" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="18280" class="Symbol">{</a><a id="18281" href="Iterative.Sets.html#18281" class="Bound">I</a><a id="18282" class="Symbol">}</a> <a id="18284" href="Iterative.Sets.html#18284" class="Bound">𝓐</a> <a id="18286" class="Symbol">=</a> <a id="18288" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="18295" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="18299" href="Iterative.Sets.html#17868" class="Function">π⁻</a> <a id="18302" href="Iterative.Sets.html#18000" class="Function">π⁻-is-embedding</a>
   <a id="18321" class="Keyword">where</a>
    <a id="18331" class="Keyword">open</a> <a id="18336" href="Iterative.Sets.html#17493" class="Module">union-construction</a> <a id="18355" href="Iterative.Sets.html#18284" class="Bound">𝓐</a>

  <a id="18360" href="Iterative.Sets.html#18360" class="Function">⋃-behaviour</a> <a id="18372" class="Symbol">:</a> <a id="18374" class="Symbol">{</a><a id="18375" href="Iterative.Sets.html#18375" class="Bound">I</a> <a id="18377" class="Symbol">:</a> <a id="18379" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="18381" href="MLTT.Universes.html#3976" class="Function Operator">̇</a> <a id="18383" class="Symbol">}</a> <a id="18385" class="Symbol">(</a><a id="18386" href="Iterative.Sets.html#18386" class="Bound">𝓐</a> <a id="18388" class="Symbol">:</a> <a id="18390" href="Iterative.Sets.html#18375" class="Bound">I</a> <a id="18392" class="Symbol">→</a> <a id="18394" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18395" class="Symbol">)</a> <a id="18397" class="Symbol">(</a><a id="18398" href="Iterative.Sets.html#18398" class="Bound">B</a> <a id="18400" class="Symbol">:</a> <a id="18402" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18403" class="Symbol">)</a>
              <a id="18419" class="Symbol">→</a> <a id="18421" href="Iterative.Sets.html#18398" class="Bound">B</a> <a id="18423" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="18425" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="18427" href="Iterative.Sets.html#18386" class="Bound">𝓐</a> <a id="18429" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="18431" class="Symbol">(</a><a id="18432" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18434" href="Iterative.Sets.html#18434" class="Bound">i</a> <a id="18436" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="18438" href="Iterative.Sets.html#18375" class="Bound">I</a> <a id="18440" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="18442" href="Iterative.Sets.html#18398" class="Bound">B</a> <a id="18444" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18446" href="Iterative.Sets.html#18386" class="Bound">𝓐</a> <a id="18448" href="Iterative.Sets.html#18434" class="Bound">i</a><a id="18449" class="Symbol">)</a>
  <a id="18453" href="Iterative.Sets.html#18360" class="Function">⋃-behaviour</a> <a id="18465" class="Symbol">{</a><a id="18466" href="Iterative.Sets.html#18466" class="Bound">I</a><a id="18467" class="Symbol">}</a> <a id="18469" href="Iterative.Sets.html#18469" class="Bound">𝓐</a> <a id="18471" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="18473" class="Symbol">=</a>
   <a id="18478" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="18480" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="18482" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="18484" href="Iterative.Sets.html#18469" class="Bound">𝓐</a>                                    <a id="18521" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18524" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="18537" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="18539" class="Symbol">(</a><a id="18540" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="18542" href="Iterative.Sets.html#18469" class="Bound">𝓐</a><a id="18543" class="Symbol">)</a> <a id="18545" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18550" class="Symbol">(</a><a id="18551" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18553" href="Iterative.Sets.html#18553" class="Bound">j</a> <a id="18555" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18557" href="Iterative.Sets.html#17711" class="Function">im⁻</a> <a id="18561" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18563" href="Iterative.Sets.html#17868" class="Function">π⁻</a> <a id="18566" href="Iterative.Sets.html#18553" class="Bound">j</a> <a id="18568" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18570" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="18571" class="Symbol">)</a>                    <a id="18592" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18595" href="Iterative.Sets.html#19084" class="Function">e₁</a> <a id="18598" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18603" class="Symbol">(</a><a id="18604" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18606" href="Iterative.Sets.html#18606" class="Bound">j</a> <a id="18608" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18610" href="Iterative.Sets.html#17575" class="Function">im</a> <a id="18613" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18615" href="Iterative.Sets.html#17830" class="Function">π</a> <a id="18617" href="Iterative.Sets.html#18606" class="Bound">j</a> <a id="18619" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18621" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="18622" class="Symbol">)</a>                      <a id="18645" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18648" href="UF.EquivalenceExamples.html#2025" class="Function">Σ-assoc</a> <a id="18656" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18661" class="Symbol">(</a><a id="18662" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18664" href="Iterative.Sets.html#18664" class="Bound">C</a> <a id="18666" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18668" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="18670" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18672" href="Iterative.Sets.html#18664" class="Bound">C</a> <a id="18674" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18681" href="Iterative.Sets.html#18469" class="Bound">𝓐</a> <a id="18683" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18685" class="Symbol">(</a><a id="18686" href="Iterative.Sets.html#18664" class="Bound">C</a> <a id="18688" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18690" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="18691" class="Symbol">))</a>          <a id="18703" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18706" href="UF.EquivalenceExamples.html#3378" class="Function">Σ-cong</a> <a id="18713" class="Symbol">(λ</a> <a id="18716" href="Iterative.Sets.html#18716" class="Bound">C</a> <a id="18718" class="Symbol">→</a> <a id="18720" href="UF.EquivalenceExamples.html#7690" class="Function">×-comm</a><a id="18726" class="Symbol">)</a> <a id="18728" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18733" class="Symbol">(</a><a id="18734" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18736" href="Iterative.Sets.html#18736" class="Bound">C</a> <a id="18738" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18740" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="18742" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18744" class="Symbol">(</a><a id="18745" href="Iterative.Sets.html#18736" class="Bound">C</a> <a id="18747" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18749" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="18750" class="Symbol">)</a> <a id="18752" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18754" class="Symbol">(</a><a id="18755" href="Iterative.Sets.html#18736" class="Bound">C</a> <a id="18757" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18764" href="Iterative.Sets.html#18469" class="Bound">𝓐</a><a id="18765" class="Symbol">))</a>        <a id="18775" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18778" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="18784" href="UF.EquivalenceExamples.html#2025" class="Function">Σ-assoc</a> <a id="18792" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18797" class="Symbol">(</a><a id="18798" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18800" href="Iterative.Sets.html#18800" class="Bound">s</a> <a id="18802" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18804" href="UF.Subsingletons.html#3951" class="Function">singleton-type&#39;</a> <a id="18820" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="18822" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18824" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="18828" href="Iterative.Sets.html#18800" class="Bound">s</a> <a id="18830" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18837" href="Iterative.Sets.html#18469" class="Bound">𝓐</a><a id="18838" class="Symbol">)</a> <a id="18840" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18843" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="18849" href="Iterative.Sets.html#19128" class="Function">e₂</a> <a id="18852" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18857" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="18859" class="Symbol">{</a><a id="18860" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="18861" class="Symbol">}</a> <a id="18863" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18865" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="18867" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18874" href="Iterative.Sets.html#18469" class="Bound">𝓐</a>                         <a id="18900" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18903" href="UF.EquivalenceExamples.html#7420" class="Function">𝟙-lneutral</a> <a id="18914" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18919" class="Symbol">(</a><a id="18920" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18922" href="Iterative.Sets.html#18922" class="Bound">i</a> <a id="18924" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="18926" href="Iterative.Sets.html#18466" class="Bound">I</a> <a id="18928" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="18930" href="Iterative.Sets.html#18469" class="Bound">𝓐</a> <a id="18932" href="Iterative.Sets.html#18922" class="Bound">i</a> <a id="18934" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18936" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="18937" class="Symbol">)</a>                       <a id="18961" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18964" href="UF.EquivalenceExamples.html#34784" class="Function">∃-cong</a> <a id="18971" href="Iterative.Sets.html#17290" class="Bound">pt</a> <a id="18974" class="Symbol">(λ</a> <a id="18977" href="Iterative.Sets.html#18977" class="Bound">i</a> <a id="18979" class="Symbol">→</a> <a id="18981" href="UF.EquivalenceExamples.html#25192" class="Function">＝-flip</a><a id="18987" class="Symbol">)</a> <a id="18989" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18994" class="Symbol">(</a><a id="18995" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18997" href="Iterative.Sets.html#18997" class="Bound">i</a> <a id="18999" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="19001" href="Iterative.Sets.html#18466" class="Bound">I</a> <a id="19003" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="19005" href="Iterative.Sets.html#18471" class="Bound">B</a> <a id="19007" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19009" href="Iterative.Sets.html#18469" class="Bound">𝓐</a> <a id="19011" href="Iterative.Sets.html#18997" class="Bound">i</a><a id="19012" class="Symbol">)</a>                       <a id="19036" href="UF.Equiv.html#2815" class="Function Operator">■</a>
    <a id="19042" class="Keyword">where</a>
     <a id="19053" class="Keyword">open</a> <a id="19058" href="Iterative.Sets.html#17493" class="Module">union-construction</a> <a id="19077" href="Iterative.Sets.html#18469" class="Bound">𝓐</a>
     <a id="19084" href="Iterative.Sets.html#19084" class="Function">e₁</a> <a id="19087" class="Symbol">=</a> <a id="19089" href="UF.EquivalenceExamples.html#20247" class="Function">Σ-change-of-variable-≃</a> <a id="19112" class="Symbol">_</a> <a id="19114" href="Iterative.Sets.html#17759" class="Function">im⁻-≃-im</a>
     <a id="19128" href="Iterative.Sets.html#19128" class="Function">e₂</a> <a id="19131" class="Symbol">=</a> <a id="19133" href="UF.EquivalenceExamples.html#20247" class="Function">Σ-change-of-variable-≃</a> <a id="19156" class="Symbol">_</a>
           <a id="19169" class="Symbol">(</a><a id="19170" href="UF.EquivalenceExamples.html#25604" class="Function">singleton-≃-𝟙&#39;</a> <a id="19185" class="Symbol">(</a><a id="19186" href="UF.Equiv.html#9612" class="Function">singleton-types&#39;-are-singletons</a> <a id="19218" href="Iterative.Sets.html#18471" class="Bound">B</a><a id="19219" class="Symbol">))</a>

<a id="19223" class="Markup">\end{code}</a><a id="19233" class="Background">

Any iterative set is the union of its 𝕍-forest.

</a><a id="19284" class="Markup">\begin{code}</a>

  <a id="19300" href="Iterative.Sets.html#19300" class="Function">⋃-η</a> <a id="19304" class="Symbol">:</a> <a id="19306" class="Symbol">(</a><a id="19307" href="Iterative.Sets.html#19307" class="Bound">A</a> <a id="19309" class="Symbol">:</a> <a id="19311" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="19312" class="Symbol">)</a> <a id="19314" class="Symbol">→</a> <a id="19316" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="19318" class="Symbol">(</a><a id="19319" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19328" href="Iterative.Sets.html#19307" class="Bound">A</a><a id="19329" class="Symbol">)</a> <a id="19331" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19333" href="Iterative.Sets.html#19307" class="Bound">A</a>
  <a id="19337" href="Iterative.Sets.html#19300" class="Function">⋃-η</a> <a id="19341" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19343" class="Symbol">=</a> <a id="19345" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="19362" class="Symbol">(</a><a id="19363" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="19365" class="Symbol">(</a><a id="19366" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19375" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19376" class="Symbol">))</a> <a id="19379" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19381" href="Iterative.Sets.html#19398" class="Function">i</a> <a id="19383" href="Iterative.Sets.html#19605" class="Function">j</a>
   <a id="19388" class="Keyword">where</a>
    <a id="19398" href="Iterative.Sets.html#19398" class="Function">i</a> <a id="19400" class="Symbol">:</a> <a id="19402" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="19404" class="Symbol">(</a><a id="19405" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19414" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19415" class="Symbol">)</a> <a id="19417" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="19419" href="Iterative.Sets.html#19341" class="Bound">A</a>
    <a id="19425" href="Iterative.Sets.html#19398" class="Function">i</a> <a id="19427" href="Iterative.Sets.html#19427" class="Bound">B</a> <a id="19429" href="Iterative.Sets.html#19429" class="Bound">m</a> <a id="19431" class="Symbol">=</a> <a id="19433" href="UF.PropTrunc.html#676" class="Field">∥∥-rec</a> <a id="19440" class="Symbol">(</a><a id="19441" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="19458" href="Iterative.Sets.html#19427" class="Bound">B</a> <a id="19460" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19461" class="Symbol">)</a> <a id="19463" href="Iterative.Sets.html#19517" class="Function">f</a> <a id="19465" class="Symbol">(</a><a id="19466" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="19468" href="Iterative.Sets.html#18360" class="Function">⋃-behaviour</a> <a id="19480" class="Symbol">(</a><a id="19481" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19490" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19491" class="Symbol">)</a> <a id="19493" href="Iterative.Sets.html#19427" class="Bound">B</a> <a id="19495" href="UF.Equiv.html#2933" class="Function Operator">⌝</a> <a id="19497" href="Iterative.Sets.html#19429" class="Bound">m</a><a id="19498" class="Symbol">)</a>
     <a id="19505" class="Keyword">where</a>
      <a id="19517" href="Iterative.Sets.html#19517" class="Function">f</a> <a id="19519" class="Symbol">:</a> <a id="19521" class="Symbol">(</a><a id="19522" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="19524" href="Iterative.Sets.html#19524" class="Bound">a</a> <a id="19526" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="19528" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19535" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19537" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="19539" href="Iterative.Sets.html#19427" class="Bound">B</a> <a id="19541" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19543" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19552" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19554" href="Iterative.Sets.html#19524" class="Bound">a</a><a id="19555" class="Symbol">)</a> <a id="19557" class="Symbol">→</a> <a id="19559" href="Iterative.Sets.html#19427" class="Bound">B</a> <a id="19561" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="19563" href="Iterative.Sets.html#19341" class="Bound">A</a>
      <a id="19571" href="Iterative.Sets.html#19517" class="Function">f</a> <a id="19573" class="Symbol">(</a><a id="19574" href="Iterative.Sets.html#19574" class="Bound">a</a> <a id="19576" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="19578" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="19582" class="Symbol">)</a> <a id="19584" class="Symbol">=</a> <a id="19586" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="19597" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19599" href="Iterative.Sets.html#19574" class="Bound">a</a>
    <a id="19605" href="Iterative.Sets.html#19605" class="Function">j</a> <a id="19607" class="Symbol">:</a> <a id="19609" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19611" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="19613" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="19615" class="Symbol">(</a><a id="19616" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19625" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19626" class="Symbol">)</a>
    <a id="19632" href="Iterative.Sets.html#19605" class="Function">j</a> <a id="19634" href="Iterative.Sets.html#19634" class="Bound">B</a> <a id="19636" href="Iterative.Sets.html#19636" class="Bound">m</a> <a id="19638" class="Symbol">=</a> <a id="19640" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="19642" href="Iterative.Sets.html#18360" class="Function">⋃-behaviour</a> <a id="19654" class="Symbol">(</a><a id="19655" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19664" href="Iterative.Sets.html#19341" class="Bound">A</a><a id="19665" class="Symbol">)</a> <a id="19667" href="Iterative.Sets.html#19634" class="Bound">B</a> <a id="19669" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="19673" href="UF.PropTrunc.html#630" class="Field Operator">∣</a> <a id="19675" href="Iterative.Sets.html#19797" class="Function">a</a> <a id="19677" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="19679" href="Iterative.Sets.html#19835" class="Function">e</a> <a id="19681" href="UF.PropTrunc.html#630" class="Field Operator">∣</a>
     <a id="19688" class="Keyword">where</a>
      <a id="19700" class="Keyword">abstract</a>
       <a id="19716" href="Iterative.Sets.html#19716" class="Function">m&#39;</a> <a id="19719" class="Symbol">:</a> <a id="19721" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="19723" href="Iterative.Sets.html#19723" class="Bound">a</a> <a id="19725" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="19727" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19734" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19736" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="19738" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19747" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19749" href="Iterative.Sets.html#19723" class="Bound">a</a> <a id="19751" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19753" href="Iterative.Sets.html#19634" class="Bound">B</a>
       <a id="19762" href="Iterative.Sets.html#19716" class="Function">m&#39;</a> <a id="19765" class="Symbol">=</a> <a id="19767" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="19769" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="19782" href="Iterative.Sets.html#19634" class="Bound">B</a> <a id="19784" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19786" href="UF.Equiv.html#2933" class="Function Operator">⌝</a> <a id="19788" href="Iterative.Sets.html#19636" class="Bound">m</a>
       <a id="19797" href="Iterative.Sets.html#19797" class="Function">a</a> <a id="19799" class="Symbol">:</a> <a id="19801" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19808" href="Iterative.Sets.html#19341" class="Bound">A</a>
       <a id="19817" href="Iterative.Sets.html#19797" class="Function">a</a> <a id="19819" class="Symbol">=</a> <a id="19821" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="19825" href="Iterative.Sets.html#19716" class="Function">m&#39;</a>
       <a id="19835" href="Iterative.Sets.html#19835" class="Function">e</a> <a id="19837" class="Symbol">:</a> <a id="19839" href="Iterative.Sets.html#19634" class="Bound">B</a> <a id="19841" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19843" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19852" href="Iterative.Sets.html#19341" class="Bound">A</a> <a id="19854" href="Iterative.Sets.html#19797" class="Function">a</a>
       <a id="19863" href="Iterative.Sets.html#19835" class="Function">e</a> <a id="19865" class="Symbol">=</a> <a id="19867" class="Symbol">(</a><a id="19868" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="19872" href="Iterative.Sets.html#19716" class="Function">m&#39;</a><a id="19874" class="Symbol">)</a> <a id="19876" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>

<a id="19880" class="Markup">\end{code}</a><a id="19890" class="Background">

Unions allow us to construct a retraction of the inclusion 𝕍 ↪ 𝕄, and
this seems to be a new result.

</a><a id="19994" class="Markup">\begin{code}</a>

  <a id="20010" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20017" class="Symbol">:</a> <a id="20019" href="Iterative.Multisets.html#690" class="Function">𝕄</a> <a id="20021" class="Symbol">→</a> <a id="20023" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
  <a id="20027" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20034" class="Symbol">(</a><a id="20035" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="20040" href="Iterative.Sets.html#20040" class="Bound">X</a> <a id="20042" href="Iterative.Sets.html#20042" class="Bound">φ</a><a id="20043" class="Symbol">)</a> <a id="20045" class="Symbol">=</a> <a id="20047" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="20049" class="Symbol">(</a><a id="20050" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20057" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20059" href="Iterative.Sets.html#20042" class="Bound">φ</a><a id="20060" class="Symbol">)</a>

  <a id="20065" href="Iterative.Sets.html#20065" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a> <a id="20099" class="Symbol">:</a> <a id="20101" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20108" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20110" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20126" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20128" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="20133" href="Iterative.Sets.html#20065" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a> <a id="20167" class="Symbol">=</a> <a id="20169" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="20177" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="20180" class="Symbol">(</a><a id="20181" href="Iterative.Sets.html#15827" class="Function">∈-induction</a> <a id="20193" class="Symbol">_</a> <a id="20195" href="Iterative.Sets.html#20211" class="Function">f</a><a id="20196" class="Symbol">)</a>
   <a id="20201" class="Keyword">where</a>
    <a id="20211" href="Iterative.Sets.html#20211" class="Function">f</a> <a id="20213" class="Symbol">:</a> <a id="20215" class="Symbol">(</a><a id="20216" href="Iterative.Sets.html#20216" class="Bound">A</a> <a id="20218" class="Symbol">:</a> <a id="20220" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="20221" class="Symbol">)</a> <a id="20223" class="Symbol">→</a> <a id="20225" class="Symbol">((</a><a id="20227" href="Iterative.Sets.html#20227" class="Bound">B</a> <a id="20229" class="Symbol">:</a> <a id="20231" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="20232" class="Symbol">)</a> <a id="20234" class="Symbol">→</a> <a id="20236" href="Iterative.Sets.html#20227" class="Bound">B</a> <a id="20238" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="20240" href="Iterative.Sets.html#20216" class="Bound">A</a> <a id="20242" class="Symbol">→</a> <a id="20244" class="Symbol">(</a><a id="20245" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20252" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20254" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20269" class="Symbol">)</a> <a id="20271" href="Iterative.Sets.html#20227" class="Bound">B</a> <a id="20273" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20275" href="Iterative.Sets.html#20227" class="Bound">B</a><a id="20276" class="Symbol">)</a>
      <a id="20284" class="Symbol">→</a> <a id="20286" class="Symbol">(</a><a id="20287" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20294" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20296" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20311" class="Symbol">)</a> <a id="20313" href="Iterative.Sets.html#20216" class="Bound">A</a> <a id="20315" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20317" href="Iterative.Sets.html#20216" class="Bound">A</a>
    <a id="20323" href="Iterative.Sets.html#20211" class="Function">f</a> <a id="20325" href="Iterative.Sets.html#20325" class="Bound">A</a> <a id="20327" href="Iterative.Sets.html#20327" class="Bound">IH</a> <a id="20330" class="Symbol">=</a> <a id="20332" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20339" href="Iterative.Sets.html#20732" class="Function">Aₘ</a>                                 <a id="20374" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="20377" href="Iterative.Sets.html#20792" class="Function">I</a> <a id="20379" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
             <a id="20394" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20401" class="Symbol">(</a><a id="20402" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="20407" class="Symbol">(</a><a id="20408" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="20415" href="Iterative.Sets.html#20325" class="Bound">A</a><a id="20416" class="Symbol">)</a> <a id="20418" class="Symbol">(</a><a id="20419" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="20428" href="Iterative.Sets.html#20732" class="Function">Aₘ</a><a id="20430" class="Symbol">))</a>    <a id="20436" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="20439" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="20444" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
             <a id="20459" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="20461" class="Symbol">(</a><a id="20462" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20469" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20471" href="Iterative.Multisets.html#1741" class="Function">𝕄-forest</a> <a id="20480" href="Iterative.Sets.html#20732" class="Function">Aₘ</a><a id="20482" class="Symbol">)</a>                  <a id="20501" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="20504" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="20509" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
             <a id="20524" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="20526" class="Symbol">(</a><a id="20527" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20534" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20536" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20552" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20554" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20563" href="Iterative.Sets.html#20325" class="Bound">A</a><a id="20564" class="Symbol">)</a> <a id="20566" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="20569" href="Iterative.Sets.html#20853" class="Function">II</a> <a id="20572" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
             <a id="20587" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="20589" class="Symbol">(</a><a id="20590" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20599" href="Iterative.Sets.html#20325" class="Bound">A</a><a id="20600" class="Symbol">)</a>                            <a id="20629" href="MLTT.Id.html#2239" class="Function Operator">＝⟨</a> <a id="20632" href="Iterative.Sets.html#19300" class="Function">⋃-η</a> <a id="20636" href="Iterative.Sets.html#20325" class="Bound">A</a> <a id="20638" href="MLTT.Id.html#2239" class="Function Operator">⟩</a>
             <a id="20653" href="Iterative.Sets.html#20325" class="Bound">A</a>                                         <a id="20695" href="MLTT.Id.html#2321" class="Function Operator">∎</a>
              <a id="20711" class="Keyword">where</a>
               <a id="20732" href="Iterative.Sets.html#20732" class="Function">Aₘ</a> <a id="20735" class="Symbol">:</a> <a id="20737" href="Iterative.Multisets.html#690" class="Function">𝕄</a>
               <a id="20754" href="Iterative.Sets.html#20732" class="Function">Aₘ</a> <a id="20757" class="Symbol">=</a> <a id="20759" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20775" href="Iterative.Sets.html#20325" class="Bound">A</a>
               <a id="20792" href="Iterative.Sets.html#20792" class="Function">I</a>  <a id="20795" class="Symbol">=</a> <a id="20797" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20800" class="Symbol">(</a><a id="20801" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20808" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20810" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20825" class="Symbol">)</a> <a id="20827" class="Symbol">(</a><a id="20828" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="20832" href="Iterative.Sets.html#20325" class="Bound">A</a> <a id="20834" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20836" class="Symbol">)</a>
               <a id="20853" href="Iterative.Sets.html#20853" class="Function">II</a> <a id="20856" class="Symbol">=</a> <a id="20858" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20861" href="Iterative.Sets.html#18245" class="Function">⋃</a> <a id="20863" class="Symbol">(</a><a id="20864" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="20872" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="20875" class="Symbol">(λ</a> <a id="20878" href="Iterative.Sets.html#20878" class="Bound">a</a> <a id="20880" class="Symbol">→</a> <a id="20882" href="Iterative.Sets.html#20327" class="Bound">IH</a> <a id="20885" class="Symbol">(</a><a id="20886" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20895" href="Iterative.Sets.html#20325" class="Bound">A</a> <a id="20897" href="Iterative.Sets.html#20878" class="Bound">a</a><a id="20898" class="Symbol">)</a> <a id="20900" class="Symbol">(</a><a id="20901" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="20912" href="Iterative.Sets.html#20325" class="Bound">A</a> <a id="20914" href="Iterative.Sets.html#20878" class="Bound">a</a><a id="20915" class="Symbol">)))</a>

  <a id="20922" href="Iterative.Sets.html#20922" class="Function">𝕍-is-retract-of-𝕄</a> <a id="20940" class="Symbol">:</a> <a id="20942" href="UF.Retracts.html#1303" class="Function Operator">retract</a> <a id="20950" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="20952" href="UF.Retracts.html#1303" class="Function Operator">of</a> <a id="20955" href="Iterative.Multisets.html#690" class="Function">𝕄</a>
  <a id="20959" href="Iterative.Sets.html#20922" class="Function">𝕍-is-retract-of-𝕄</a> <a id="20977" class="Symbol">=</a> <a id="20979" href="Iterative.Sets.html#20010" class="Function">𝕄-to-𝕍</a> <a id="20986" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
                      <a id="21010" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="21026" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
                      <a id="21050" href="UF.Base.html#10649" class="Function">happly</a> <a id="21057" href="Iterative.Sets.html#20065" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a>

<a id="21092" class="Markup">\end{code}</a><a id="21102" class="Background">
</a></pre></body></html>