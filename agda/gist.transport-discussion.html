<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>gist.transport-discussion</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Marc Bezem, Thierry Coquand, Peter Dybjer, Martin Escardo
18th March 2025.

Discussion about whether a certain transport can be performed more
easily using univalence than &quot;by hand&quot;. In particular, does
cumulativity help?

This discussion is inconclusive for the moment.

</a><a id="273" class="Markup">\begin{code}</a>

<a id="287" class="Symbol">{-#</a> <a id="291" class="Keyword">OPTIONS</a> <a id="299" class="Pragma">--safe</a> <a id="306" class="Pragma">--without-K</a> <a id="318" class="Symbol">#-}</a>

<a id="323" class="Keyword">module</a> <a id="330" href="gist.transport-discussion.html" class="Module">gist.transport-discussion</a> <a id="356" class="Keyword">where</a>

<a id="363" class="Keyword">open</a> <a id="368" class="Keyword">import</a> <a id="375" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="388" class="Keyword">open</a> <a id="393" class="Keyword">import</a> <a id="400" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="409" class="Keyword">open</a> <a id="414" class="Keyword">import</a> <a id="421" href="UF.FunExt.html" class="Module">UF.FunExt</a>
<a id="431" class="Keyword">open</a> <a id="436" class="Keyword">import</a> <a id="443" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>
<a id="460" class="Keyword">open</a> <a id="465" class="Keyword">import</a> <a id="472" href="UF.Univalence.html" class="Module">UF.Univalence</a>
<a id="486" class="Keyword">open</a> <a id="491" class="Keyword">import</a> <a id="498" href="UF.UniverseEmbedding.html" class="Module">UF.UniverseEmbedding</a>
<a id="519" class="Keyword">open</a> <a id="524" class="Keyword">import</a> <a id="531" href="Ordinals.Type.html" class="Module">Ordinals.Type</a>
<a id="545" class="Keyword">open</a> <a id="550" class="Keyword">import</a> <a id="557" href="Ordinals.Underlying.html" class="Module">Ordinals.Underlying</a>
<a id="577" class="Keyword">open</a> <a id="582" class="Keyword">import</a> <a id="589" href="Ordinals.Equivalence.html" class="Module">Ordinals.Equivalence</a>

<a id="611" class="Markup">\end{code}</a><a id="621" class="Background">

The following transport is performed by hand in the following imported
module.

</a><a id="703" class="Markup">\begin{code}</a>

<a id="717" class="Keyword">module</a> <a id="724" href="gist.transport-discussion.html#724" class="Module">_</a> <a id="726" class="Symbol">(</a><a id="727" href="gist.transport-discussion.html#727" class="Bound">fe</a> <a id="730" class="Symbol">:</a> <a id="732" href="UF.FunExt.html#995" class="Function">FunExt</a><a id="738" class="Symbol">)</a> <a id="740" class="Keyword">where</a>

 <a id="748" class="Keyword">open</a> <a id="753" class="Keyword">import</a> <a id="760" href="Ordinals.WellOrderTransport.html" class="Module">Ordinals.WellOrderTransport</a> <a id="788" href="gist.transport-discussion.html#727" class="Bound">fe</a>

 <a id="793" href="gist.transport-discussion.html#793" class="Function">_</a> <a id="795" class="Symbol">:</a> <a id="797" class="Symbol">(</a><a id="798" href="gist.transport-discussion.html#798" class="Bound">X</a> <a id="800" class="Symbol">:</a> <a id="802" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a> <a id="804" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="806" class="Symbol">)</a> <a id="808" class="Symbol">(</a><a id="809" href="gist.transport-discussion.html#809" class="Bound">α</a> <a id="811" class="Symbol">:</a> <a id="813" href="Ordinals.Type.html#600" class="Function">Ordinal</a> <a id="821" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a><a id="822" class="Symbol">)</a>
   <a id="827" class="Symbol">→</a> <a id="829" href="gist.transport-discussion.html#798" class="Bound">X</a> <a id="831" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="833" href="Ordinals.Underlying.html#315" class="Field Operator">⟨</a> <a id="835" href="gist.transport-discussion.html#809" class="Bound">α</a> <a id="837" href="Ordinals.Underlying.html#315" class="Field Operator">⟩</a>
   <a id="842" class="Symbol">→</a> <a id="844" href="Ordinals.WellOrderTransport.html#9964" class="Function">resizable-order</a> <a id="860" href="gist.transport-discussion.html#809" class="Bound">α</a> <a id="862" href="MLTT.Universes.html#3834" class="Generalizable">𝓤</a>
   <a id="867" class="Symbol">→</a> <a id="869" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="871" href="gist.transport-discussion.html#871" class="Bound">s</a> <a id="873" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="875" href="Ordinals.Type.html#498" class="Function">OrdinalStructure</a> <a id="892" href="gist.transport-discussion.html#798" class="Bound">X</a> <a id="894" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="896" class="Symbol">(</a><a id="897" href="gist.transport-discussion.html#798" class="Bound">X</a> <a id="899" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="901" href="gist.transport-discussion.html#871" class="Bound">s</a><a id="902" class="Symbol">)</a> <a id="904" href="Ordinals.Equivalence.html#3337" class="Function Operator">≃ₒ</a> <a id="907" href="gist.transport-discussion.html#809" class="Bound">α</a>
 <a id="910" class="Symbol">_</a> <a id="912" class="Symbol">=</a> <a id="914" href="Ordinals.WellOrderTransport.html#10151" class="Function">transfer-structure</a>

<a id="934" class="Markup">\end{code}</a><a id="944" class="Background">

Can it be done, instead, using univalence in the absence of
cumulativity? If not, would cumulativity help?

We consider a simplified version of the problem to reduce labour. We
could even remove the requirement that there is at most one edge
between any two vertices, but this is useful to prove a no-go theorem
below. We could also require that the type V of vertices is a set, but
we try to keep things as simple as possible.

</a><a id="1375" class="Markup">\begin{code}</a>

<a id="reflexive-structure"></a><a id="1389" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="1409" class="Symbol">:</a> <a id="1411" class="Symbol">(</a><a id="1412" href="gist.transport-discussion.html#1412" class="Bound">𝓦</a> <a id="1414" class="Symbol">:</a> <a id="1416" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="1424" class="Symbol">)</a> <a id="1426" class="Symbol">→</a> <a id="1428" href="MLTT.Universes.html#3840" class="Generalizable">𝓣</a> <a id="1430" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>  <a id="1433" class="Symbol">→</a> <a id="1435" href="gist.transport-discussion.html#1412" class="Bound">𝓦</a> <a id="1437" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a> <a id="1439" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="1441" href="MLTT.Universes.html#3840" class="Generalizable">𝓣</a> <a id="1443" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="1445" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="1465" href="gist.transport-discussion.html#1465" class="Bound">𝓦</a> <a id="1467" href="gist.transport-discussion.html#1467" class="Bound">V</a> <a id="1469" class="Symbol">=</a> <a id="1471" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="1473" href="gist.transport-discussion.html#1473" class="Bound Operator">_⇒_</a> <a id="1477" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="1479" class="Symbol">(</a><a id="1480" href="gist.transport-discussion.html#1467" class="Bound">V</a> <a id="1482" class="Symbol">→</a> <a id="1484" href="gist.transport-discussion.html#1467" class="Bound">V</a> <a id="1486" class="Symbol">→</a> <a id="1488" href="gist.transport-discussion.html#1465" class="Bound">𝓦</a> <a id="1490" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1492" class="Symbol">)</a>
                                 <a id="1527" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="1529" class="Symbol">((</a><a id="1531" href="gist.transport-discussion.html#1531" class="Bound">v</a> <a id="1533" class="Symbol">:</a> <a id="1535" href="gist.transport-discussion.html#1467" class="Bound">V</a><a id="1536" class="Symbol">)</a> <a id="1538" class="Symbol">→</a> <a id="1540" href="gist.transport-discussion.html#1531" class="Bound">v</a> <a id="1542" href="gist.transport-discussion.html#1473" class="Bound Operator">⇒</a> <a id="1544" href="gist.transport-discussion.html#1531" class="Bound">v</a><a id="1545" class="Symbol">)</a>
                                 <a id="1580" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="1582" class="Symbol">((</a><a id="1584" href="gist.transport-discussion.html#1584" class="Bound">v</a> <a id="1586" href="gist.transport-discussion.html#1586" class="Bound">v&#39;</a> <a id="1589" class="Symbol">:</a> <a id="1591" href="gist.transport-discussion.html#1467" class="Bound">V</a><a id="1592" class="Symbol">)</a> <a id="1594" class="Symbol">→</a> <a id="1596" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="1604" class="Symbol">(</a><a id="1605" href="gist.transport-discussion.html#1584" class="Bound">v</a> <a id="1607" href="gist.transport-discussion.html#1473" class="Bound Operator">⇒</a> <a id="1609" href="gist.transport-discussion.html#1586" class="Bound">v&#39;</a><a id="1611" class="Symbol">))</a>

<a id="Reflexive-Graph"></a><a id="1615" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="1631" class="Symbol">:</a> <a id="1633" class="Symbol">(</a><a id="1634" href="gist.transport-discussion.html#1634" class="Bound">𝓦</a> <a id="1636" href="gist.transport-discussion.html#1636" class="Bound">𝓣</a> <a id="1638" class="Symbol">:</a> <a id="1640" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="1648" class="Symbol">)</a> <a id="1650" class="Symbol">→</a> <a id="1652" class="Symbol">(</a><a id="1653" href="gist.transport-discussion.html#1634" class="Bound">𝓦</a> <a id="1655" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="1657" href="gist.transport-discussion.html#1636" class="Bound">𝓣</a><a id="1658" class="Symbol">)</a><a id="1659" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a> <a id="1661" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="1663" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="1679" href="gist.transport-discussion.html#1679" class="Bound">𝓦</a> <a id="1681" href="gist.transport-discussion.html#1681" class="Bound">𝓣</a> <a id="1683" class="Symbol">=</a> <a id="1685" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="1687" href="gist.transport-discussion.html#1687" class="Bound">V</a> <a id="1689" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="1691" href="gist.transport-discussion.html#1681" class="Bound">𝓣</a> <a id="1693" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="1695" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="1697" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="1717" href="gist.transport-discussion.html#1679" class="Bound">𝓦</a> <a id="1719" href="gist.transport-discussion.html#1687" class="Bound">V</a>

<a id="1722" class="Markup">\end{code}</a><a id="1732" class="Background">

We now formulate the notion of reflexive graph equivalence, for the
above notion of reflexive graph. Using SIP, and assuming univalence,
we can show that for graphs in the same universes, identity is
canonically equivalent to this notion of reflexive graph
equivalence. But we won&#39;t bother to prove this, at least not for the
moment.

</a><a id="2069" class="Markup">\begin{code}</a>

<a id="_≃ʳᵍ_"></a><a id="2083" href="gist.transport-discussion.html#2083" class="Function Operator">_≃ʳᵍ_</a> <a id="2089" class="Symbol">:</a> <a id="2091" class="Symbol">{</a><a id="2092" href="gist.transport-discussion.html#2092" class="Bound">𝓦</a> <a id="2094" href="gist.transport-discussion.html#2094" class="Bound">𝓣</a> <a id="2096" href="gist.transport-discussion.html#2096" class="Bound">𝓦&#39;</a> <a id="2099" href="gist.transport-discussion.html#2099" class="Bound">𝓣&#39;</a> <a id="2102" class="Symbol">:</a> <a id="2104" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="2112" class="Symbol">}</a>
      <a id="2120" class="Symbol">→</a> <a id="2122" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="2138" href="gist.transport-discussion.html#2092" class="Bound">𝓦</a> <a id="2140" href="gist.transport-discussion.html#2094" class="Bound">𝓣</a> <a id="2142" class="Symbol">→</a> <a id="2144" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="2160" href="gist.transport-discussion.html#2096" class="Bound">𝓦&#39;</a> <a id="2163" href="gist.transport-discussion.html#2099" class="Bound">𝓣&#39;</a> <a id="2166" class="Symbol">→</a> <a id="2168" href="gist.transport-discussion.html#2092" class="Bound">𝓦</a> <a id="2170" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2172" href="gist.transport-discussion.html#2094" class="Bound">𝓣</a> <a id="2174" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2176" href="gist.transport-discussion.html#2096" class="Bound">𝓦&#39;</a> <a id="2179" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2181" href="gist.transport-discussion.html#2099" class="Bound">𝓣&#39;</a> <a id="2184" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="2186" class="Symbol">(</a><a id="2187" href="gist.transport-discussion.html#2187" class="Bound">V</a> <a id="2189" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2191" href="gist.transport-discussion.html#2191" class="Bound Operator">_⇒_</a> <a id="2195" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2197" class="Symbol">_)</a> <a id="2200" href="gist.transport-discussion.html#2083" class="Function Operator">≃ʳᵍ</a> <a id="2204" class="Symbol">(</a><a id="2205" href="gist.transport-discussion.html#2205" class="Bound">V&#39;</a> <a id="2208" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2210" href="gist.transport-discussion.html#2210" class="Bound Operator">_⇒&#39;_</a> <a id="2215" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2217" class="Symbol">_)</a>
 <a id="2221" class="Symbol">=</a> <a id="2223" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="2225" href="gist.transport-discussion.html#2225" class="Bound">f</a> <a id="2227" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="2229" class="Symbol">(</a><a id="2230" href="gist.transport-discussion.html#2187" class="Bound">V</a> <a id="2232" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="2234" href="gist.transport-discussion.html#2205" class="Bound">V&#39;</a><a id="2236" class="Symbol">)</a><a id="2237" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="2239" class="Symbol">((</a><a id="2241" href="gist.transport-discussion.html#2241" class="Bound">v₀</a> <a id="2244" href="gist.transport-discussion.html#2244" class="Bound">v₁</a> <a id="2247" class="Symbol">:</a> <a id="2249" href="gist.transport-discussion.html#2205" class="Bound">V&#39;</a><a id="2251" class="Symbol">)</a> <a id="2253" class="Symbol">→</a> <a id="2255" class="Symbol">(</a><a id="2256" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="2258" href="gist.transport-discussion.html#2225" class="Bound">f</a> <a id="2260" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="2264" href="gist.transport-discussion.html#2241" class="Bound">v₀</a> <a id="2267" href="gist.transport-discussion.html#2191" class="Bound Operator">⇒</a> <a id="2269" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="2271" href="gist.transport-discussion.html#2225" class="Bound">f</a> <a id="2273" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="2277" href="gist.transport-discussion.html#2244" class="Bound">v₁</a><a id="2279" class="Symbol">)</a> <a id="2281" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="2283" class="Symbol">(</a><a id="2284" href="gist.transport-discussion.html#2241" class="Bound">v₀</a> <a id="2287" href="gist.transport-discussion.html#2210" class="Bound Operator">⇒&#39;</a> <a id="2290" href="gist.transport-discussion.html#2244" class="Bound">v₁</a><a id="2292" class="Symbol">))</a>

<a id="2296" class="Markup">\end{code}</a><a id="2306" class="Background">

So here is our experimental discussion.

</a><a id="2349" class="Markup">\begin{code}</a>

<a id="2363" class="Keyword">module</a> <a id="discussion"></a><a id="2370" href="gist.transport-discussion.html#2370" class="Module">discussion</a>
        <a id="2389" class="Symbol">(</a><a id="2390" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2392" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="2394" class="Symbol">:</a> <a id="2396" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="2404" class="Symbol">)</a>
        <a id="2414" class="Symbol">(</a><a id="2415" href="gist.transport-discussion.html#2415" class="Bound">𝓐</a><a id="2416" class="Symbol">@(</a><a id="2418" href="gist.transport-discussion.html#2418" class="Bound">A</a> <a id="2420" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2422" href="gist.transport-discussion.html#2422" class="Bound Operator">_⇒_</a> <a id="2426" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2428" href="gist.transport-discussion.html#2428" class="Bound">⇒-refl</a> <a id="2435" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2437" href="gist.transport-discussion.html#2437" class="Bound">⇒-is-prop-valued</a><a id="2453" class="Symbol">)</a> <a id="2455" class="Symbol">:</a> <a id="2457" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="2473" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="2475" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2476" class="Symbol">)</a>
        <a id="2486" class="Symbol">(</a><a id="2487" href="gist.transport-discussion.html#2487" class="Bound Operator">_⇒&#39;_</a> <a id="2492" class="Symbol">:</a> <a id="2494" href="gist.transport-discussion.html#2418" class="Bound">A</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="gist.transport-discussion.html#2418" class="Bound">A</a> <a id="2500" class="Symbol">→</a> <a id="2502" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2504" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2506" class="Symbol">)</a>
        <a id="2516" class="Symbol">(</a><a id="2517" href="gist.transport-discussion.html#2517" class="Bound">resizing-assumption</a> <a id="2537" class="Symbol">:</a> <a id="2539" class="Symbol">(</a><a id="2540" href="gist.transport-discussion.html#2540" class="Bound">a</a> <a id="2542" href="gist.transport-discussion.html#2542" class="Bound">b</a> <a id="2544" class="Symbol">:</a> <a id="2546" href="gist.transport-discussion.html#2418" class="Bound">A</a><a id="2547" class="Symbol">)</a> <a id="2549" class="Symbol">→</a> <a id="2551" class="Symbol">(</a><a id="2552" href="gist.transport-discussion.html#2540" class="Bound">a</a> <a id="2554" href="gist.transport-discussion.html#2422" class="Bound Operator">⇒</a> <a id="2556" href="gist.transport-discussion.html#2542" class="Bound">b</a><a id="2557" class="Symbol">)</a> <a id="2559" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="2561" class="Symbol">(</a><a id="2562" href="gist.transport-discussion.html#2540" class="Bound">a</a> <a id="2564" href="gist.transport-discussion.html#2487" class="Bound Operator">⇒&#39;</a> <a id="2567" href="gist.transport-discussion.html#2542" class="Bound">b</a><a id="2568" class="Symbol">))</a>
        <a id="2579" class="Symbol">(</a><a id="2580" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="2582" class="Symbol">:</a> <a id="2584" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2586" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2588" class="Symbol">)</a>
        <a id="2598" class="Symbol">(</a><a id="2599" href="gist.transport-discussion.html#2599" class="Bound">f</a> <a id="2601" class="Symbol">:</a> <a id="2603" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="2605" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="2607" href="gist.transport-discussion.html#2418" class="Bound">A</a><a id="2608" class="Symbol">)</a>
        <a id="2618" class="Symbol">(</a><a id="2619" href="gist.transport-discussion.html#2619" class="Bound">ua</a> <a id="2622" class="Symbol">:</a> <a id="2624" href="UF.Univalence.html#412" class="Function">is-univalent</a> <a id="2637" class="Symbol">(</a><a id="2638" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2640" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2642" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2643" class="Symbol">))</a>
        <a id="2654" class="Symbol">(</a><a id="2655" href="gist.transport-discussion.html#2655" class="Bound">sorry</a> <a id="2661" class="Symbol">:</a> <a id="2663" class="Symbol">{</a><a id="2664" href="gist.transport-discussion.html#2664" class="Bound">𝓦</a> <a id="2666" class="Symbol">:</a> <a id="2668" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="2676" class="Symbol">}</a> <a id="2678" class="Symbol">{</a><a id="2679" href="gist.transport-discussion.html#2679" class="Bound">S</a> <a id="2681" class="Symbol">:</a> <a id="2683" href="gist.transport-discussion.html#2664" class="Bound">𝓦</a> <a id="2685" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="2687" class="Symbol">}</a> <a id="2689" class="Symbol">→</a> <a id="2691" href="gist.transport-discussion.html#2679" class="Bound">S</a><a id="2692" class="Symbol">)</a>
      <a id="2700" class="Keyword">where</a>

<a id="2707" class="Markup">\end{code}</a><a id="2717" class="Background">

We don&#39;t have cumulativity, so we lift explicitly.

</a><a id="2771" class="Markup">\begin{code}</a>

 <a id="discussion.X⁺"></a><a id="2786" href="gist.transport-discussion.html#2786" class="Function">X⁺</a> <a id="discussion.A⁺"></a><a id="2789" href="gist.transport-discussion.html#2789" class="Function">A⁺</a> <a id="2792" class="Symbol">:</a> <a id="2794" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2796" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2798" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="2800" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
 <a id="2803" href="gist.transport-discussion.html#2786" class="Function">X⁺</a> <a id="2806" class="Symbol">=</a> <a id="2808" href="UF.UniverseEmbedding.html#2936" class="Function">Lift</a> <a id="2813" class="Symbol">(</a><a id="2814" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2816" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2818" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2819" class="Symbol">)</a> <a id="2821" href="gist.transport-discussion.html#2580" class="Bound">X</a>
 <a id="2824" href="gist.transport-discussion.html#2789" class="Function">A⁺</a> <a id="2827" class="Symbol">=</a> <a id="2829" href="UF.UniverseEmbedding.html#2936" class="Function">Lift</a> <a id="2834" class="Symbol">(</a><a id="2835" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2837" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2839" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2840" class="Symbol">)</a> <a id="2842" href="gist.transport-discussion.html#2418" class="Bound">A</a>

 <a id="discussion.II"></a><a id="2846" href="gist.transport-discussion.html#2846" class="Function">II</a> <a id="2849" class="Symbol">:</a> <a id="2851" href="gist.transport-discussion.html#2786" class="Function">X⁺</a> <a id="2854" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="2856" href="gist.transport-discussion.html#2789" class="Function">A⁺</a>
 <a id="2860" href="gist.transport-discussion.html#2846" class="Function">II</a> <a id="2863" class="Symbol">=</a> <a id="2865" href="gist.transport-discussion.html#2786" class="Function">X⁺</a> <a id="2868" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="2871" href="UF.UniverseEmbedding.html#3551" class="Function">Lift-≃</a> <a id="2878" class="Symbol">(</a><a id="2879" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2881" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2883" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2884" class="Symbol">)</a> <a id="2886" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="2888" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="2896" href="gist.transport-discussion.html#2580" class="Bound">X</a>  <a id="2899" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="2902" href="gist.transport-discussion.html#2599" class="Bound">f</a> <a id="2904" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="2912" href="gist.transport-discussion.html#2418" class="Bound">A</a>  <a id="2915" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="2918" href="UF.UniverseEmbedding.html#3638" class="Function">≃-Lift</a> <a id="2925" class="Symbol">(</a><a id="2926" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="2928" href="Agda.Primitive.html#961" class="Primitive Operator">⊔</a> <a id="2930" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="2931" class="Symbol">)</a> <a id="2933" href="gist.transport-discussion.html#2418" class="Bound">A</a> <a id="2935" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="2943" href="gist.transport-discussion.html#2789" class="Function">A⁺</a> <a id="2946" href="UF.Equiv.html#2815" class="Function Operator">■</a>

<a id="2949" class="Markup">\end{code}</a><a id="2959" class="Background">

The following apologies can be filled by transporting by hand as in
the function `transfer-structure` mentioned above.

Presumably they don&#39;t need proof in a universe-cumulative system,
where X⁺ and A⁺ are simply X and A, so that we have false apologies.

</a><a id="3217" class="Markup">\begin{code}</a>

 <a id="discussion._⇒⁺_"></a><a id="3232" href="gist.transport-discussion.html#3232" class="Function Operator">_⇒⁺_</a> <a id="3237" class="Symbol">:</a> <a id="3239" href="gist.transport-discussion.html#2789" class="Function">A⁺</a> <a id="3242" class="Symbol">→</a> <a id="3244" href="gist.transport-discussion.html#2789" class="Function">A⁺</a> <a id="3247" class="Symbol">→</a> <a id="3249" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="3251" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
 <a id="3254" href="gist.transport-discussion.html#3254" class="Bound">a</a> <a id="3256" href="gist.transport-discussion.html#3232" class="Function Operator">⇒⁺</a> <a id="3259" href="gist.transport-discussion.html#3259" class="Bound">b</a> <a id="3261" class="Symbol">=</a> <a id="3263" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.⇒⁺-refl"></a><a id="3271" href="gist.transport-discussion.html#3271" class="Function">⇒⁺-refl</a> <a id="3279" class="Symbol">:</a> <a id="3281" class="Symbol">(</a><a id="3282" href="gist.transport-discussion.html#3282" class="Bound">a</a> <a id="3284" class="Symbol">:</a> <a id="3286" href="gist.transport-discussion.html#2789" class="Function">A⁺</a><a id="3288" class="Symbol">)</a> <a id="3290" class="Symbol">→</a> <a id="3292" href="gist.transport-discussion.html#3282" class="Bound">a</a> <a id="3294" href="gist.transport-discussion.html#3232" class="Function Operator">⇒⁺</a> <a id="3297" href="gist.transport-discussion.html#3282" class="Bound">a</a>
 <a id="3300" href="gist.transport-discussion.html#3271" class="Function">⇒⁺-refl</a> <a id="3308" class="Symbol">=</a> <a id="3310" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.⇒⁺-is-prop-valued"></a><a id="3318" href="gist.transport-discussion.html#3318" class="Function">⇒⁺-is-prop-valued</a> <a id="3336" class="Symbol">:</a> <a id="3338" class="Symbol">(</a><a id="3339" href="gist.transport-discussion.html#3339" class="Bound">a</a> <a id="3341" href="gist.transport-discussion.html#3341" class="Bound">b</a> <a id="3343" class="Symbol">:</a> <a id="3345" href="gist.transport-discussion.html#2789" class="Function">A⁺</a><a id="3347" class="Symbol">)</a> <a id="3349" class="Symbol">→</a> <a id="3351" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="3359" class="Symbol">(</a><a id="3360" href="gist.transport-discussion.html#3339" class="Bound">a</a> <a id="3362" href="gist.transport-discussion.html#3232" class="Function Operator">⇒⁺</a> <a id="3365" href="gist.transport-discussion.html#3341" class="Bound">b</a><a id="3366" class="Symbol">)</a>
 <a id="3369" href="gist.transport-discussion.html#3318" class="Function">⇒⁺-is-prop-valued</a> <a id="3387" class="Symbol">=</a> <a id="3389" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.rsₐ"></a><a id="3397" href="gist.transport-discussion.html#3397" class="Function">rsₐ</a> <a id="3401" class="Symbol">:</a> <a id="3403" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="3423" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="3425" href="gist.transport-discussion.html#2789" class="Function">A⁺</a>
 <a id="3429" href="gist.transport-discussion.html#3397" class="Function">rsₐ</a> <a id="3433" class="Symbol">=</a> <a id="3435" href="gist.transport-discussion.html#3232" class="Function Operator">_⇒⁺_</a> <a id="3440" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3442" href="gist.transport-discussion.html#3271" class="Function">⇒⁺-refl</a> <a id="3450" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3452" href="gist.transport-discussion.html#3318" class="Function">⇒⁺-is-prop-valued</a>

 <a id="discussion.I"></a><a id="3472" href="gist.transport-discussion.html#3472" class="Function">I</a> <a id="3474" class="Symbol">:</a> <a id="3476" href="gist.transport-discussion.html#2786" class="Function">X⁺</a> <a id="3479" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3481" href="gist.transport-discussion.html#2789" class="Function">A⁺</a>
 <a id="3485" href="gist.transport-discussion.html#3472" class="Function">I</a> <a id="3487" class="Symbol">=</a> <a id="3489" href="UF.Univalence.html#905" class="Function">eqtoid</a> <a id="3496" href="gist.transport-discussion.html#2619" class="Bound">ua</a> <a id="3499" class="Symbol">(</a><a id="3500" href="gist.transport-discussion.html#2786" class="Function">X⁺</a><a id="3502" class="Symbol">)</a> <a id="3504" class="Symbol">(</a><a id="3505" href="gist.transport-discussion.html#2789" class="Function">A⁺</a><a id="3507" class="Symbol">)</a> <a id="3509" href="gist.transport-discussion.html#2846" class="Function">II</a>

 <a id="discussion.rsₓ"></a><a id="3514" href="gist.transport-discussion.html#3514" class="Function">rsₓ</a> <a id="3518" class="Symbol">:</a> <a id="3520" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="3540" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a> <a id="3542" href="gist.transport-discussion.html#2786" class="Function">X⁺</a>
 <a id="3546" href="gist.transport-discussion.html#3514" class="Function">rsₓ</a> <a id="3550" class="Symbol">=</a> <a id="3552" href="MLTT.Id.html#1259" class="Function">transport⁻¹</a> <a id="3564" class="Symbol">(</a><a id="3565" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="3585" href="gist.transport-discussion.html#2392" class="Bound">𝓥</a><a id="3586" class="Symbol">)</a> <a id="3588" href="gist.transport-discussion.html#3472" class="Function">I</a> <a id="3590" href="gist.transport-discussion.html#3397" class="Function">rsₐ</a>

<a id="3595" class="Markup">\end{code}</a><a id="3605" class="Background">

But there is limit to the number of false apologies one can make.

The following needs more than cumulativity. And this is why we have
the above assumptions `_⇒&#39;_` and `resizing-assumption` (which
correspond to the `resizable-order` condition in `transfer-structure`).
Without them, we get a no-go theorem (see `resizing-taboo` below).

So the following are genuine apologies: They can&#39;t just hold on the
nose by cumulativity.

</a><a id="4035" class="Markup">\begin{code}</a>

 <a id="discussion._⇒ₓ_"></a><a id="4050" href="gist.transport-discussion.html#4050" class="Function Operator">_⇒ₓ_</a> <a id="4055" class="Symbol">:</a> <a id="4057" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="4059" class="Symbol">→</a> <a id="4061" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="4063" class="Symbol">→</a> <a id="4065" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="4067" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
 <a id="4070" href="gist.transport-discussion.html#4050" class="Function Operator">_⇒ₓ_</a> <a id="4075" class="Symbol">=</a> <a id="4077" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.⇒ₓ-refl"></a><a id="4085" href="gist.transport-discussion.html#4085" class="Function">⇒ₓ-refl</a> <a id="4093" class="Symbol">:</a> <a id="4095" class="Symbol">(</a><a id="4096" href="gist.transport-discussion.html#4096" class="Bound">x</a> <a id="4098" class="Symbol">:</a> <a id="4100" href="gist.transport-discussion.html#2580" class="Bound">X</a><a id="4101" class="Symbol">)</a> <a id="4103" class="Symbol">→</a> <a id="4105" href="gist.transport-discussion.html#4096" class="Bound">x</a> <a id="4107" href="gist.transport-discussion.html#4050" class="Function Operator">⇒ₓ</a> <a id="4110" href="gist.transport-discussion.html#4096" class="Bound">x</a>
 <a id="4113" href="gist.transport-discussion.html#4085" class="Function">⇒ₓ-refl</a> <a id="4121" class="Symbol">=</a> <a id="4123" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.⇒ₓ-is-prop-valued"></a><a id="4131" href="gist.transport-discussion.html#4131" class="Function">⇒ₓ-is-prop-valued</a> <a id="4149" class="Symbol">:</a> <a id="4151" class="Symbol">(</a><a id="4152" href="gist.transport-discussion.html#4152" class="Bound">x</a> <a id="4154" href="gist.transport-discussion.html#4154" class="Bound">y</a> <a id="4156" class="Symbol">:</a> <a id="4158" href="gist.transport-discussion.html#2580" class="Bound">X</a><a id="4159" class="Symbol">)</a> <a id="4161" class="Symbol">→</a> <a id="4163" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="4171" class="Symbol">(</a><a id="4172" href="gist.transport-discussion.html#4152" class="Bound">x</a> <a id="4174" href="gist.transport-discussion.html#4050" class="Function Operator">⇒ₓ</a> <a id="4177" href="gist.transport-discussion.html#4154" class="Bound">y</a><a id="4178" class="Symbol">)</a>
 <a id="4181" href="gist.transport-discussion.html#4131" class="Function">⇒ₓ-is-prop-valued</a> <a id="4199" class="Symbol">=</a> <a id="4201" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

 <a id="discussion.𝓧"></a><a id="4209" href="gist.transport-discussion.html#4209" class="Function">𝓧</a> <a id="4211" class="Symbol">:</a> <a id="4213" href="gist.transport-discussion.html#1615" class="Function">Reflexive-Graph</a> <a id="4229" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a> <a id="4231" href="gist.transport-discussion.html#2390" class="Bound">𝓤</a>
 <a id="4234" href="gist.transport-discussion.html#4209" class="Function">𝓧</a> <a id="4236" class="Symbol">=</a> <a id="4238" href="gist.transport-discussion.html#2580" class="Bound">X</a> <a id="4240" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4242" href="gist.transport-discussion.html#4050" class="Function Operator">_⇒ₓ_</a> <a id="4247" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4249" href="gist.transport-discussion.html#4085" class="Function">⇒ₓ-refl</a> <a id="4257" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4259" href="gist.transport-discussion.html#4131" class="Function">⇒ₓ-is-prop-valued</a>

 <a id="discussion.transfer-structure-analogue"></a><a id="4279" href="gist.transport-discussion.html#4279" class="Function">transfer-structure-analogue</a> <a id="4307" class="Symbol">:</a> <a id="4309" href="gist.transport-discussion.html#4209" class="Function">𝓧</a> <a id="4311" href="gist.transport-discussion.html#2083" class="Function Operator">≃ʳᵍ</a> <a id="4315" href="gist.transport-discussion.html#2415" class="Bound">𝓐</a>
 <a id="4318" href="gist.transport-discussion.html#4279" class="Function">transfer-structure-analogue</a> <a id="4346" class="Symbol">=</a> <a id="4348" href="gist.transport-discussion.html#2655" class="Bound">sorry</a>

<a id="4355" class="Markup">\end{code}</a><a id="4365" class="Background">

Of course all the apologies can be removed, even without cumulativity,
by following the strategy of `transfer-structure` by transporting
structure and properties by hand, without univalence.

The question here is whether univalence, perhaps with the help of
cumulativity, can avoid transport by hand.

We now formulate and prove the no-go theorem. Because it holds in the
absence of cumulativity, it also holds in its presence.

The following type is a distilled version of the type of the function
`transfer-structure`, but without the `resizable-order` assumption.

</a><a id="4935" class="Markup">\begin{code}</a>

<a id="Transport-Assumption"></a><a id="4949" href="gist.transport-discussion.html#4949" class="Function">Transport-Assumption</a> <a id="4970" class="Symbol">:</a> <a id="4972" href="Agda.Primitive.html#512" class="Primitive">𝓤ω</a>
<a id="4975" href="gist.transport-discussion.html#4949" class="Function">Transport-Assumption</a> <a id="4996" class="Symbol">=</a>
   <a id="5001" class="Symbol">{</a><a id="5002" href="gist.transport-discussion.html#5002" class="Bound">𝓤</a> <a id="5004" href="gist.transport-discussion.html#5004" class="Bound">𝓥</a> <a id="5006" class="Symbol">:</a> <a id="5008" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="5016" class="Symbol">}</a> <a id="5018" class="Symbol">(</a><a id="5019" href="gist.transport-discussion.html#5019" class="Bound">X</a> <a id="5021" class="Symbol">:</a> <a id="5023" href="gist.transport-discussion.html#5002" class="Bound">𝓤</a> <a id="5025" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="5027" class="Symbol">)</a> <a id="5029" class="Symbol">(</a><a id="5030" href="gist.transport-discussion.html#5030" class="Bound">A</a> <a id="5032" class="Symbol">:</a> <a id="5034" href="gist.transport-discussion.html#5004" class="Bound">𝓥</a> <a id="5036" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="5038" class="Symbol">)</a>
   <a id="5043" class="Symbol">(</a><a id="5044" href="gist.transport-discussion.html#5044" class="Bound">f</a> <a id="5046" class="Symbol">:</a> <a id="5048" href="gist.transport-discussion.html#5019" class="Bound">X</a> <a id="5050" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="5052" href="gist.transport-discussion.html#5030" class="Bound">A</a><a id="5053" class="Symbol">)</a>
   <a id="5058" class="Symbol">(</a><a id="5059" href="gist.transport-discussion.html#5059" class="Bound">rsₐ</a> <a id="5063" class="Symbol">:</a> <a id="5065" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="5085" href="gist.transport-discussion.html#5004" class="Bound">𝓥</a> <a id="5087" href="gist.transport-discussion.html#5030" class="Bound">A</a><a id="5088" class="Symbol">)</a>
 <a id="5091" class="Symbol">→</a> <a id="5093" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="5095" href="gist.transport-discussion.html#5095" class="Bound">rsₓ</a> <a id="5099" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="5101" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="5121" href="gist.transport-discussion.html#5002" class="Bound">𝓤</a> <a id="5123" href="gist.transport-discussion.html#5019" class="Bound">X</a> <a id="5125" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="5127" class="Symbol">(</a><a id="5128" href="gist.transport-discussion.html#5019" class="Bound">X</a> <a id="5130" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5132" href="gist.transport-discussion.html#5095" class="Bound">rsₓ</a><a id="5135" class="Symbol">)</a> <a id="5137" href="gist.transport-discussion.html#2083" class="Function Operator">≃ʳᵍ</a> <a id="5141" class="Symbol">(</a><a id="5142" href="gist.transport-discussion.html#5030" class="Bound">A</a> <a id="5144" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5146" href="gist.transport-discussion.html#5059" class="Bound">rsₐ</a><a id="5149" class="Symbol">)</a>

<a id="5152" class="Keyword">open</a> <a id="5157" class="Keyword">import</a> <a id="5164" href="UF.Size.html" class="Module">UF.Size</a>
<a id="5172" class="Keyword">open</a> <a id="5177" class="Keyword">import</a> <a id="5184" href="UF.EquivalenceExamples.html" class="Module">UF.EquivalenceExamples</a>

<a id="resizing-taboo"></a><a id="5208" href="gist.transport-discussion.html#5208" class="Function">resizing-taboo</a> <a id="5223" class="Symbol">:</a> <a id="5225" href="gist.transport-discussion.html#4949" class="Function">Transport-Assumption</a> <a id="5246" class="Symbol">→</a> <a id="5248" href="UF.Size.html#2934" class="Function">Propositional-Resizing</a>
<a id="5271" href="gist.transport-discussion.html#5208" class="Function">resizing-taboo</a> <a id="5286" href="gist.transport-discussion.html#5286" class="Bound">t</a> <a id="5288" class="Symbol">{</a><a id="5289" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a><a id="5290" class="Symbol">}</a> <a id="5292" class="Symbol">{</a><a id="5293" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a><a id="5294" class="Symbol">}</a> <a id="5296" class="Symbol">=</a> <a id="5298" href="gist.transport-discussion.html#6430" class="Function">γ</a>
 <a id="5301" class="Keyword">where</a>
  <a id="5309" class="Keyword">module</a> <a id="5316" href="gist.transport-discussion.html#5316" class="Module">_</a> <a id="5318" class="Symbol">(</a><a id="5319" href="gist.transport-discussion.html#5319" class="Bound">P</a> <a id="5321" class="Symbol">:</a> <a id="5323" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a> <a id="5325" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="5327" class="Symbol">)</a> <a id="5329" class="Symbol">(</a><a id="5330" href="gist.transport-discussion.html#5330" class="Bound">P-is-prop</a> <a id="5340" class="Symbol">:</a> <a id="5342" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="5350" href="gist.transport-discussion.html#5319" class="Bound">P</a><a id="5351" class="Symbol">)</a> <a id="5353" class="Keyword">where</a>
   <a id="5362" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="5364" class="Symbol">:</a> <a id="5366" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a> <a id="5368" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
   <a id="5373" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="5375" class="Symbol">=</a> <a id="5377" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="5379" class="Symbol">{</a><a id="5380" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a><a id="5381" class="Symbol">}</a> <a id="5383" href="MLTT.Plus-Type.html#120" class="Datatype Operator">+</a> <a id="5385" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="5387" class="Symbol">{</a><a id="5388" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a><a id="5389" class="Symbol">}</a>

   <a id="5395" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="5397" class="Symbol">:</a> <a id="5399" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a> <a id="5401" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
   <a id="5406" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="5408" class="Symbol">=</a> <a id="5410" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="5412" class="Symbol">{</a><a id="5413" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a><a id="5414" class="Symbol">}</a> <a id="5416" href="MLTT.Plus-Type.html#120" class="Datatype Operator">+</a> <a id="5418" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="5420" class="Symbol">{</a><a id="5421" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a><a id="5422" class="Symbol">}</a>

   <a id="5428" href="gist.transport-discussion.html#5428" class="Function">I</a> <a id="5430" class="Symbol">:</a> <a id="5432" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="5434" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="5436" href="gist.transport-discussion.html#5395" class="Function">A</a>
   <a id="5441" href="gist.transport-discussion.html#5428" class="Function">I</a> <a id="5443" class="Symbol">=</a> <a id="5445" href="UF.EquivalenceExamples.html#10087" class="Function">+-cong</a> <a id="5452" href="UF.EquivalenceExamples.html#8576" class="Function">one-𝟙-only</a> <a id="5463" href="UF.EquivalenceExamples.html#8576" class="Function">one-𝟙-only</a>

   <a id="5478" href="gist.transport-discussion.html#5478" class="Function Operator">_⇒_</a> <a id="5482" class="Symbol">:</a> <a id="5484" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="5486" class="Symbol">→</a> <a id="5488" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="5490" class="Symbol">→</a> <a id="5492" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a> <a id="5494" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
   <a id="5499" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5503" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5505" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5507" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5511" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5513" class="Symbol">=</a> <a id="5515" href="MLTT.Unit.html#129" class="Record">𝟙</a>
   <a id="5520" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5524" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5526" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5528" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5532" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5534" class="Symbol">=</a> <a id="5536" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="5538" class="Comment">-- It&#39;s not important what we choose in this case.</a>
   <a id="5592" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5596" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5598" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5600" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5604" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5606" class="Symbol">=</a> <a id="5608" href="gist.transport-discussion.html#5319" class="Bound">P</a>
   <a id="5613" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5617" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5619" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5621" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5625" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="5627" class="Symbol">=</a> <a id="5629" href="MLTT.Unit.html#129" class="Record">𝟙</a>

   <a id="5635" href="gist.transport-discussion.html#5635" class="Function">⇒-refl</a> <a id="5642" class="Symbol">:</a> <a id="5644" class="Symbol">(</a><a id="5645" href="gist.transport-discussion.html#5645" class="Bound">a</a> <a id="5647" class="Symbol">:</a> <a id="5649" href="gist.transport-discussion.html#5395" class="Function">A</a><a id="5650" class="Symbol">)</a> <a id="5652" class="Symbol">→</a> <a id="5654" href="gist.transport-discussion.html#5645" class="Bound">a</a> <a id="5656" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5658" href="gist.transport-discussion.html#5645" class="Bound">a</a>
   <a id="5663" href="gist.transport-discussion.html#5635" class="Function">⇒-refl</a> <a id="5670" class="Symbol">(</a><a id="5671" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5675" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5676" class="Symbol">)</a> <a id="5678" class="Symbol">=</a> <a id="5680" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a>
   <a id="5685" href="gist.transport-discussion.html#5635" class="Function">⇒-refl</a> <a id="5692" class="Symbol">(</a><a id="5693" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5697" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5698" class="Symbol">)</a> <a id="5700" class="Symbol">=</a> <a id="5702" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a>

   <a id="5708" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a> <a id="5725" class="Symbol">:</a> <a id="5727" class="Symbol">(</a><a id="5728" href="gist.transport-discussion.html#5728" class="Bound">a</a> <a id="5730" href="gist.transport-discussion.html#5730" class="Bound">b</a> <a id="5732" class="Symbol">:</a> <a id="5734" href="gist.transport-discussion.html#5395" class="Function">A</a><a id="5735" class="Symbol">)</a> <a id="5737" class="Symbol">→</a> <a id="5739" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="5747" class="Symbol">(</a><a id="5748" href="gist.transport-discussion.html#5728" class="Bound">a</a> <a id="5750" href="gist.transport-discussion.html#5478" class="Function Operator">⇒</a> <a id="5752" href="gist.transport-discussion.html#5730" class="Bound">b</a><a id="5753" class="Symbol">)</a>
   <a id="5758" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a> <a id="5775" class="Symbol">(</a><a id="5776" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5780" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5781" class="Symbol">)</a> <a id="5783" class="Symbol">(</a><a id="5784" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5788" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5789" class="Symbol">)</a> <a id="5791" class="Symbol">=</a> <a id="5793" href="UF.Subsingletons.html#2858" class="Function">𝟙-is-prop</a>
   <a id="5806" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a> <a id="5823" class="Symbol">(</a><a id="5824" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5828" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5829" class="Symbol">)</a> <a id="5831" class="Symbol">(</a><a id="5832" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5836" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5837" class="Symbol">)</a> <a id="5839" class="Symbol">=</a> <a id="5841" href="UF.Subsingletons.html#2858" class="Function">𝟙-is-prop</a>
   <a id="5854" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a> <a id="5871" class="Symbol">(</a><a id="5872" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5876" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5877" class="Symbol">)</a> <a id="5879" class="Symbol">(</a><a id="5880" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="5884" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5885" class="Symbol">)</a> <a id="5887" class="Symbol">=</a> <a id="5889" href="gist.transport-discussion.html#5330" class="Bound">P-is-prop</a>
   <a id="5902" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a> <a id="5919" class="Symbol">(</a><a id="5920" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5924" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5925" class="Symbol">)</a> <a id="5927" class="Symbol">(</a><a id="5928" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="5932" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="5933" class="Symbol">)</a> <a id="5935" class="Symbol">=</a> <a id="5937" href="UF.Subsingletons.html#2858" class="Function">𝟙-is-prop</a>

   <a id="5951" href="gist.transport-discussion.html#5951" class="Function">rₐ</a> <a id="5954" class="Symbol">:</a> <a id="5956" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="5976" href="gist.transport-discussion.html#5289" class="Bound">𝓥</a> <a id="5978" href="gist.transport-discussion.html#5395" class="Function">A</a>
   <a id="5983" href="gist.transport-discussion.html#5951" class="Function">rₐ</a> <a id="5986" class="Symbol">=</a> <a id="5988" class="Symbol">(</a><a id="5989" href="gist.transport-discussion.html#5478" class="Function Operator">_⇒_</a> <a id="5993" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5995" href="gist.transport-discussion.html#5635" class="Function">⇒-refl</a> <a id="6002" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6004" href="gist.transport-discussion.html#5708" class="Function">⇒-is-prop-valued</a><a id="6020" class="Symbol">)</a>

   <a id="6026" href="gist.transport-discussion.html#6026" class="Function">II</a> <a id="6029" class="Symbol">:</a> <a id="6031" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="6033" href="gist.transport-discussion.html#6033" class="Bound">rₓ</a> <a id="6036" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="6038" href="gist.transport-discussion.html#1389" class="Function">reflexive-structure</a> <a id="6058" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a> <a id="6060" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="6062" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="6064" class="Symbol">(</a><a id="6065" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="6067" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6069" href="gist.transport-discussion.html#6033" class="Bound">rₓ</a><a id="6071" class="Symbol">)</a> <a id="6073" href="gist.transport-discussion.html#2083" class="Function Operator">≃ʳᵍ</a> <a id="6077" class="Symbol">(</a><a id="6078" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="6080" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6082" href="gist.transport-discussion.html#5951" class="Function">rₐ</a><a id="6084" class="Symbol">)</a>
   <a id="6089" href="gist.transport-discussion.html#6026" class="Function">II</a> <a id="6092" class="Symbol">=</a> <a id="6094" href="gist.transport-discussion.html#5286" class="Bound">t</a> <a id="6096" href="gist.transport-discussion.html#5362" class="Function">X</a> <a id="6098" href="gist.transport-discussion.html#5395" class="Function">A</a> <a id="6100" href="gist.transport-discussion.html#5428" class="Function">I</a> <a id="6102" href="gist.transport-discussion.html#5951" class="Function">rₐ</a>

   <a id="6109" href="gist.transport-discussion.html#6109" class="Function">III</a> <a id="6113" class="Symbol">:</a> <a id="6115" href="Notation.General.html#3116" class="Function">type-of</a> <a id="6123" href="gist.transport-discussion.html#6026" class="Function">II</a> <a id="6126" class="Symbol">→</a> <a id="6128" href="gist.transport-discussion.html#5319" class="Bound">P</a> <a id="6130" href="UF.Size.html#2097" class="Function Operator">is</a> <a id="6133" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a> <a id="6135" href="UF.Size.html#2097" class="Function Operator">small</a>
   <a id="6144" href="gist.transport-discussion.html#6109" class="Function">III</a> <a id="6148" class="Symbol">((</a><a id="6150" href="gist.transport-discussion.html#6150" class="Bound Operator">_⇒ₓ_</a> <a id="6155" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6157" href="gist.transport-discussion.html#6157" class="Bound">⇒ₓ-refl</a> <a id="6165" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6167" href="gist.transport-discussion.html#6167" class="Bound">⇒ₓ-is-prop-valued</a><a id="6184" class="Symbol">)</a> <a id="6186" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6188" href="gist.transport-discussion.html#6188" class="Bound">f</a> <a id="6190" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6192" href="gist.transport-discussion.html#6192" class="Bound">g</a><a id="6193" class="Symbol">)</a> <a id="6195" class="Symbol">=</a>
    <a id="6201" href="gist.transport-discussion.html#6224" class="Function">Pₓ</a> <a id="6204" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6206" href="gist.transport-discussion.html#6386" class="Function">IV</a>
    <a id="6213" class="Keyword">where</a>
     <a id="6224" href="gist.transport-discussion.html#6224" class="Function">Pₓ</a> <a id="6227" class="Symbol">:</a> <a id="6229" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a> <a id="6231" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
     <a id="6238" href="gist.transport-discussion.html#6224" class="Function">Pₓ</a> <a id="6241" class="Symbol">=</a> <a id="6243" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="6245" href="gist.transport-discussion.html#6188" class="Bound">f</a> <a id="6247" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="6251" class="Symbol">(</a><a id="6252" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="6256" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6257" class="Symbol">)</a> <a id="6259" href="gist.transport-discussion.html#6150" class="Bound Operator">⇒ₓ</a> <a id="6262" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="6264" href="gist.transport-discussion.html#6188" class="Bound">f</a> <a id="6266" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="6270" class="Symbol">(</a><a id="6271" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="6275" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6276" class="Symbol">)</a>

     <a id="6284" href="gist.transport-discussion.html#6284" class="Function">Pₓ-is-prop</a> <a id="6295" class="Symbol">:</a> <a id="6297" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="6305" href="gist.transport-discussion.html#6224" class="Function">Pₓ</a>
     <a id="6313" href="gist.transport-discussion.html#6284" class="Function">Pₓ-is-prop</a> <a id="6324" class="Symbol">=</a> <a id="6326" href="gist.transport-discussion.html#6167" class="Bound">⇒ₓ-is-prop-valued</a> <a id="6344" class="Symbol">(</a><a id="6345" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="6347" href="gist.transport-discussion.html#6188" class="Bound">f</a> <a id="6349" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="6353" class="Symbol">(</a><a id="6354" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="6358" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6359" class="Symbol">))</a> <a id="6362" class="Symbol">(</a><a id="6363" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="6365" href="gist.transport-discussion.html#6188" class="Bound">f</a> <a id="6367" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="6371" class="Symbol">(</a><a id="6372" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="6376" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6377" class="Symbol">))</a>

     <a id="6386" href="gist.transport-discussion.html#6386" class="Function">IV</a> <a id="6389" class="Symbol">:</a> <a id="6391" href="gist.transport-discussion.html#6224" class="Function">Pₓ</a> <a id="6394" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="6396" href="gist.transport-discussion.html#5319" class="Bound">P</a>
     <a id="6403" href="gist.transport-discussion.html#6386" class="Function">IV</a> <a id="6406" class="Symbol">=</a> <a id="6408" href="gist.transport-discussion.html#6192" class="Bound">g</a> <a id="6410" class="Symbol">(</a><a id="6411" href="MLTT.Plus-Type.html#186" class="InductiveConstructor">inr</a> <a id="6415" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6416" class="Symbol">)</a> <a id="6418" class="Symbol">(</a><a id="6419" href="MLTT.Plus-Type.html#169" class="InductiveConstructor">inl</a> <a id="6423" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a><a id="6424" class="Symbol">)</a>

   <a id="6430" href="gist.transport-discussion.html#6430" class="Function">γ</a> <a id="6432" class="Symbol">:</a> <a id="6434" href="gist.transport-discussion.html#5319" class="Bound">P</a> <a id="6436" href="UF.Size.html#2097" class="Function Operator">is</a> <a id="6439" href="gist.transport-discussion.html#5293" class="Bound">𝓤</a> <a id="6441" href="UF.Size.html#2097" class="Function Operator">small</a>
   <a id="6450" href="gist.transport-discussion.html#6430" class="Function">γ</a> <a id="6452" class="Symbol">=</a> <a id="6454" href="gist.transport-discussion.html#6109" class="Function">III</a> <a id="6458" href="gist.transport-discussion.html#6026" class="Function">II</a>

<a id="6462" class="Markup">\end{code}</a><a id="6472" class="Background">

NB. If we wanted to prove the converse, we would still have to chase
equivalences by hand, as far as we know at the time of writing, unless
we have propositional resizing on-the-nose like UniMath. But notice
that propositional resizing on-the-nose is not unknown to be
consistent.

In other words, there are propositional resizing *axioms* (which are
known to be consistent, and in the above no-go theorem we have a
propositional resizing axiom) and there are propositional resizing
*rules* for the type theory (which are not known to be consistent).

If we hadn&#39;t assumed that the edge relation of a reflexive graph is a
proposition, we would instead be able to show that every type in any
universe is equivalent to any type in any universe we wish, which is
of course false, as &quot;there are more types in larger universes&quot;.
</a></pre></body></html>