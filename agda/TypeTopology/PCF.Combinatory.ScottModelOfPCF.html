<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>PCF.Combinatory.ScottModelOfPCF</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Tom de Jong, 31 May 2019
Updated comments on 21 June 2022.
Added examples at the end on 22 December 2022.

The denotational semantics of PCF based on pointed directed complete posets.

The flag --lossy-unification significantly speeds up the
typechecking of the line ⟦ S {ρ} {σ} {τ} ⟧ₑ = Sᵈᶜᵖᵒ⊥ ⟦ ρ ⟧ ⟦ σ ⟧ ⟦ τ ⟧ below.
(https://agda.readthedocs.io/en/latest/language/lossy-unification.html)


We consider the combinatory version of PCF here. This development was extended
to PCF with variables and λ-abstraction by Brendan Hart in a final year project
supervised by Martín Escardó and myself. Notably, Brendan&#39;s extension contains
an Agda formalization of soundness and computational adequacy.

Brendan&#39;s code, using a previous version of our library, can be found
here: https://github.com/BrendanHart/Investigating-Properties-of-PCF.

The repository also contains Brendan&#39;s report describing the project:
https://github.com/BrendanHart/Investigating-Properties-of-PCF/blob/master/InvestigatingPropertiesOfPCFInAgda.pdf.

</a><a id="1024" class="Markup">\begin{code}</a>

<a id="1038" class="Symbol">{-#</a> <a id="1042" class="Keyword">OPTIONS</a> <a id="1050" class="Pragma">--safe</a> <a id="1057" class="Pragma">--without-K</a> <a id="1069" class="Pragma">--lossy-unification</a> <a id="1089" class="Symbol">#-}</a>

<a id="1094" class="Keyword">open</a> <a id="1099" class="Keyword">import</a> <a id="1106" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="1119" class="Keyword">open</a> <a id="1124" class="Keyword">import</a> <a id="1131" href="UF.PropTrunc.html" class="Module">UF.PropTrunc</a>
<a id="1144" class="Keyword">open</a> <a id="1149" class="Keyword">import</a> <a id="1156" href="UF.FunExt.html" class="Module">UF.FunExt</a>
<a id="1166" class="Keyword">open</a> <a id="1171" class="Keyword">import</a> <a id="1178" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>

<a id="1196" class="Keyword">module</a> <a id="1203" href="PCF.Combinatory.ScottModelOfPCF.html" class="Module">PCF.Combinatory.ScottModelOfPCF</a>
        <a id="1243" class="Symbol">(</a><a id="1244" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1247" class="Symbol">:</a> <a id="1249" href="UF.PropTrunc.html#486" class="Record">propositional-truncations-exist</a><a id="1280" class="Symbol">)</a>
        <a id="1290" class="Symbol">(</a><a id="1291" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1294" class="Symbol">:</a> <a id="1296" href="UF.FunExt.html#1047" class="Function">Fun-Ext</a><a id="1303" class="Symbol">)</a>
        <a id="1313" class="Symbol">(</a><a id="1314" href="PCF.Combinatory.ScottModelOfPCF.html#1314" class="Bound">pe</a> <a id="1317" class="Symbol">:</a> <a id="1319" href="UF.Subsingletons.html#7674" class="Function">propext</a> <a id="1327" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a><a id="1329" class="Symbol">)</a>
       <a id="1338" class="Keyword">where</a>

<a id="1345" class="Keyword">open</a> <a id="1350" href="UF.PropTrunc.html#792" class="Module">PropositionalTruncation</a> <a id="1374" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a>

<a id="1378" class="Keyword">open</a> <a id="1383" class="Keyword">import</a> <a id="1390" href="Naturals.Properties.html" class="Module">Naturals.Properties</a>
<a id="1410" class="Keyword">open</a> <a id="1415" class="Keyword">import</a> <a id="1422" href="UF.DiscreteAndSeparated.html" class="Module">UF.DiscreteAndSeparated</a>

<a id="1447" class="Keyword">open</a> <a id="1452" class="Keyword">import</a> <a id="1459" href="PCF.Combinatory.PCF.html" class="Module">PCF.Combinatory.PCF</a> <a id="1479" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a>
<a id="1482" class="Keyword">open</a> <a id="1487" class="Keyword">import</a> <a id="1494" href="DomainTheory.Basics.Dcpo.html" class="Module">DomainTheory.Basics.Dcpo</a> <a id="1519" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1522" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1525" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>
<a id="1528" class="Keyword">open</a> <a id="1533" class="Keyword">import</a> <a id="1540" href="DomainTheory.Basics.Exponential.html" class="Module">DomainTheory.Basics.Exponential</a> <a id="1572" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1575" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1578" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>
<a id="1581" class="Keyword">open</a> <a id="1586" class="Keyword">import</a> <a id="1593" href="DomainTheory.Basics.LeastFixedPoint.html" class="Module">DomainTheory.Basics.LeastFixedPoint</a> <a id="1629" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1632" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1635" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>
<a id="1638" class="Keyword">open</a> <a id="1643" class="Keyword">import</a> <a id="1650" href="DomainTheory.Basics.Pointed.html" class="Module">DomainTheory.Basics.Pointed</a> <a id="1678" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1681" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1684" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>

<a id="1688" class="Keyword">open</a> <a id="1693" class="Keyword">import</a> <a id="1700" href="PCF.Combinatory.PCFCombinators.html" class="Module">PCF.Combinatory.PCFCombinators</a> <a id="1731" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1734" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1737" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>
<a id="1740" class="Keyword">open</a> <a id="1745" href="PCF.Combinatory.PCFCombinators.html#9207" class="Module">IfZeroDenotationalSemantics</a> <a id="1773" href="PCF.Combinatory.ScottModelOfPCF.html#1314" class="Bound">pe</a>

<a id="1777" class="Keyword">open</a> <a id="1782" class="Keyword">import</a> <a id="1789" href="DomainTheory.Lifting.LiftingSet.html" class="Module">DomainTheory.Lifting.LiftingSet</a> <a id="1821" href="PCF.Combinatory.ScottModelOfPCF.html#1244" class="Bound">pt</a> <a id="1824" href="PCF.Combinatory.ScottModelOfPCF.html#1291" class="Bound">fe</a> <a id="1827" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="1830" href="PCF.Combinatory.ScottModelOfPCF.html#1314" class="Bound">pe</a>

<a id="1834" class="Keyword">open</a> <a id="1839" class="Keyword">import</a> <a id="1846" href="Lifting.Construction.html" class="Module">Lifting.Construction</a> <a id="1867" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a>
<a id="1870" class="Keyword">open</a> <a id="1875" class="Keyword">import</a> <a id="1882" href="Lifting.Monad.html" class="Module">Lifting.Monad</a> <a id="1896" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="1899" class="Keyword">hiding</a> <a id="1906" class="Symbol">(</a><a id="1907" href="Lifting.Monad.html#1037" class="Function">μ</a><a id="1908" class="Symbol">)</a>

<a id="⟦_⟧"></a><a id="1911" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦_⟧</a> <a id="1915" class="Symbol">:</a> <a id="1917" href="PCF.Combinatory.PCF.html#403" class="Datatype">type</a> <a id="1922" class="Symbol">→</a> <a id="1924" href="DomainTheory.Basics.Pointed.html#1018" class="Function">DCPO⊥</a> <a id="1930" class="Symbol">{</a><a id="1931" href="MLTT.Universes.html#4022" class="Function">𝓤₁</a><a id="1933" class="Symbol">}</a> <a id="1935" class="Symbol">{</a><a id="1936" href="MLTT.Universes.html#4022" class="Function">𝓤₁</a><a id="1938" class="Symbol">}</a>
<a id="1940" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="1942" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a> <a id="1944" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a>     <a id="1950" class="Symbol">=</a> <a id="1952" href="DomainTheory.Lifting.LiftingSet.html#5663" class="Function">𝓛-DCPO⊥</a> <a id="1960" href="UF.DiscreteAndSeparated.html#22934" class="Function">ℕ-is-set</a>
<a id="1969" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="1971" href="PCF.Combinatory.ScottModelOfPCF.html#1971" class="Bound">σ</a> <a id="1973" href="PCF.Combinatory.PCF.html#436" class="InductiveConstructor Operator">⇒</a> <a id="1975" href="PCF.Combinatory.ScottModelOfPCF.html#1975" class="Bound">τ</a> <a id="1977" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="1979" class="Symbol">=</a> <a id="1981" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="1983" href="PCF.Combinatory.ScottModelOfPCF.html#1971" class="Bound">σ</a> <a id="1985" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="1987" href="DomainTheory.Basics.Exponential.html#5491" class="Function Operator">⟹ᵈᶜᵖᵒ⊥</a> <a id="1994" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="1996" href="PCF.Combinatory.ScottModelOfPCF.html#1975" class="Bound">τ</a> <a id="1998" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a>

<a id="⟦_⟧ₑ"></a><a id="2001" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦_⟧ₑ</a> <a id="2006" class="Symbol">:</a> <a id="2008" class="Symbol">{</a><a id="2009" href="PCF.Combinatory.ScottModelOfPCF.html#2009" class="Bound">σ</a> <a id="2011" class="Symbol">:</a> <a id="2013" href="PCF.Combinatory.PCF.html#403" class="Datatype">type</a><a id="2017" class="Symbol">}</a> <a id="2019" class="Symbol">(</a><a id="2020" href="PCF.Combinatory.ScottModelOfPCF.html#2020" class="Bound">t</a> <a id="2022" class="Symbol">:</a> <a id="2024" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="2028" href="PCF.Combinatory.ScottModelOfPCF.html#2009" class="Bound">σ</a><a id="2029" class="Symbol">)</a> <a id="2031" class="Symbol">→</a> <a id="2033" href="DomainTheory.Basics.Pointed.html#1143" class="Function Operator">⟪</a> <a id="2035" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2037" href="PCF.Combinatory.ScottModelOfPCF.html#2009" class="Bound">σ</a> <a id="2039" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2041" href="DomainTheory.Basics.Pointed.html#1143" class="Function Operator">⟫</a>
<a id="2043" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2045" href="PCF.Combinatory.PCF.html#513" class="InductiveConstructor">Zero</a> <a id="2050" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>            <a id="2064" class="Symbol">=</a> <a id="2066" href="Lifting.Construction.html#609" class="Function">η</a> <a id="2068" href="MLTT.Natural-Numbers-Type.html#113" class="InductiveConstructor">zero</a>
<a id="2073" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2075" href="PCF.Combinatory.PCF.html#530" class="InductiveConstructor">Succ</a> <a id="2080" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>            <a id="2094" class="Symbol">=</a> <a id="2096" href="Lifting.Monad.html#720" class="Function">𝓛̇</a> <a id="2099" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a> <a id="2104" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2106" href="DomainTheory.Lifting.LiftingSet.html#8826" class="Function">𝓛̇-continuous</a> <a id="2120" href="UF.DiscreteAndSeparated.html#22934" class="Function">ℕ-is-set</a> <a id="2129" href="UF.DiscreteAndSeparated.html#22934" class="Function">ℕ-is-set</a> <a id="2138" href="MLTT.Natural-Numbers-Type.html#123" class="InductiveConstructor">succ</a>
<a id="2143" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2145" href="PCF.Combinatory.PCF.html#553" class="InductiveConstructor">Pred</a> <a id="2150" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>            <a id="2164" class="Symbol">=</a> <a id="2166" href="Lifting.Monad.html#720" class="Function">𝓛̇</a> <a id="2169" href="Naturals.Properties.html#172" class="Function">pred</a> <a id="2174" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2176" href="DomainTheory.Lifting.LiftingSet.html#8826" class="Function">𝓛̇-continuous</a> <a id="2190" href="UF.DiscreteAndSeparated.html#22934" class="Function">ℕ-is-set</a> <a id="2199" href="UF.DiscreteAndSeparated.html#22934" class="Function">ℕ-is-set</a> <a id="2208" href="Naturals.Properties.html#172" class="Function">pred</a>
<a id="2213" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2215" href="PCF.Combinatory.PCF.html#576" class="InductiveConstructor">ifZero</a> <a id="2222" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>          <a id="2234" class="Symbol">=</a> <a id="2236" href="PCF.Combinatory.PCFCombinators.html#16704" class="Function">⦅ifZero⦆</a>
<a id="2245" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2247" href="PCF.Combinatory.PCF.html#607" class="InductiveConstructor">Fix</a> <a id="2251" class="Symbol">{</a><a id="2252" href="PCF.Combinatory.ScottModelOfPCF.html#2252" class="Bound">σ</a><a id="2253" class="Symbol">}</a> <a id="2255" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>         <a id="2266" class="Symbol">=</a> <a id="2268" href="DomainTheory.Basics.LeastFixedPoint.html#8880" class="Function">μ</a> <a id="2270" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2272" href="PCF.Combinatory.ScottModelOfPCF.html#2252" class="Bound">σ</a> <a id="2274" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a>
<a id="2276" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2278" href="PCF.Combinatory.PCF.html#653" class="InductiveConstructor">K</a> <a id="2280" class="Symbol">{</a><a id="2281" href="PCF.Combinatory.ScottModelOfPCF.html#2281" class="Bound">σ</a><a id="2282" class="Symbol">}</a> <a id="2284" class="Symbol">{</a><a id="2285" href="PCF.Combinatory.ScottModelOfPCF.html#2285" class="Bound">τ</a><a id="2286" class="Symbol">}</a> <a id="2288" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>       <a id="2297" class="Symbol">=</a> <a id="2299" href="PCF.Combinatory.PCFCombinators.html#8794" class="Function">Kᵈᶜᵖᵒ⊥</a> <a id="2306" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2308" href="PCF.Combinatory.ScottModelOfPCF.html#2281" class="Bound">σ</a> <a id="2310" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2312" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2314" href="PCF.Combinatory.ScottModelOfPCF.html#2285" class="Bound">τ</a> <a id="2316" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a>
<a id="2318" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2320" href="PCF.Combinatory.PCF.html#697" class="InductiveConstructor">S</a> <a id="2322" class="Symbol">{</a><a id="2323" href="PCF.Combinatory.ScottModelOfPCF.html#2323" class="Bound">ρ</a><a id="2324" class="Symbol">}</a> <a id="2326" class="Symbol">{</a><a id="2327" href="PCF.Combinatory.ScottModelOfPCF.html#2327" class="Bound">σ</a><a id="2328" class="Symbol">}</a> <a id="2330" class="Symbol">{</a><a id="2331" href="PCF.Combinatory.ScottModelOfPCF.html#2331" class="Bound">τ</a><a id="2332" class="Symbol">}</a> <a id="2334" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>   <a id="2339" class="Symbol">=</a> <a id="2341" href="PCF.Combinatory.PCFCombinators.html#8857" class="Function">Sᵈᶜᵖᵒ⊥</a> <a id="2348" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2350" href="PCF.Combinatory.ScottModelOfPCF.html#2323" class="Bound">ρ</a> <a id="2352" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2354" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2356" href="PCF.Combinatory.ScottModelOfPCF.html#2327" class="Bound">σ</a> <a id="2358" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2360" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2362" href="PCF.Combinatory.ScottModelOfPCF.html#2331" class="Bound">τ</a> <a id="2364" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a>
<a id="2366" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2368" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">_·_</a> <a id="2372" class="Symbol">{</a><a id="2373" href="PCF.Combinatory.ScottModelOfPCF.html#2373" class="Bound">σ</a><a id="2374" class="Symbol">}</a> <a id="2376" class="Symbol">{</a><a id="2377" href="PCF.Combinatory.ScottModelOfPCF.html#2377" class="Bound">τ</a><a id="2378" class="Symbol">}</a> <a id="2380" href="PCF.Combinatory.ScottModelOfPCF.html#2380" class="Bound">s</a> <a id="2382" href="PCF.Combinatory.ScottModelOfPCF.html#2382" class="Bound">t</a> <a id="2384" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="2387" class="Symbol">=</a> <a id="2389" href="DomainTheory.Basics.Dcpo.html#11440" class="Function">[</a> <a id="2391" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2393" href="PCF.Combinatory.ScottModelOfPCF.html#2373" class="Bound">σ</a> <a id="2395" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2397" href="DomainTheory.Basics.Pointed.html#1113" class="Function Operator">⁻</a> <a id="2399" href="DomainTheory.Basics.Dcpo.html#11440" class="Function">,</a>  <a id="2402" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2404" href="PCF.Combinatory.ScottModelOfPCF.html#2377" class="Bound">τ</a> <a id="2406" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2408" href="DomainTheory.Basics.Pointed.html#1113" class="Function Operator">⁻</a> <a id="2410" href="DomainTheory.Basics.Dcpo.html#11440" class="Function">]⟨</a> <a id="2413" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2415" href="PCF.Combinatory.ScottModelOfPCF.html#2380" class="Bound">s</a> <a id="2417" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="2420" href="DomainTheory.Basics.Dcpo.html#11440" class="Function">⟩</a> <a id="2422" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2424" href="PCF.Combinatory.ScottModelOfPCF.html#2382" class="Bound">t</a> <a id="2426" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>

<a id="2430" class="Markup">\end{code}</a><a id="2440" class="Background">

Because Agda is a computational system, we can use it to directly compute the
value of terms in the model. We showcase a few examples illustrating this, as
suggested by Andrej Bauer during my viva on 20 December 2022.

</a><a id="2661" class="Markup">\begin{code}</a>

<a id="2675" class="Keyword">private</a>
 <a id="t₁"></a><a id="2684" href="PCF.Combinatory.ScottModelOfPCF.html#2684" class="Function">t₁</a> <a id="2687" class="Symbol">:</a> <a id="2689" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="2693" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="2696" href="PCF.Combinatory.ScottModelOfPCF.html#2684" class="Function">t₁</a> <a id="2699" class="Symbol">=</a> <a id="2701" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="2703" class="Number">7</a> <a id="2705" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a>

 <a id="recall-the-interpretation-of-ι"></a><a id="2709" href="PCF.Combinatory.ScottModelOfPCF.html#2709" class="Function">recall-the-interpretation-of-ι</a> <a id="2740" class="Symbol">:</a> <a id="2742" href="DomainTheory.Basics.Pointed.html#1143" class="Function Operator">⟪</a> <a id="2744" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟦</a> <a id="2746" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a> <a id="2748" href="PCF.Combinatory.ScottModelOfPCF.html#1911" class="Function Operator">⟧</a> <a id="2750" href="DomainTheory.Basics.Pointed.html#1143" class="Function Operator">⟫</a> <a id="2752" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2754" href="Lifting.Construction.html#246" class="Function">𝓛</a> <a id="2756" href="MLTT.Natural-Numbers-Type.html#96" class="Datatype">ℕ</a>
 <a id="2759" href="PCF.Combinatory.ScottModelOfPCF.html#2709" class="Function">recall-the-interpretation-of-ι</a> <a id="2790" class="Symbol">=</a> <a id="2792" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

 <a id="⟦t₁⟧-is-a-triple-representing-a-partial-element"></a><a id="2799" href="PCF.Combinatory.ScottModelOfPCF.html#2799" class="Function">⟦t₁⟧-is-a-triple-representing-a-partial-element</a> <a id="2847" class="Symbol">:</a> <a id="2849" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="2851" href="PCF.Combinatory.ScottModelOfPCF.html#2684" class="Function">t₁</a> <a id="2854" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>
                                                 <a id="2906" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="2908" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="2910" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2912" class="Symbol">(λ</a> <a id="2915" href="PCF.Combinatory.ScottModelOfPCF.html#2915" class="Bound">_</a> <a id="2917" class="Symbol">→</a> <a id="2919" class="Number">7</a><a id="2920" class="Symbol">)</a> <a id="2922" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="2924" href="UF.Subsingletons.html#2858" class="Function">𝟙-is-prop</a>
 <a id="2935" href="PCF.Combinatory.ScottModelOfPCF.html#2799" class="Function">⟦t₁⟧-is-a-triple-representing-a-partial-element</a> <a id="2983" class="Symbol">=</a> <a id="2985" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

 <a id="compute-the-value-of-⟦t₁⟧"></a><a id="2992" href="PCF.Combinatory.ScottModelOfPCF.html#2992" class="Function">compute-the-value-of-⟦t₁⟧</a> <a id="3018" class="Symbol">:</a> <a id="3020" href="Lifting.Construction.html#481" class="Function">value</a> <a id="3026" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="3028" href="PCF.Combinatory.ScottModelOfPCF.html#2684" class="Function">t₁</a> <a id="3031" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="3034" href="MLTT.Unit.html#162" class="InductiveConstructor">⋆</a> <a id="3036" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3038" class="Number">7</a>
 <a id="3041" href="PCF.Combinatory.ScottModelOfPCF.html#2992" class="Function">compute-the-value-of-⟦t₁⟧</a> <a id="3067" class="Symbol">=</a> <a id="3069" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>


 <a id="t₂"></a><a id="3077" href="PCF.Combinatory.ScottModelOfPCF.html#3077" class="Function">t₂</a> <a id="3080" class="Symbol">:</a> <a id="3082" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="3086" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="3089" href="PCF.Combinatory.ScottModelOfPCF.html#3077" class="Function">t₂</a> <a id="3092" class="Symbol">=</a> <a id="3094" href="PCF.Combinatory.PCF.html#553" class="InductiveConstructor">Pred</a> <a id="3099" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3101" class="Symbol">(</a><a id="3102" href="PCF.Combinatory.PCF.html#553" class="InductiveConstructor">Pred</a> <a id="3107" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3109" class="Symbol">(</a><a id="3110" href="PCF.Combinatory.PCF.html#530" class="InductiveConstructor">Succ</a> <a id="3115" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3117" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="3119" class="Number">3</a> <a id="3121" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a><a id="3122" class="Symbol">))</a>

 <a id="⟦t₂⟧-is-a-triple-representing-a-partial-element"></a><a id="3127" href="PCF.Combinatory.ScottModelOfPCF.html#3127" class="Function">⟦t₂⟧-is-a-triple-representing-a-partial-element</a> <a id="3175" class="Symbol">:</a> <a id="3177" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="3179" href="PCF.Combinatory.ScottModelOfPCF.html#3077" class="Function">t₂</a> <a id="3182" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>
                                                 <a id="3234" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3236" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="3238" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3240" class="Symbol">(λ</a> <a id="3243" href="PCF.Combinatory.ScottModelOfPCF.html#3243" class="Bound">_</a> <a id="3245" class="Symbol">→</a> <a id="3247" class="Number">2</a><a id="3248" class="Symbol">)</a> <a id="3250" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="3252" href="UF.Subsingletons.html#2858" class="Function">𝟙-is-prop</a>
 <a id="3263" href="PCF.Combinatory.ScottModelOfPCF.html#3127" class="Function">⟦t₂⟧-is-a-triple-representing-a-partial-element</a> <a id="3311" class="Symbol">=</a> <a id="3313" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

  <a id="3321" class="Comment">-- We let Agda compute the witness (indicated by _) that ⟦ t₂ ⟧ₑ is total.</a>
 <a id="compute-the-value-of-⟦t₂⟧"></a><a id="3397" href="PCF.Combinatory.ScottModelOfPCF.html#3397" class="Function">compute-the-value-of-⟦t₂⟧</a> <a id="3423" class="Symbol">:</a> <a id="3425" href="Lifting.Construction.html#481" class="Function">value</a> <a id="3431" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="3433" href="PCF.Combinatory.ScottModelOfPCF.html#3077" class="Function">t₂</a> <a id="3436" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="3439" class="Symbol">_</a> <a id="3441" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3443" class="Number">2</a>
 <a id="3446" href="PCF.Combinatory.ScottModelOfPCF.html#3397" class="Function">compute-the-value-of-⟦t₂⟧</a> <a id="3472" class="Symbol">=</a> <a id="3474" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="3480" class="Markup">\end{code}</a><a id="3490" class="Background">

By computational adequacy (see the comments at the top of this file) and the
computation above, the term t₂ reduces to the numeral ⌜ 2 ⌝ in PCF.

</a><a id="3638" class="Markup">\begin{code}</a>

 <a id="3653" class="Comment">-- t₃ encodes the program [λ x . (if (0 == x) then 2 else (pred 5)) 3]</a>
 <a id="t₃"></a><a id="3725" href="PCF.Combinatory.ScottModelOfPCF.html#3725" class="Function">t₃</a> <a id="3728" class="Symbol">:</a> <a id="3730" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="3734" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="3737" href="PCF.Combinatory.ScottModelOfPCF.html#3725" class="Function">t₃</a> <a id="3740" class="Symbol">=</a> <a id="3742" href="PCF.Combinatory.PCF.html#576" class="InductiveConstructor">ifZero</a> <a id="3749" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3751" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="3753" class="Number">2</a> <a id="3755" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a> <a id="3757" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3759" class="Symbol">(</a><a id="3760" href="PCF.Combinatory.PCF.html#553" class="InductiveConstructor">Pred</a> <a id="3765" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3767" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="3769" class="Number">5</a> <a id="3771" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a><a id="3772" class="Symbol">)</a> <a id="3774" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="3776" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="3778" class="Number">3</a> <a id="3780" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a>

 <a id="3784" class="Comment">-- Notice how the extent of the partial element is no longer given by 𝟙 but, as</a>
 <a id="3865" class="Comment">-- a consequence of the constructions in our model, by the product 𝟙 × 𝟙.</a>
 <a id="3940" class="Comment">--</a>
 <a id="3944" class="Comment">-- We let Agda compute the witness (indicated by _) that the type 𝟙 × 𝟙 is a</a>
 <a id="4022" class="Comment">-- proposition.</a>
 <a id="⟦t₃⟧-is-a-triple-representing-a-partial-element"></a><a id="4039" href="PCF.Combinatory.ScottModelOfPCF.html#4039" class="Function">⟦t₃⟧-is-a-triple-representing-a-partial-element</a> <a id="4087" class="Symbol">:</a> <a id="4089" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="4091" href="PCF.Combinatory.ScottModelOfPCF.html#3725" class="Function">t₃</a> <a id="4094" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a>
                                                 <a id="4146" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="4148" class="Symbol">(</a><a id="4149" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="4151" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="4153" href="MLTT.Unit.html#129" class="Record">𝟙</a><a id="4154" class="Symbol">)</a> <a id="4156" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4158" class="Symbol">(λ</a> <a id="4161" href="PCF.Combinatory.ScottModelOfPCF.html#4161" class="Bound">_</a> <a id="4163" class="Symbol">→</a> <a id="4165" class="Number">4</a><a id="4166" class="Symbol">)</a> <a id="4168" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4170" class="Symbol">_</a>
 <a id="4173" href="PCF.Combinatory.ScottModelOfPCF.html#4039" class="Function">⟦t₃⟧-is-a-triple-representing-a-partial-element</a> <a id="4221" class="Symbol">=</a> <a id="4223" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

 <a id="compute-the-value-of-⟦t₃⟧"></a><a id="4230" href="PCF.Combinatory.ScottModelOfPCF.html#4230" class="Function">compute-the-value-of-⟦t₃⟧</a> <a id="4256" class="Symbol">:</a> <a id="4258" href="Lifting.Construction.html#481" class="Function">value</a> <a id="4264" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="4266" href="PCF.Combinatory.ScottModelOfPCF.html#3725" class="Function">t₃</a> <a id="4269" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="4272" class="Symbol">_</a> <a id="4274" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="4276" class="Number">4</a>
 <a id="4279" href="PCF.Combinatory.ScottModelOfPCF.html#4230" class="Function">compute-the-value-of-⟦t₃⟧</a> <a id="4305" class="Symbol">=</a> <a id="4307" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="4313" class="Markup">\end{code}</a><a id="4323" class="Background">

Next we show two examples using the S and K combinators. We first construct the
identity function I on an arbitrary type σ of PCF using the well-known
definition I = S · K · K.

</a><a id="4503" class="Markup">\begin{code}</a>

 <a id="I"></a><a id="4518" href="PCF.Combinatory.ScottModelOfPCF.html#4518" class="Function">I</a> <a id="4520" class="Symbol">:</a> <a id="4522" class="Symbol">{</a><a id="4523" href="PCF.Combinatory.ScottModelOfPCF.html#4523" class="Bound">σ</a> <a id="4525" class="Symbol">:</a> <a id="4527" href="PCF.Combinatory.PCF.html#403" class="Datatype">type</a><a id="4531" class="Symbol">}</a> <a id="4533" class="Symbol">→</a> <a id="4535" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="4539" class="Symbol">(</a><a id="4540" href="PCF.Combinatory.ScottModelOfPCF.html#4523" class="Bound">σ</a> <a id="4542" href="PCF.Combinatory.PCF.html#436" class="InductiveConstructor Operator">⇒</a> <a id="4544" href="PCF.Combinatory.ScottModelOfPCF.html#4523" class="Bound">σ</a><a id="4545" class="Symbol">)</a>
 <a id="4548" href="PCF.Combinatory.ScottModelOfPCF.html#4518" class="Function">I</a> <a id="4550" class="Symbol">{</a><a id="4551" href="PCF.Combinatory.ScottModelOfPCF.html#4551" class="Bound">σ</a><a id="4552" class="Symbol">}</a> <a id="4554" class="Symbol">=</a> <a id="4556" class="Symbol">(</a><a id="4557" href="PCF.Combinatory.PCF.html#697" class="InductiveConstructor">S</a> <a id="4559" class="Symbol">{</a><a id="4560" href="PCF.Combinatory.ScottModelOfPCF.html#4551" class="Bound">σ</a><a id="4561" class="Symbol">}</a> <a id="4563" class="Symbol">{</a><a id="4564" href="PCF.Combinatory.ScottModelOfPCF.html#4551" class="Bound">σ</a> <a id="4566" href="PCF.Combinatory.PCF.html#436" class="InductiveConstructor Operator">⇒</a> <a id="4568" href="PCF.Combinatory.ScottModelOfPCF.html#4551" class="Bound">σ</a><a id="4569" class="Symbol">}</a> <a id="4571" class="Symbol">{</a><a id="4572" href="PCF.Combinatory.ScottModelOfPCF.html#4551" class="Bound">σ</a><a id="4573" class="Symbol">})</a> <a id="4576" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="4578" href="PCF.Combinatory.PCF.html#653" class="InductiveConstructor">K</a> <a id="4580" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="4582" href="PCF.Combinatory.PCF.html#653" class="InductiveConstructor">K</a>

 <a id="t₄"></a><a id="4586" href="PCF.Combinatory.ScottModelOfPCF.html#4586" class="Function">t₄</a> <a id="4589" class="Symbol">:</a> <a id="4591" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="4595" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="4598" href="PCF.Combinatory.ScottModelOfPCF.html#4586" class="Function">t₄</a> <a id="4601" class="Symbol">=</a> <a id="4603" href="PCF.Combinatory.ScottModelOfPCF.html#4518" class="Function">I</a> <a id="4605" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="4607" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="4609" class="Number">7</a> <a id="4611" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a>

 <a id="compute-the-value-of-⟦t₄⟧"></a><a id="4615" href="PCF.Combinatory.ScottModelOfPCF.html#4615" class="Function">compute-the-value-of-⟦t₄⟧</a> <a id="4641" class="Symbol">:</a> <a id="4643" href="Lifting.Construction.html#481" class="Function">value</a> <a id="4649" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="4651" href="PCF.Combinatory.ScottModelOfPCF.html#4586" class="Function">t₄</a> <a id="4654" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="4657" class="Symbol">_</a> <a id="4659" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="4661" class="Number">7</a>
 <a id="4664" href="PCF.Combinatory.ScottModelOfPCF.html#4615" class="Function">compute-the-value-of-⟦t₄⟧</a> <a id="4690" class="Symbol">=</a> <a id="4692" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

 <a id="t₅"></a><a id="4699" href="PCF.Combinatory.ScottModelOfPCF.html#4699" class="Function">t₅</a> <a id="4702" class="Symbol">:</a> <a id="4704" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="4708" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="4711" href="PCF.Combinatory.ScottModelOfPCF.html#4699" class="Function">t₅</a> <a id="4714" class="Symbol">=</a> <a id="4716" class="Symbol">(</a><a id="4717" href="PCF.Combinatory.ScottModelOfPCF.html#4518" class="Function">I</a> <a id="4719" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="4721" href="PCF.Combinatory.PCF.html#530" class="InductiveConstructor">Succ</a><a id="4725" class="Symbol">)</a> <a id="4727" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="4729" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="4731" class="Number">11</a> <a id="4734" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a>

 <a id="compute-the-value-of-⟦t₅⟧"></a><a id="4738" href="PCF.Combinatory.ScottModelOfPCF.html#4738" class="Function">compute-the-value-of-⟦t₅⟧</a> <a id="4764" class="Symbol">:</a> <a id="4766" href="Lifting.Construction.html#481" class="Function">value</a> <a id="4772" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟦</a> <a id="4774" href="PCF.Combinatory.ScottModelOfPCF.html#4699" class="Function">t₅</a> <a id="4777" href="PCF.Combinatory.ScottModelOfPCF.html#2001" class="Function Operator">⟧ₑ</a> <a id="4780" class="Symbol">_</a> <a id="4782" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="4784" class="Number">12</a>
 <a id="4788" href="PCF.Combinatory.ScottModelOfPCF.html#4738" class="Function">compute-the-value-of-⟦t₅⟧</a> <a id="4814" class="Symbol">=</a> <a id="4816" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="4822" class="Markup">\end{code}</a><a id="4832" class="Background">

Finally, here are two examples that use the Fix combinator where Agda cannot
normalise the term within reasonable time, which is why these lines are
commented out.

</a><a id="4999" class="Markup">\begin{code}</a>
 <a id="t₆"></a><a id="5013" href="PCF.Combinatory.ScottModelOfPCF.html#5013" class="Function">t₆</a> <a id="5016" class="Symbol">:</a> <a id="5018" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="5022" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="5025" href="PCF.Combinatory.ScottModelOfPCF.html#5013" class="Function">t₆</a> <a id="5028" class="Symbol">=</a> <a id="5030" href="PCF.Combinatory.PCF.html#607" class="InductiveConstructor">Fix</a> <a id="5034" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="5036" class="Symbol">(</a><a id="5037" href="PCF.Combinatory.PCF.html#653" class="InductiveConstructor">K</a> <a id="5039" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="5041" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌜</a> <a id="5043" class="Number">0</a> <a id="5045" href="PCF.Combinatory.PCF.html#830" class="Function Operator">⌝</a><a id="5046" class="Symbol">)</a>

 <a id="5050" class="Comment">-- The value of ⟦ t₆ ⟧ is 0, but the computation takes an unreasonable amount</a>
 <a id="5129" class="Comment">-- of time.</a>
 <a id="5142" class="Comment">--</a>
 <a id="5146" class="Comment">-- compute-the-value-of-⟦t₆⟧ : value ⟦ t₆ ⟧ₑ _ = 0</a>
 <a id="5198" class="Comment">-- compute-the-value-of-⟦t₆⟧ = refl</a>

 <a id="t₇"></a><a id="5236" href="PCF.Combinatory.ScottModelOfPCF.html#5236" class="Function">t₇</a> <a id="5239" class="Symbol">:</a> <a id="5241" href="PCF.Combinatory.PCF.html#481" class="Datatype">PCF</a> <a id="5245" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a>
 <a id="5248" href="PCF.Combinatory.ScottModelOfPCF.html#5236" class="Function">t₇</a> <a id="5251" class="Symbol">=</a> <a id="5253" href="PCF.Combinatory.PCF.html#607" class="InductiveConstructor">Fix</a> <a id="5257" href="PCF.Combinatory.PCF.html#761" class="InductiveConstructor Operator">·</a> <a id="5259" class="Symbol">(</a><a id="5260" href="PCF.Combinatory.ScottModelOfPCF.html#4518" class="Function">I</a> <a id="5262" class="Symbol">{</a><a id="5263" href="PCF.Combinatory.PCF.html#423" class="InductiveConstructor">ι</a><a id="5264" class="Symbol">})</a>

 <a id="5269" class="Comment">-- The interpretation of t₇ is equal to ⊥, because it is the least fixed point</a>
 <a id="5349" class="Comment">-- of the identity on ⟦ ι ⟧, but Agda cannot normalise (is-defined (⟦ t₇ ⟧ₑ) in</a>
 <a id="5430" class="Comment">-- reasonable time.</a>
 <a id="5451" class="Comment">--</a>
 <a id="5455" class="Comment">-- ⟦t₇⟧-is-not-defined : ¬ (is-defined ⟦ t₇ ⟧ₑ)</a>
 <a id="5504" class="Comment">-- ⟦t₇⟧-is-not-defined = {!!}</a>

<a id="5535" class="Markup">\end{code}</a><a id="5545" class="Background">
</a></pre></body></html>