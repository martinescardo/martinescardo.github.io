Inï¬nite sets that admit fast exhaustive search
MartÂ´n EscardÂ´ Ä± o
School of Computer Science, University of Birmingham, UK Version of January 27, 2008

Abstract. Perhaps surprisingly, there are inï¬nite sets that admit mechanical exhaustive search in ï¬nite time. An old example is the Cantor space of inï¬nite sequences of binary digits. We investigate three related questions, in the realm of higher-type computation: (i) What kinds of inï¬nite sets are exhaustible? It turns out that they have to be compact in the topological sense. A complete description is obtained by developing a computational version of an Arzelaâ€“Ascoli type characterization of compact subsets of function spaces. Another, less explicit, one is perhaps more appealing: a non-empty set is exhaustible if and only if it is a computable image of the Cantor space. (ii) How do we systematically build inï¬nite exhaustible sets? Here some well-known topological closure properties of compact sets are shown to hold for exhaustible sets. This includes a computational version of the Tychonoff theorem, asserting that exhaustible sets are closed under countable products. (iii) How fast can exhaustive search over inï¬nite sets be performed? Although exhaustive search over inï¬nite sets is of course intractable, as is the case for ï¬nite sets, algorithms that are fast in surprising classes of instances are exhibited. We formulate time-complexity conjectures, which are backed by experiments, where the size of the input predicate for the search algorithm is taken as its modulus of uniform continuity.
Keywords. Higher-type computability and complexity, Kleeneâ€“Kreisel functional, PCF, domain theory, programminglanguage semantics, topology, k-space, compactly generated space, Haskell, functional programming. Mathematics Subject Classiï¬cation 2000. 03D65, 68Q55, 06B35, 54D50.

1

Introduction
given a set K and a property p of elements of K , check whether or not all elements of K satisfy p.

A wealth of computational problems of interest have the following form:

For K ï¬xed in advance, this is known as the emptiness problem for p. One is often interested in suitable restrictions on the possible syntactical forms of the predicate p that guarantee that the emptiness problem is decidable (or, less ambitiously, that the non-emptiness problem is semi-decidable) uniformly in the syntactical form of p. In this work, on the other hand, the emphasis is on the set K rather than the predicate p, and, moreover, we donâ€™t look at the syntactic structure of p: we consider all decidable predicates on K , in the sense of computability theory, given as black boxes. Exhaustively searchable sets. We say that the set K is exhaustible if the above problem can be algorithmically solved in ï¬nite time, for any decidable property p, uniformly p. Thus, the input of the decision algorithm is a black box for p and the output is the truth value of the statement that all elements of K satisfy p. In the realm of higher-type computability theory [23], the algorithm has type (C â†’ B) â†’ B, where C is a type, K âŠ† C , and B is the 1

type of booleans, so that (C â†’ B) is the type of decidable predicates on C . The question investigated in this work is what sets, if any, are exhaustible in the realm of higher-type computability theory [19]. Clearly, ï¬nite sets of computable elements are exhaustible. What may be rather unclear is whether there are inï¬nite examples. Intuitively, there can be none: how could one possibly check inï¬nitely many cases in ï¬nite time? This intuition is correct when K is a set of natural numbers: it is a theorem that, in this case, K is exhaustible if and only if it is ï¬nite. This can be proved by reduction to the halting problem, but there is also a purely topological argument (Remark 3.3.5). However, it turns out that there is a rich supply of inï¬nite exhaustible sets. A ï¬rst example, the Cantor space of inï¬nite sequences of binary digits, goes back to the 1950â€™s, or even earlier, with the work of Brouwer, as discussed in the related-work paragraph below. The inï¬nite case. Our primary contribution is a comprehensive investigation of inï¬nite exhaustible sets in the realm of higher-type computability theory (with classical logic as our meta-theory). We develop tools for systematically building them and some characterizations, including the following: they are closed under intersections with decidable sets, under the formation of computable images and of ï¬nite and countably inï¬nite products, and in the non-empty case they are precisely the computable images of the Cantor space. An Arzelaâ€“Ascoli type characterization is formulated and proved in Section 3. If a problem of the above form has a negative solution, one would like to be able to algorithmically ï¬nd a counter-example. If this is possible, we say that the set K is searchable. It turns out that exhaustibility coincides with searchability, which supports the intuitive understanding of exhaustive search, but involves an elaborate construction. The closure properties and characterizations of exhaustibility resemble those of compactness in topology. This is no accident: exhaustible sets are to compact sets as computable functions are to continuous maps. This plays a crucial role in the correctness proofs of some of the algorithms, and, indeed, in their very construction. Thus, the speciï¬cations of all of our algorithms can be understood without much background, but an understanding of the working of some of them requires some amount of topology. We have organized the construction of these algorithms in two parts: Section 2 addresses those that are motivated by topology but donâ€™t rely on knowledge of topology for their formulation or correctness proofs, and Section 3 collects those that crucially depend on topological considerations for their proofs, together with the necessary topological background. Complexity considerations. Our secondary contribution is a preliminary investigation of the run-time behaviour of some of our algorithms and of the complexity of the search problem in the inï¬nite case. Although we donâ€™t have conclusive results in this direction, we have some surprising experimental results and tentative theoretical explanations and conjectures (Section 4). These experiments are implemented in a fragment of the highertype functional programming language Haskell [13], which is essentially the same as PCF (simply-typed lambda-calculus with arithmetic and ï¬xed-point recursion) [29, 25]. Related work. Brouwerâ€™s Fan functional gives the modulus of uniform continuity of a discrete-valued continuous functional on the Cantor space. According to personal communication by Normann, computability of the Fan functional was known in the late 1950â€™s. This immediately gives rise to the exhaustibility of the Cantor space. A number of authors have considered deï¬nability of the Fan functional in various formal systems. Normann [23] cites Tait (1958, unpublished), Gandy (around 1982, unpublished) and Berger [5] (1990). Tait showed that the Fan functional is not deï¬nable from Kleeneâ€™s schemes S1â€“S9 interpreted over total functionals. Berger showed that it is PCF deï¬nable, and, in order to do that, he ï¬rst explicitly deï¬ned a search functional for the Cantor space. Berger observed

2

that, for partial functionals, PCF deï¬nability coincides with S1â€“S9 deï¬nability. Then Hyland informed the community that Gandy was aware of the S1â€“S9 deï¬nability of the Fan functional for the partial interpretation of Kleeneâ€™s schemes, although Gandyâ€™s deï¬nition seems to be lost. Totality assumptions. Some of the above results crucially rely on a notion of totality. For example, to show that exhaustible sets are searchable, we need to assume that they consist of total elements. But there are two contenders for a notion of totality in highertype computation, namely Kleeneâ€“Kreisel totality and hereditarily effective totality. Our results hold for the former but fail for the latter. This failure is to be expected: it is well known that, for the hereditarily effective notion, there is no total Fan functional [4], and hence the set of total elements of the Cantor type cannot be exhaustible. Put another way, the above algorithms for the Fan functional are total in the Kleeneâ€“Kreisel sense, but not in the hereditarily effective sense. In the language of Plotkin [27], we work with PCFdeï¬nable functionals under the semantic notion of totality. Acknowledgements. I have beneï¬ted from discussions with Andrej Bauer, Ulrich Berger, Dan Ghica, Achim Jung, John Longley, Matthias SchrÂ¨ der, and Alex Simpson. I also thank o Dag Normann for having answered questions regarding the history and technical ramiï¬cations of the subject, and for sending me a copy of Taitâ€™s unpublished manuscript â€” but the reader should consult his paper [23] for a more accurate and detailed account of the development of the subject.

2

Topologically inspired algorithms

In this section we develop algorithms that donâ€™t require knowledge of topology but are motivated by topological considerations. The intuition behind the topological notion of compactness is that compact sets behave, in many relevant respects, as if they were ï¬nite. Inï¬nite sets that admit exhaustive search in ï¬nite time share the same intuition. Hence it is natural to conjecture that they also share similar structural properties. For example, compact sets are closed under the formation of products (Tychonoff theorem). Motivated by this, in this section we show that exhaustible sets are closed under countable products, and we also export other closure properties from topology to computation. After introducing the relevant computational background, we deï¬ne the two main notions investigated in this work, namely those of exhaustibility and searchability, and then develop algorithms that implement the closure properties.

2.1 Background on higher-type computation
As discussed in e.g. [23, 16, 17], there are many equivalent approaches to higher-type computation. Kleene deï¬ned the total functionals directly, but it has been found more convenient to work with the larger collection of partial functionals and isolate the total ones within them, as done by Kreisel. The approaches are equivalent, and such total functionals are often referred to as Kleeneâ€“Kreisel functionals. It turns out that, as discussed by Normann [23], this coincides with another approach known in the computer-science community: equivalence classes of total functionals on Scott domains. In this section we work with total functionals on Scott domains, and in Section 3 we work with a characterization of Kleeneâ€“Kreisel functionals, due to Hyland, in terms of compactly generated topological spaces. Types. The simple types are deï¬ned by induction as Ïƒ, Ï„ ::= o | Î¹ | Ïƒ Ã— Ï„ | Ïƒ â†’ Ï„, 3

with usual rules for bracketing, where o and Î¹ are ground types for booleans and natural numbers respectively. The subset of pure types is deï¬ned by Ïƒ ::= Î¹ | Ïƒ â†’ Î¹. As usual, weâ€™ll occasionally reduce statements about simple types to statements about pure types. Partial functionals. For each type Ïƒ , deï¬ne a Scott domain DÏƒ of partial functionals of type Ïƒ by induction as follows: Do = B = BâŠ¥ , D Î¹ = N = NâŠ¥ ,

DÏƒÃ—Ï„ = DÏƒ Ã— DÏ„ , DÏƒâ†’Ï„ = (DÏƒ â†’ DÏ„ ) = DÏ„ DÏƒ , where B = {ï¬€ , tt} is the set of booleans and the products and exponentials are calculated in the cartesian closed category of continuous maps of Scott domains, where a Scott domain is an algebraic, bounded complete, and directed complete poset [1]. Total functionals. For each type Ïƒ , deï¬ne, a set TÏƒ âŠ† DÏƒ of total functionals and a relation âˆ¼Ïƒ on DÏƒ as follows, where Î³ ranges over ground types o and Î¹: To = B, T Î¹ = N,

x âˆ¼Î³ y â‡â‡’ x, y âˆˆ TÎ³ and x = y . TÏƒÃ—Ï„ = TÏƒ Ã— TÏ„ , (x, x ) âˆ¼ÏƒÃ—Ï„ (y, y ) â‡â‡’ x âˆ¼Ïƒ y âˆ§ x âˆ¼Ï„ y , TÏƒâ†’Ï„ = {f âˆˆ DÏƒâ†’Ï„ | f (TÏƒ ) âŠ† TÏ„ }, f âˆ¼Ïƒâ†’Ï„ g â‡â‡’ âˆ€x âˆ¼Ïƒ y.f (x) âˆ¼Ï„ g (y ). Then the set TÏƒ can be recovered from the relation âˆ¼Ïƒ as x âˆˆ TÏƒ â‡â‡’ x âˆ¼Ïƒ x, and the relation can be recovered from the set as x âˆ¼Ïƒ y â‡â‡’ x y âˆˆ TÏƒ â‡â‡’ x, y âˆˆ TÏƒ and x and y are bounded above.

See e.g. [6] and [27]. In particular, âˆ¼Ïƒ is an equivalence relation on TÏƒ . Computability. A partial functional is computable iff it is PCF-deï¬nable from parallel-or and parallel-exists [25]. This is a theorem, but we take it as our deï¬nition. All computable functionals we construct are deï¬ned in PCF without parallel extensions. This deï¬nition includes, in particular, total functionals. An interesting fact, which we donâ€™t use, is that every total functional deï¬nable in PCF with parallel extensions is equivalent to one deï¬nable in PCF without parallel extensions [20].

4

2.2 Exhaustible and searchable sets
We now formulate the central notions investigated in this work. Through this section, D = DÏƒ , T = TÏƒ and D = DÏƒ , T = TÏƒ for arbitrary simple types Ïƒ and Ïƒ . Deï¬nition 2.2.1. If K is a subset of D, we say that a predicate p âˆˆ (D â†’ B) is deï¬ned on K , or total on K , if p(x) = âŠ¥ for every x âˆˆ K . Deï¬nition 2.2.2. We say that a set K âŠ† D is exhaustible if there is a computable functional âˆ€K : (D â†’ B) â†’ B such that for any p âˆˆ (D â†’ B) deï¬ned on K , âˆ€K (p) = tt if p(x) = tt for all x âˆˆ K , ï¬€ if p(x) = ï¬€ for some x âˆˆ K .

Such a functional is not uniquely determined, because its behaviour is not speciï¬ed for predicates p that are not deï¬ned on K . For the sake of clarity, weâ€™ll often write â€œâˆ€K (Î»x. . . . )â€ as â€œâˆ€x âˆˆ K. . . . â€. Clearly, it is equivalent to instead require the existence of a computable functional âˆƒK : (D â†’ B) â†’ B such that for any p âˆˆ (D â†’ B) deï¬ned on K , âˆƒK (p) = tt if p(x) = tt for some x âˆˆ K , ï¬€ if p(x) = ï¬€ for all x âˆˆ K ,

because such functionals are inter-deï¬nable by the De Morgan Laws and hence weâ€™ll freely switch between them. Deï¬nition 2.2.3. We say that a set K âŠ† D is searchable if there is a computable functional ÎµK : (D â†’ B) â†’ D such that, for every predicate p âˆˆ (D â†’ B) deï¬ned on K , 1. ÎµK (p) âˆˆ K , and 2. p(ÎµK (p)) = tt if p(x) = tt for some x âˆˆ K . Again, notice that ÎµK is not uniquely determined by K . Thus, ÎµK (p) is an example of an element of K for which p holds, if such an element exists, or a counter-example in K if no such example exists. Lemma 2.2.4. Searchable sets are exhaustible. Proof. Deï¬ne âˆƒK (p) = p(ÎµK (p)). With 1 = { }, an equivalent deï¬nition of searchability, which will not be used, is that 1. K has a computable element eK , and 2. there is ÎµK : (D â†’ B ) â†’ 1 + D computable such that ÎµK (p) = example, and otherwise ÎµK (p) âˆˆ K and p(ÎµK (p)) = tt. In fact, given ÎµK one can deï¬ne eK = ÎµK (Î»x. tt) and ÎµK (p) = if p(ÎµK (p)) then ÎµK (p) else . Conversely, given ÎµK and eK as speciï¬ed, one can deï¬ne ÎµK (p) = if ÎµK (p) = then eK else ÎµK (p). if there is no

The empty set is exhaustible with realizer âˆ€âˆ… (p) = tt, but it is not searchable because the condition Îµâˆ… (p) âˆˆ âˆ… cannot hold. But weâ€™ll see in Section 3.4 that, for non-empty entire sets, deï¬ned below, the two notions turn out to agree. 5

Deï¬nition 2.2.5. We say that a set K is entire if it consists of total elements and is closed under total equivalence. Notice that if p is total then it is deï¬ned on every entire set. Even if p is not total and K is not entire, p(x) = p(x ) for all x âˆ¼ x in K , because if x âˆ¼ x then x and x are bounded above and hence so are p(x) and p(x ), which then must be equal as they are non-bottom by deï¬nition. But if x âˆˆ K and x âˆ¼ x for x outside K , it doesnâ€™t follow that p(x ) = âŠ¥ (consider e.g. K = {Î»i. tt} for Ïƒ = Î¹ â†’ o and p(Î±) = Î±(âŠ¥)). Let DÏ‰ = (N â†’ D) and, for any sequence Ki of subsets of D, let i Ki be the set of functions Î± âˆˆ DÏ‰ with Î±i = Î±(i) âˆˆ Ki for all i âˆˆ N âŠ† N . The following closure properties of entire sets are easily veriï¬ed: 1. If K âŠ† D and K âŠ† D are entire, so is K Ã— K âŠ† D Ã— D 2. If Ki is a sequence of entire subsets of D, then
i

Ki is an entire subset of DÏ‰ .

Deï¬nition 2.2.6. The image of an entire set by a total function doesnâ€™t need to be entire, but it consists of total elements, and hence its closure under total equivalence is entire. We refer to this as its entire image. (Thus, entire images are deï¬ned for total functions and entire sets only.) Deï¬nition 2.2.7. 1. An entire set F âŠ† D is decidable if there is a total computable map ÏˆF : D â†’ B such that, for all total x âˆˆ D, ÏˆF (x) = tt iff x âˆˆ F . 2. For given K âŠ† D, we say that a set F âŠ† D is decidable on K if there is a computable map ÏˆF : D â†’ B deï¬ned on K such that, for all x âˆˆ K , ÏˆF (x) = tt iff x âˆˆ F . (Then an entire set F is decidable if and only if it is decidable on T .) 3. An entire set F âŠ† D is semi-decidable if there is a computable map Ï‡F : D â†’ B such that, for all total x âˆˆ D, ÏˆF (x) = tt if x âˆˆ F , and ÏˆF (x) = âŠ¥ otherwise. 4. F is co-semi-decidable if its complement in the set of total elements is decidable. Notice that the functions ÏˆF and Ï‡F are not uniquely determined by F , because their behaviours are speciï¬ed on a subset of D.

2.3 Building new searchable sets from old
We develop algorithms that show that exhaustible and searchable sets are closed under various constructions. Starting from the ï¬nite sets, this allows one to systematically build plenty of inï¬nite searchable sets. Proposition 2.3.1. Let K, F âŠ† D with F decidable on K . 1. If K is exhaustible then so is K âˆ© F . 2. If K is searchable then so is K âˆ© F , provided it is non-empty. Proof. Deï¬ne âˆƒK âˆ©F (p) = âˆƒx âˆˆ K.ÏˆF (x) âˆ§ p(x), ÎµK âˆ©F (p) = if âˆƒx âˆˆ K âˆ© F.p(x) then ÎµK (Î»x.Ïˆ (x) âˆ§ p(x)) else ÎµK (ÏˆF ). The topological motivation for the above proposition is that the intersection of a closed set with a compact set is compact. Decidable sets correspond to sets that are open and closed, and hence, bearing in mind that exhastible sets (ought to) correspond compact sets, the above proposition ought to be true, which it is. The motivation for the following proposition is that, in topology, continuous images of compact sets are compact. In fact, it arises by replacing continuity by computability and compactness by exhaustibility. For later use, we also make sure it holds in the world of entire sets. 6

Proposition 2.3.2. Exhaustible and searchable sets are closed under the formation of computable images, and also under the formation of computable entire images. Proof. Given f : D â†’ D and K âŠ† D exhaustible, deï¬ne âˆ€f (K ) (q ) = âˆ€x âˆˆ K.q (f (x)). This proves closure of exhaustible sets under images. Regarding entire images of entire exhaustible sets, if f is total and K is entire with entire image L, then we can take âˆ€L = âˆ€f (K ) . To verify this, let q be deï¬ned on L. Then q is deï¬ned on f (K ) âŠ† L, and hence if q (l) = tt for all l âˆˆ L, then âˆ€L (q ) = tt. If, on the other hand, q (l) = ï¬€ for some l âˆˆ L, then l âˆ¼ f (x) for some x âˆˆ K . But then q (f (x)) = ï¬€ , and so âˆ€T (q ) = ï¬€ , which concludes the veriï¬cation. For K âŠ† D searchable, deï¬ne Îµf (K ) (q ) = f (ÎµK (Î»x.q (f (x))). That is, ï¬rst ï¬nd x such that q (f (x)) holds, using ÎµK , and then apply f to such x. This proves closure under images, and the argument for entire images is similar to the previous. The following corresponds to the fact that compact sets in topology are closed under ï¬nite products: Proposition 2.3.3. Exhaustible and searchable sets are closed under the formation of ï¬nite products. Proof. For K âŠ† D and K âŠ† D exhaustible, deï¬ne âˆ€K Ã—K (p) = âˆ€x âˆˆ K.âˆ€x âˆˆ K .p(x, x ). For K âŠ† D and K âŠ† D searchable, to compute ÎµK Ã—K (p) we ï¬rst ï¬nd x âˆˆ K such that there is x âˆˆ K with p(x, x ), and then ï¬nd x âˆˆ K such that p(x, x ), i.e. x = ÎµK (Î»x.âˆƒx âˆˆ K .p(x, x )), x = ÎµK (Î»x .p(x, x )), using the fact that searchable sets are exhaustible, and let ÎµK Ã—K (p) = (x, x ). Compact sets in topology are closed under arbitrary products. We now show that searchable sets are closed under countable products. We would like show that for any sequence searchable sets Ki âŠ† Di , their product i Ki âŠ† i Di is also searchable, but this would require dependent types, which are not part of the traditional higher-type computation formalism. So we assume that the components Ki of the product are all subsets of the same type D, so that i Ki âŠ† DÏ‰ instead. Given search functionals ÎµKi âˆˆ ((D â†’ B ) â†’ D), we wish to ï¬nd a search functional ÎµQi Ki âˆˆ ((DÏ‰ â†’ B) â†’ DÏ‰ ). The idea, that iterates the proof of Proposition 2.3.3, is to let ÎµQi Ki (p) = x0 x1 x2 . . . xn . . . , where x0 âˆˆ K0 is such that âˆƒÎ± âˆˆ
i

Ki+1 .p(x0 Î±), 7

x1 âˆˆ K1 is such that âˆƒÎ± âˆˆ ... xn âˆˆ Kn is such that âˆƒÎ± âˆˆ ...

i

Ki+2 .p(x0 x1 Î±),

i

Ki+n+1 .p(x0 x1 . . . xn Î±),

The component xn will be found using ÎµKn , and existential quantiï¬cations will be recursively reduced to search. To make this precise, we change notation. Given Îµ âˆˆ ((D â†’ B) â†’ D)Ï‰ , such that Îµi searches over Ki , we wish to ï¬nd Î (Îµ) âˆˆ (DÏ‰ â†’ B) â†’ DÏ‰ that searches over
i

Ki . That is, we want a functional

Î  : ((D â†’ B) â†’ D)Ï‰ â†’ ((DÏ‰ â†’ B) â†’ DÏ‰ ) that transforms a sequence of search operators over D into a search operator over DÏ‰ : Î (Îµ)(p)(0) = x0 s.t. âˆƒÎ± âˆˆ Î (Îµ)(p)(1) = x1 s.t. âˆƒÎ± âˆˆ ... Î (Îµ)(p)(n) = xn s.t. âˆƒÎ± âˆˆ ... To complete the derivation of the functional Î , we reduce the existential quantiï¬cation to a suitable recursive call to Î . If the functional Î  is to meet its speciï¬cation, Î (Î»i.Îµi+n+1 ) should search over i Ki+n+1 . But a searchable set is exhaustible by Lemma 2.2.4. To implement the proof of this lemma in our situation, for any given p, n, xn , deï¬ne pn,xn (Î±) = p(x0 x1 . . . xnâˆ’1 xn Î±) = p(Î (Îµ)(p)(0)Î (Îµ)(p)(1) . . . Î (Îµ)(p)(n âˆ’ 1)xn Î±). Then âˆƒÎ± âˆˆ is equivalent to pn,xn (Î (Î»i.Îµn+i+1 )(pn,xn )). To ï¬nd xn such that this holds, we use Îµn : Î (Îµ)(p)(n) = Îµn (Î»xn .pn,xn (Î (Î»i.Îµn+i+1 ))(pn,xn )). Because we donâ€™t want a different variable xn for each n, we rename the variable to simply x. This completes our derivation of the product functional: Deï¬nition 2.3.4. The product functional Î  : ((D â†’ B) â†’ D)Ï‰ â†’ ((DÏ‰ â†’ B) â†’ DÏ‰ ) is recursively deï¬ned by Î (Îµ)(p)(n) = Îµn (Î»x.pn,x (Î (Î»i.Îµn+i+1 ))(pn,x )) 8
i i i i

Ki+1 .p(x0 Î±), Ki+2 .p(x0 x1 Î±),

Ki+n+1 .p(x0 x1 . . . xn Î±),

Ki+n+1 .p(x0 x1 . . . xn Î±)

where ï£± ï£¶ ï£´Î (Îµ)(p)(i) if i < n, ï£² ï£· ï£¬ pn,x (Î±) = p ï£­Î»i. x if i = n, ï£¸ ï£´ ï£³ Î±iâˆ’nâˆ’1 if i > n. ï£« Theorem 2.3.5. If each Îµi searches over a set Ki âŠ† D then Î (Îµ) searches over
i

Ki .

Proof. By construction, it is clear that p(Î (Îµ)(p)) = tt iff there is Î± âˆˆ i Ki with p(Î±) = tt, provided the recursion converges in the sense that Î (Îµ)(p) âˆˆ i Ki . To establish this, we ï¬rst show that p(Î (Îµ)(p)) = âŠ¥ for any p deï¬ned on i Ki . For Îµ and p ï¬xed, and for each ï¬nite sequence Î² over D, deï¬ne W (Î² ) = Î (Î»i .Îµi+|Î² | )(Î»Î±.p(Î²Î±)), where Î²Î± denotes the concatenation of Î² and Î±, and |Î² | denotes the length of Î² . It is easy to see that W (Î² ) satisï¬es the equation W (Î² ) = xW (Î²x) where x = Îµ|Î² | (Î»y.p(Î²yW (Î²y ))). Here Î²x denotes the sequence Î² extended by the element x, and xW (Î²x) is the sequence with ï¬rst element x followed by the sequence W (Î²x). Claim: For any Î² âˆˆ i<|Î² | Ki , if p(Î²W (Î² )) = âŠ¥ then then there is x âˆˆ K|Î² | such that p(Î²xW (Î²x)) = âŠ¥, and hence such that also p(Î²xâŠ¥) = âŠ¥. We establish the contrapositive, i.e. if Î»y.p(Î²yW (Î²y )) is deï¬ned on K|Î² | then p(Î²W (Î² )) = âŠ¥. By speciï¬cation of Îµ|Î² | , we have that x := Îµ|Î² | (Î»y.p(Î²yW (Î²y )) âˆˆ K|Î² | . By the above equation for W (Î² ) and by the assumption, we have that p(Î²W (Î² )) = p(Î²xW (Î²x)) = âŠ¥, which concludes the proof of the claim. For the sake of contradiction, assume p(Î (Îµ)(p)) = âŠ¥. Then p(Î²W (Î² )) = âŠ¥ for Î² empty. Hence, repeatedly applying the above claim starting with Î² empty, we get Î± âˆˆ i Ki such that p(Î±0 Î±1 Â· Â· Â· Î±n âŠ¥) = âŠ¥ for every n, and hence p(Î±) = âŠ¥ by continuity of p, which contradicts the hypothesis that p is deï¬ned on i Ki and concludes the proof that p(Î (Îµ)(p)) = âŠ¥ for all Îµ such that Îµi searches over Ki and all p deï¬ned on i Ki . Finally using this, an easy argument by course-of-values induction on n shows that, for all Îµ such that Îµi searches over Ki and all p deï¬ned on i Ki , we have that Î (Îµ)(p)(n) âˆˆ Kn . Therefore Î (Îµ)(p) âˆˆ i Ki . The following gives a uniform continuity principle. Deï¬ne Î± =n Î² â‡â‡’ Î±i = Î²i for all i < n, Î±|n (i) = Î±i âŠ¥ i < n, otherwise.

Theorem 2.3.6. If f âˆˆ (DÏ‰ â†’ E ) is deï¬ned on a product i Ki of searchable sets, where E = DÎ³ for some ground type Î³ , then there is a number n such that for all Î±, Î± âˆˆ i Ki , Î± =n Î± =â‡’ f (Î±) = f (Î± ). Proof. Let (==) âˆˆ (E Ã— E â†’ B) be the unique total function such that (x == y ) = tt iff x âˆ¼ y . Then âˆ€Qi Ki (Î»Î±.f (Î±) == f (Î±)) = tt. If we deï¬ne f|n (Î±) = f (Î±|n ), then f = n f|n and hence (Î»Î±.f (Î±) == f (Î±)) = continuity of âˆ€Qi Ki , there is n such that
n (Î»Î±.f|n (Î±)

== f (Î±)). So, by

âˆ€Qi Ki (Î»Î±.f|n (Î±) == f (Î±)) = tt .

9

We cannot conclude that f|n (Î±) == f (Î±) for all Î± âˆˆ i Ki because there is no reason why the predicate Î»Î±.f|n (Î±) == f (Î±) should be deï¬ned on i Ki . To overcome this difï¬culty, let Î² âˆˆ i Ki+n and deï¬ne gn (Î±) = f (Î±0 Î±1 . . . Î±nâˆ’1 Î² ) so that gn is deï¬ned on i Ki and above gn . By monotonicity, âˆ€Qi Ki (Î»Î±.gn (Î±) == f (Î±)) = tt . Now the predicate Î»Î±.gn (Î±) == f (Î±) is deï¬ned on i Ki and hence gn (Î±) = f (Î±) for all Î± âˆˆ i Ki . But if Î± =n Î± then gn (Î±) = gn (Î± ), and so f (Î±) = f (Î± ), as required. The following is an immediate consequence of this and Theorem 2.3.5: Corollary 2.3.7. The functional fan = fanQi Ki : (DÏ‰ â†’ E ) â†’ N deï¬ned by fan(f ) = Âµn.âˆ€Î±, Î± âˆˆ
i

Ki .Î± =n Î² =â‡’ f (Î±) = f (Î² )

is computable uniformly in any sequence of searchers of the sets Ki , and is deï¬ned on any f that is deï¬ned on i Ki . Moreover, if the sets Ki are entire, then the fan functional is total. This is the case, for instance, if D = N and each Ki is a ï¬nite subset of N deï¬ned uniformly in i, which is the case that has been considered in higher-type computability theory regarding the fan functional (see e.g. [11]). Here we have generalized this to arbitrary higher types D = DÏƒ . Remark 2.3.8. Bergerâ€™s algorithm [5] ÎµBerger : (B Ï‰ â†’ B) â†’ B for searching over the total elements of B Ï‰ , mentioned in the introduction, can be written as: tt #ÎµBerger (Î»Î±.p(tt #Î±)) if p(tt #ÎµBerger (Î»Î±.p(tt #Î±))), ÎµBerger (p) = ï¬€ #ÎµBerger (Î»Î±.p(ï¬€ #Î±)) otherwise, where (#) : B Ã— B Ï‰ â†’ BÏ‰ is deï¬ned as (x#Î±)(i) = x Î±iâˆ’1 if i = 0, otherwise.

Using our product functional, another algorithm is given by Îµ where ÎµB : (B â†’ B) â†’ B ÎµB (p) = p(tt) is a search operator for the set B of total elements of B . These two algorithms and others will be compared for run-time behaviour in Section 4.
Q

= Î (Î»i.ÎµB ),

3

Topologically based algorithms

The previous section is relies on the analogy of topology with computation while this one applies theorems of topology to computation. One can say that the algorithmic aspects of higher-type computation belong to algebra and logic, whereas the aspects that relate the inï¬nite character of higher-type objects to the ï¬nite nature of higher-type computation processes belong to topology.

10

3.1 Background on compactly generated spaces
Compactly generated Hausdorff spaces, or k -spaces, to be introduced shortly, are to total computation as Scott domains are to partial computation. This is made precise in Section 3.2. Here we brieï¬‚y introduce k -spaces and some of their fundamental topological properties that are applied to prove the computational theorems of this section. For more details and proofs, see e.g. [9] and the references contained therein. We begin by considering the Hausdorff case. If F is a closed set of a Hausdorff space X , then K âˆ© F is closed for every compact set K âŠ† X . Any set F that satisï¬es this condition is called k -closed. The Hausdorff space X is a k -space iff every k -closed set is closed. (This is equivalent to saying that X is the colimit of its compact subspaces ordered by inclusion.) Any Hausdorff space can be transformed into a k -space by stipulating that all k -closed sets are closed. In categorical terms, this construction is a coreï¬‚ection of the category of Hausdorff spaces into its subcategory of k -spaces. The category of Hausdorff k -spaces is cartesian closed. Given objects X and Y , their categorical product X Ã— Y is the coreï¬‚ection their topological product. Their exponential Y X consists of the continuous maps X â†’ Y under the coreï¬‚ection of the compact-open topology. The compact-open topology has subbasic open sets of the form N (Q, V ) = {f âˆˆ Y X | f (Q) âŠ† V }, where Q is a compact subset of X and V is an open subset of V . Cartesian closedness amounts to the fact that the evaluation map YX Ã—X â†’ Y f (x)

(f, x) â†’

is continuous, and that for any continuous map f : Z Ã— X â†’ Y , its transpose Â¯ f: Z z â†’ â†’ YX (x â†’ f (z, x))

Â¯ is continuous. Equivalently, f is continuous iff f is continuous. We also need to consider k -spaces without the restriction to the Hausdorff case. Let X be an arbitrary topological space. A probe is a continuous function p : K â†’ X where K is a compact Hausdorff space. A set F âŠ† X is k -closed if pâˆ’1 (F ) is closed for every probe p : K â†’ X . Then, again, X is a k -space iff every k -closed set is closed, and k spaces form a cartesian closed category, and the inclusion of Hausdorff k -spaces preserves products and exponentials. All locally compact spaces are k -spaces, and this includes nonHausdorff examples such as Scott domains under the Scott topology. The description of the products and exponentials in the general case is omitted and the reader is referred to the above references, but in any case they are not needed for the purposes of this work, with one exception: an exponential of k -spaces whose base is the Sierpinski space has the Scott topology [9]. This is applied in the proof of the following lemma. Denote by S the Sierpinski space with an isolated point and a limit point âŠ¥. Then a function p : X â†’ S is continuous iff pâˆ’1 ( ) is open, and a set U âŠ† X is open iff its characteristic function Ï‡U , deï¬ned by Ï‡U (x) = â‡â‡’ x âˆˆ U , is continuous. Thus, using the Sierpinski space, the notion of openness is reduced to that of continuity. The following reduces the notion of compactness to that of of continuity (a particular case of this is proved in [7], with essentially the same proof as the one give here). Lemma 3.1.1. If X is a k -space, a set K âŠ† X is compact if and only if the universal quantiï¬cation functional âˆ€K : S X â†’ S deï¬ned by âˆ€K (p) = is continuous. 11 iff p(x) = for all x âˆˆ K

Proof. A set K is compact if and only if every directed cover of K by open sets has a member that covers K , because from any cover one obtains a directed cover with the same union by adding the ï¬nite unions of the members of the cover. Hence by deï¬nition of the Scott topology, a set is compact if and only if its open-neighbourhood ï¬lter is open in the Scott topology of the lattice of open sets. But U â†’ Ï‡U is a bijection from the lattice of open sets to the points of S X , and it was shown in [9] that the topology of the exponential S X is the one induced by this bijection. Hence the functional âˆ€K is continuous iff âˆ€âˆ’1 ( ) is open iff the set of characteristic functions Ï‡U with K âŠ† U is open iff the K open neighbourhood ï¬lter of K is open iff K is compact.

3.2 Background on Kleeneâ€“Kreisel functionals
For each type Ïƒ , deï¬ne by induction a set CÏƒ of Kleeneâ€“Kreisel functionals of type Ïƒ and a surjection ÏÏƒ : TÏƒ â†’ CÏƒ as follows, so that CÏƒ âˆ¼ TÏƒ / âˆ¼Ïƒ . = For ground types and product types, deï¬ne Co = To , CÎ¹ = T Î¹ , ÏÎ³ (x) = x. ÏÏƒÃ—Ï„ = ÏÏƒ Ã— ÏÏ„ .

CÏƒÃ—Ï„ = CÏƒ Ã— CÏ„ ,

For function types, consider the diagram DÏƒ  (â€ ) f ? DÏ„  (1)
âŠƒ âŠƒ

TÏƒ

ÏÏƒ

- CÏƒ Ï† ? CÏ„ .

(2) ? TÏ„ ÏÏ„ -

The square (1) commutes for some map TÏƒ â†’ TÏ„ if and only if f âˆˆ TÏƒâ†’Ï„ , and in this case the map is uniquely determined as the (co)restriction of f . Moreover, in this case, there is a unique map Ï† making the square (2) commute, because ÏÏƒ is a surjection. We deï¬ne CÏƒâ†’Ï„ = {Ï† : CÏƒ â†’ CÏ„ | âˆƒf âˆˆ TÏƒâ†’Ï„ .(2) commutes}, ÏÏƒâ†’Ï„ (f ) = the unique Ï† such that (2) commutes. Then, by construction, for any Ïƒ and all x, y âˆˆ DÏƒ , we have that x âˆ¼Ïƒ y iff x, y âˆˆ TÏƒ and ÏÏƒ (x) = ÏÏƒ (y ). If (â€ ) commutes, we say that f is a realizer of Ï†. A Kleeneâ€“Kreisel functional is computable iff it has a computable realizer. Lemma 3.2.1. Every CÏƒ is a computable retract of CÏ„ â†’Î¹ for some Ï„ . A stronger form of this is known as â€œsimple types are retracts of pure typesâ€ (see e.g. [17]). Here we use the fact that every pure type is either Î¹ or of the form Ï„ â†’ Î¹, and that Î¹ is a retract of Ï„ â†’ Î¹ for any Ï„ .

12

Hylandâ€™s characterization of Kleeneâ€“Kreisel functionals. For certain proofs and constructions of algorithms, we consider a topology on the set of Kleene-Kreisel functionals. Deï¬nition 3.2.2. Endow TÏƒ with the relative Scott topology and CÏƒ with the quotient topology of the surjection ÏÏƒ : TÏƒ â†’ CÏƒ . We refer to this topology on CÏƒ as the Kleeneâ€“ Kreisel topology, and to the resulting spaces CÏƒ as Kleeneâ€“Kreisel spaces. The points of the Kleeneâ€“Kreisel are often referred to as the continuous functionals in the higher-type computability (or higher-type recursion theory) literature. A proof of the following inductive topological characterization of the Kleeneâ€“Kreisel spaces, attributed to Hyland, can be found in Normann [19]. Lemma 3.2.3. 1. CÎ³ has the discrete topology for Î³ ground, 2. CÏƒÃ—Ï„ = CÏƒ Ã— CÏ„ and 3. CÏƒâ†’Ï„ = CÏ„ CÏƒ , where the product and exponential are calculated in the cartesian closed category of Hausdorff k -spaces. The following two lemmas, which are part of the folklore of the subject, are applied in order to show that exhaustible sets of total elements are compact in the Kleeneâ€“Kreisel topology (Lemma 3.3.4(1)). A set is called clopen if it is both closed and open. Lemma 3.2.4. For every clopen U âŠ† CÏƒ there is a total predicate p âˆˆ (DÏƒ â†’ B) such that Ïâˆ’1 (U ) âŠ† pâˆ’1 (tt) and Ïâˆ’1 (CÏƒ \ U ) âŠ† pâˆ’1 (ï¬€). Ïƒ Ïƒ Proof. Because U is clopen, its characteristic function Ï‡U : C â†’ B is continuous, and hence so is the composite i â—¦ Ï‡U â—¦ ÏÏƒ : TÏƒ â†’ B , where i : B â†’ B in the inclusion. Because T is dense in D (see e.g. [6]) and because Scott domains, and hence B , are densely injective (see e.g. [12]), by deï¬nition of injectivity this extends to a continuous function p : DÏƒ â†’ B. Then p is total by construction, and the extension property amounts to the above set inclusions. A space is zero-dimensional iff it has a base of clopen sets. It is an open problem whether the spaces CÏƒ are zero-dimensional [3, 21]. If they are, the following lemma becomes superï¬‚uous. The zero-dimensional reï¬‚ection Z C of a space C is obtained by taking the same set of points and the clopen sets as a base. Lemma 3.2.5. Z CÏƒ and CÏƒ have the same compact subsets. Proof. We ï¬rst show that KZ CÏƒ = CÏƒ for any type Ïƒ , where K is the coreï¬‚ector into the category of k -spaces. The property KZ C = C is easily seen to be inherited by retracts, and hence, by Lemma 3.2.1, it is enough to consider Ïƒ = Ï„ â†’ Î¹, and hence C = NY for some k -space Y . Exponentials in k -spaces are given by the k -coreï¬‚ection of the compact-open topology on the set of continuous maps. When the target is N, the compact-open topology is clearly zero-dimensional and Hausdorff. Now, it is easy to see that KZ C = C iff there is some zero-dimensional topology whose k -reï¬‚ection is C , and hence we are done. The result then follows from the well-known fact that a Hausdorff space has the same compact sets as its k -coreï¬‚ection.

13

3.3 Compactness of exhaustible sets
A notion analogous to exhaustibility, with the Sierpinski domain S playing the role of the boolean domain B , is considered in [7]. A crucial fact, formulated here as Lemma 3.1.1, is that the (now unique) exhaustion functional âˆ€K : (D â†’ S ) â†’ S is continuous iff the set K is compact in the Scott topology of D. Hence, because computable functionals are continuous, Sierpinski-exhaustible sets are compact, and so Sierpinski exhaustibility is seen as articulating an algorithmic version of the topological notion of compactness. The computational idea is that, given any semi-decidable property of D, one can semi-decide whether it holds for all elements of K . Closure properties analogous to the above are established for Sierpinski exhaustibility in [7] (and redeveloped from a purely operational point of view in [8]). The present investigation can be seen as a natural follow-up of that work that arises by asking what changes if one moves from semi-decision problems to decision problems. One signiï¬cant change is that continuity of a boolean exhaustion operator âˆ€K : (D â†’ B) â†’ B doesnâ€™t entail the compactness of K in the Scott topology any longer. Examples 3.3.1. 1. There are exhaustible sets that fail to be compact in the Scott topology. By [28, 26], any second-countable T0 space, e.g. the real line R, can be embedded into the domain D = B Ï‰ . But R is a connected space, which is equivalent to saying that every continuous boolean-valued map deï¬ned on it is constant. Hence a predicate p âˆˆ (D â†’ B ) is deï¬ned on R iff it is constant on R. Therefore R is trivially exhaustible: âˆ€R (p) = p(0). But it is not compact. Notice also that any space embedded into the total elements of B Ï‰ must be totally disconnected, and hence any embedding of R into B Ï‰ must assign non-total elements of B Ï‰ to some real numbers. One may suspect that if such embeddings are ruled out, this problem would disappear. But this is not the case, as the next example shows. 2. There are exhaustible sets of total elements that fail to be Scott compact. In fact, there is a trivial and pervasive counter-example. Let f âˆˆ D where D = ((N â†’ N ) â†’ N ). Then the total equivalence class K of f , as is well known and easy to verify, doesnâ€™t have a minimal element, and hence cannot be compact in the Scott topology. But it is exhaustible with âˆ€K (p) = p(f ). However, although exhaustible sets fail to be compact in the Scott topology, if they consist of total elements then they are compact in the Kleeneâ€“Kreisel topology. In order to formulate and prove this, we need some deï¬nitions. As in the previous sections, D = DÏƒ for some unspeciï¬ed Ïƒ , and, additionally T = TÏƒ , C = CÏƒ and Ï = ÏÏƒ : TÏƒ â†’ CÏƒ . Deï¬nition 3.3.2. 1. By the shadow of a set K âŠ† T we mean its Ï-image in C . 2. A set K âŠ† T is called Kleeneâ€“Kreisel compact if its shadow is compact. 3. The Cantor space is the set of strict total elements of B Ï‰ = (N â†’ B ), that is those total elements Î± with Î±(âŠ¥) = âŠ¥, under the relative Scott topology. Notice that: 1. The Cantor space is a proper subset of the set of total elements of B Ï‰ , because it excludes precisely the two non-strict elements Î»i. tt and Î»i. ï¬€ . However, it still includes their strict versions. 2. The Cantor space (under the relative Scott topology) is homeomorphic to its shadow 2N (under the Kleeneâ€“Kreisel topology) and hence is a compact Hausdorff space. 14

3. The set of maximal elements of B Ï‰ is not homeomorphic to the Cantor space. This is because the two elements Î»i. tt and Î»i. ï¬€ are ï¬nite (or order compact), and hence isolated in the relative Scott topology (meaning that the two corresponding singletons are open), and hence the maximal elements have a topology strictly ï¬nner than that of the Cantor space, as there are no isolated points in the Cantor space. As is well known in topology, no compact Hausdorff topology can have another compact Hausdorff topology as a strict reï¬nement. Every (computationally) exhaustible set is topologically exhaustible in the sense of the following deï¬nition, because computable maps are continuous. Deï¬nition 3.3.3. 1. We say that a set K âŠ† D is topologically exhaustible if there is a continuous map âˆ€K âˆˆ ((D â†’ B ) â†’ B) satisfying the conditions of Deï¬nition 2.2.2. 2. Similarly, we say topologically decidable etc. taking the continuous versions of Definition 2.2.7. The following is our main tool in the constructions and proofs of correctness and termination of the algorithms developed in this section. Lemma 3.3.4. 1. Any topologically exhaustible set of total elements is Kleeneâ€“Kreisel compact. 2. Any non-empty, Kleeneâ€“Kreisel compact entire set is an entire continuous image of the Cantor space and hence is topologically exhaustible. (The empty set is trivially exhaustible, as we have already seen, and hence all Kleeneâ€“ Kreisel compact entire sets are topologically exhaustible.) 3. Any Kleeneâ€“Kreisel compact entire set has a Scott compact subset with the same shadow. Proof. (1): Let K âŠ† T be exhaustible. By Lemma 3.2.5 and the fact that clopen sets are closed under ï¬nite unions, to establish compactness of Ï(K ), it is enough to consider a directed clopen cover U . By Lemma 3.2.4, for every U âˆˆ U there is a total pU âˆˆ (D â†’ B) with
âˆ’ (â€ ) Ïâˆ’1 (U ) âŠ† pU 1 (tt) and Ïâˆ’1 (C \ U ) âŠ† pâˆ’1 (ï¬€). U

Deï¬ne predicates qU , r âˆˆ (D â†’ B) by
âˆ’ qU 1 (tt) = pâˆ’1 (tt), U

râˆ’1 (tt) =
U âˆˆU

âˆ’ pâˆ’1 (tt) and qU 1 (ï¬€) = râˆ’1 (ï¬€) = âˆ…. U

Then qU pU , the set {qU | U âˆˆ U } is directed, and r = U âˆˆU qU . Because Ï(K ) âŠ† U , we have that K âŠ† râˆ’1 (tt) and hence âˆ€K (r) = tt. So, by continuity of âˆ€K , there is U âˆˆ U with âˆ€K (qU ) = tt, and hence with âˆ€K (pU ) = tt by monotonicity. Let x âˆˆ K . Then pU (x) = tt by speciï¬cation of âˆ€K and the fact that pU is total and hence deï¬ned on K . But then Ï(x) âˆˆ U , for otherwise (â€ ) would entail pU (x) = ï¬€ . This shows that Ï(K ) âŠ† U , and so Ï(K ) is compact. (2): By e.g. [9], any compact subset of C is countably based (even though C is not). But any non-empty compact Hausdorff countably based space is a continuous image of the Cantor space. Hence there is a continuous map BN â†’ C with image Ï(K ) for any entire set K âŠ† D. Then the entire image of the Cantor space under any realizer B Ï‰ â†’ D is K . (3): This follows from the argument given in (2). 15

Remark 3.3.5. In particular, this gives a topological view of the computational fact stated in the introduction that exhaustible sets of natural numbers must be ï¬nite: all compact sets are ï¬nite in a discrete space. (There is a natural on topology on D, coarser than the Scott topology, in which all exhaustible sets are compact. Part of the argument of Lemma 3.3.4(1) shows that any exhaustible set K is compact in the coarsest topology on D such that all predicates p âˆˆ (D âˆˆ B ) deï¬ned on K are continuous. This is generated by directed unions of basic open sets of the form pâˆ’1 (tt) with p as above, because such sets are closed under ï¬nite unions and intersections. This construction is analogous to the zero-dimensional reï¬‚ection of a topology, and happens to coincide with it in the case considered in Lemma 3.3.4(1), modulo quotienting.)

3.4 Some computational properties of exhaustible sets
We already know that every searchable set is exhaustible (Lemma 2.2.4). This implication is uniform, in the sense that there is a computable functional ((D â†’ B) â†’ D) â†’ ((D â†’ B ) â†’ B) that transforms search operators into exhaustion operators, namely Îµ â†’ (Î»p.p(Îµ(p))). We now establish the converse for non-empty entire sets, and some additional results. Deï¬nition 3.4.1. We say that a set S âŠ† D = DÏƒ is a total retract if there is a function r âˆˆ (D â†’ D) such that 1. r(x) âˆˆ S for all total x âˆˆ D, 2. r(s) âˆ¼ s for all s âˆˆ S . In this case, r is total, all elements of S are total, and r(r(x)) âˆ¼ r(x) for all total x. Notice that a total retract is not necessarily a retract. But r is a total retract iff it is a total function and its Kleeneâ€“Kreisel shadow Ï(r) : C â†’ C is a retract in the usual topological sense, where C = CÏƒ . Theorem 3.4.2. If K âŠ† DÏƒ is a non-empty, exhaustible entire set then, uniformly in any exhaust or of K : 1. K is searchable. 2. K is a computable entire image of the Cantor space. 3. The shadow of K is (computably) homeomorphic to the shadow of some entire exhaustible subset of the Baire domain N Ï‰ . 4. K is a computable total retract. 5. K is co-semi-decidable. In particular, after the theorem is proved, one can w.l.o.g. work with total predicates rather than predicates deï¬ned on K , as for any predicate p âˆˆ (DÏƒ â†’ B) deï¬ned K one can uniformly ï¬nd a total predicate that agrees with p on K , by composition with the total retraction.

16

Proof. We proceed by cases, of increasing generality, on the type of K . The case K âŠ† N is trivial and is implicitly used in the case K âŠ† N Ï‰ , which in turn is used in the next case K âŠ† (D â†’ N ). The general case K âŠ† D is reduced to this last case via retracts using Lemma 3.2.1. (1) Case K âŠ† N : We can deï¬ne ÎµK (p) = Âµn.âˆƒm âˆˆ K.n = m âˆ§ p(n) if âˆƒn âˆˆ K.p(n), Âµn.âˆƒm âˆˆ K.n = m otherwise.

Notice that this construction deï¬nes ÎµK uniformly in âˆƒK . We could now easily show that K satisï¬es the other conditions of the theorem, but this wonâ€™t be required for our proof, as this will follow in later cases. For future use, notice that if K âŠ† N is entire and exhaustible, then the supremum of the ï¬nite set K (which is zero if K is empty and the largest element of K otherwise) can be computed uniformly in any exhaustor of K as sup K = Âµm.âˆ€n âˆˆ K.n â‰¤ m. Hence, the ï¬nite enumeration en of the elements of K , in ascending order, for 0 â‰¤ n < cardinality(K ), is uniformly computable as en = Âµy.âˆƒm âˆˆ K.âˆ€i < n.m = ei âˆ§ m = y. We stop when we ï¬nd n such that en = sup K , and we include en if and only if âˆƒm âˆˆ K.m = sup K . (2) Case K âŠ† N Ï‰ . We ï¬rst argue that we can ï¬nd some Î± âˆˆ K , uniformly in âˆƒK , by the following algorithm deï¬ned by course-of-values induction on n: Î±n = Âµk.âˆƒÎ² âˆˆ K.Î± =n Î² âˆ§ Î²n = k. Recall that we deï¬ned Î± =n Î² â‡â‡’ âˆ€i < n.Î²i = Î±i in the paragraph preceding Theorem 2.3.6. By construction, for every n there is Î² âˆˆ K with Î± =n Î² , and in particular Î± is total. Because the shadow of K is compact, it is closed, and because K is entire, Î± âˆˆ K , as required. Then we can deï¬ne, using Proposition 2.3.1 and the above algorithm to construct Î± is both cases, ÎµK (p) = some Î± âˆˆ K âˆ© pâˆ’1 (tt) if âˆƒÎ± âˆˆ K.p(Î±), some Î± âˆˆ K otherwise.

Again, this construction deï¬nes ÎµK uniformly in âˆƒK . We now show that K is a computable total retract, uniformly in any exhaustor of K . Deï¬ne r = rK : N Ï‰ â†’ N Ï‰ by course-of-values induction on n: r(Î±)(n) = Î±n Âµm.âˆƒÎ² âˆˆ K.Î² =n r(Î±) âˆ§ Î²n = m if âˆƒÎ² âˆˆ K.Î² =n r(Î±) âˆ§ Î²n = Î±n , otherwise.

Because the shadow of K is closed, the ï¬nite preï¬ces of its members form a tree whose inï¬nite paths correspond to the elements of K . The above algorithm follows the inï¬nite path Î± through the tree, either for ever (always following the ï¬rst case) or until the path 17

exits the tree (reaching the second case). If and when Î± exits the tree, we replace the remainder of Î± by the left-most inï¬nite branch of the subtree at which Î± exits the tree. Then r clearly satisï¬es the required conditions. A semi-decision procedure for the complement of K is given by Î± âˆˆ K â‡â‡’ r(Î±) = Î±, using the fact that apartness of total elements of N Ï‰ is semi-decidable. (This is a computational version of the topological fact and proof that retracts of Hausdorff spaces are closed.) We now show that K is a computable entire image of the Cantor space. For any i, the set Ki = {Î±i | Î± âˆˆ K } is exhaustible by Proposition 2.3.2 as evaluation at i is computable. It is enough to show that i {0, 1, . . . , sup Ki } âŠ† N Ï‰ is an entire image of the Cantor space by a computable map t : B Ï‰ â†’ N Ï‰ , because then r â—¦ t has K as its entire image since K is contained in that product. But this is straightforward: at each stage j of the computation of t(Î±), look at the next log2 (sup Kj ) digits of the input Î± (regarding ï¬€ and tt as digits 0 and 1), compute the natural number f (j ) represented by this ï¬nite sequence, and let t(Î±)(j ) = min(sup Kj , f (j )). (3) Case K âŠ† (D â†’ N ) where D = DÏƒ for an arbitrary type Ïƒ : In order to reduce this to case (2), we invoke the Kleeneâ€“Kreisel density theorem (see e.g. [6]), which gives a computable sequence d âˆˆ DÏ‰ such that the shadow sequence Ï(dn ) | n âˆˆ N is dense in C = CÏƒ . Deï¬ne P : (D â†’ N ) â†’ N Ï‰ P (f ) = Î»n.f (dn ). We will deï¬ne a total function E = EK in the other direction, E : N Ï‰ â†’ (D â†’ N ) such that R = E â—¦ P : (D â†’ N ) â†’ (D â†’ N ) exhibits K as a total retract of (D â†’ N ). This means that, for f âˆˆ K , one can recover the behaviour of f at total elements from its behaviour on the dense sequence d. Because this implies that K is the entire image of P (K ), and because P (K ) is searchable by case (2), it will follow that K is searchable and an entire image of the Cantor space. For Î± âˆˆ N Ï‰ and n âˆˆ N, deï¬ne
Î± Fn = {f âˆˆ (D â†’ N ) | âˆ€i < n.f (di ) = Î±i }, Î± Î± K n = K âˆ© Fn .

Î± Î± Then Fn is decidable on K uniformly in Î± and n, and hence Kn is uniformly exhaustible by Proposition 2.3.1.

Lemma 3.4.3. If K âŠ† (D â†’ N ) is a Kleeneâ€“Kreisel compact entire set, then for all total Î± Î± âˆˆ N Ï‰ and x âˆˆ D there is n such that f (x) = f (x) for all f, f âˆˆ Kn . Proof. For any g âˆˆ CÏ„ â†’Î¹ the set Bg = {f âˆˆ CÏ„ â†’Î¹ | f (x) = g (x)} is clopen, where we write x = Ï(x). By density of the shadow of sequence dn , the set n K Î± has at n Î± most one element, where K Î± denotes the shadow of Kn . Hence if g âˆˆ n K Î± then n n Î± Î± n K n = {g } âŠ† Bg . Because CÏ„ â†’Î¹ is Hausdorff and because each K n is compact and Bg is open, there is n such that already K Î± âŠ† Bg . So for all f âˆˆ K Î± one has n n f (x) = g (x), and hence for all f , f âˆˆ K Î± one has f (x) = f (x). n

18

By Proposition 2.3.2, the entire P -image L âŠ† N Ï‰ of K is exhaustible. Let r = rL be deï¬ned as in case (2), and deï¬ne
r E (Î±)(x) = Âµy.âˆƒf âˆˆ Kn(Î±) .f (x) = y,

where n is the least number such that âˆ€f, f âˆˆ Kn .f (x) = f (x). By exhaustibility r (Î±) of Kn , this can be found uniformly in Î±, and hence E is computable uniformly in K . Proof of correctness of E . (i) E is total and maps L into K . Let Î± âˆˆ N N be total. Then r(Î±) âˆˆ L, by construction r (Î±) of r, and hence there is g âˆˆ K with r(Î±) âˆ¼ P (g ), and so with g âˆˆ Kn . Let x âˆˆ D r (Î±) be total and n be the least number such that f (x) = f (x) for all f, f âˆˆ Kn . Then r (Î±) f (x) = g (x) for all f âˆˆ Kn , and hence E (Î±)(x) = g (x). Therefore E (Î±) âˆ¼ g âˆˆ K , and hence E (Î±) âˆˆ K as K is entire, and in particular E is total. By construction E âˆ¼ E â—¦ r, and hence, because r exhibits L as a total retract and K is entire, the E -image of L is K . (ii) If f âˆˆ (D â†’ N ) is total then R(f ) = E (P (f )) âˆˆ K . Because P (f ) âˆˆ L. (iii) If f âˆˆ K then R(f ) âˆ¼ f . Continuing from the proof of (i), for Î± = P (f ) we have r(Î±) âˆ¼ Î± by construction of r, and hence for any g âˆˆ K such that P (g ) = r(Î±) we have g (di ) = P (g )(i) = r(Î±)(i) = Î±i = P (f )(i) = f (di ) and so g âˆ¼ f by density, which shows that R(f ) = E (P (f )) âˆ¼ f , as required. A semi-decision procedure for the complement of K is given as in case (2), f âˆˆ K â‡â‡’ R(f ) = f, because f = f â‡â‡’ âˆƒn âˆˆ N.f (dn ) = f (dn ), for total functions f and f since K is entire and d is dense. Because E and P are total, they induce computable Kleeneâ€“Kreisel functionals E = Ï(E ) : NN â†’ NC and P = Ï(P ) : NC â†’ NN where C = CÏƒ . If K âŠ† NC is the shadow of K , then the restriction of P to K followed the co-restriction to its image is a homeomorphism K â†’ P (K ): abstractly because any continuous bijection of compact Hausdorff spaces is a homeomorphism, and concretely because the bi-restriction of E is a continuous inverse. Hence the shadow of any exhaustible subset of (D â†’ N ) is computably homeomorphic to the shadow of some exhaustible subset of the Baire domain N Ï‰ . (4) General case. We derive this from the case (3). By Lemma 3.2.1, for any D = DÏƒ there are D = DÏ„ â†’Î¹ and computable P : D â†’ D and E : D â†’ D such R = E â—¦ P is a total retraction and TÏƒ is the entire image of P . Let K âŠ† D be a non-empty, exhaustible entire set, and let K be the entire E -image of K . Then K is the entire image of P (K ), and, because K is entire, a predicate p âˆˆ (D â†’ B ) deï¬ned on K holds for all x âˆˆ K if and only if p â—¦ E holds for all x âˆˆ K . Hence K is exhaustible with âˆ€K (p ) = âˆ€K (p â—¦ E ). By case (3) above, K is searchable. Therefore K is searchable by Proposition 2.3.2. Similarly, the other properties we need to establish are closed under the formation of retracts and hence are inherited from case (3). This concludes the proof of Theorem 3.4.2.

r (Î±)

3.5 Arzelaâ€“Ascoli type characterizations of compact sets
We reformulate a theorem of Galeâ€™s [10] that characterizes compact subsets of function spaces (Theorem 3.5.1). The reformulation suggests a characterization of exhaustible entire sets (Theorem 3.6.1), whose topological version is developed here (Theorem 3.5.3). The main idea is to replace a condition in Galeâ€™s theorem by a continuity condition, and then further replace it by a computability condition in Section 3.6. This method of transforming 19

topological theorems into computational theorems is the main thrust of the paper [7], which develops many instances of computational manifestations of topological theorems. The Heineâ€“Borel theorem characterizes the compact subsets of Euclidean space Rn as those that are closed and bounded. The Arzelaâ€“Ascoli theorem generalizes this to subsets of RX , where X is a compact metric space and RX is the set of continuous functions endowed with the metric deï¬ned by d(f, g ) = max{d(f (x), g (x)) | x âˆˆ X }. A set K âŠ† RX is compact if and only if it is closed, bounded and equi-continuous. Equicontinuity of K means that the functions f âˆˆ K are simultaneously continuous, in the sense that for every x âˆˆ X and every > 0, there is Î´ > 0 such that d(x, x ) < Î´ =â‡’ d(f (x), f (x )) for all x âˆˆ X and all f âˆˆ K . The Heineâ€“Borel theorem is the particular case in which X is the discrete space {1, . . . , n}, for equi-continuity holds automatically for any subset of RX in this case. The above metric on RX induces the compactopen topology. More general Arzelaâ€“Ascoli type theorems characterize compact subsets of spaces Y X of continuous functions under the compact-open topology, for a variety of kinds of spaces X and Y , with a number of generalizations or versions of the notion of equi-continuity, notably even continuity in the sense of Kelley [14]. Among a multitude of generalizations of the Arzelaâ€“Ascoli theorem, that of Gale [10, Theorem 1] proves to be relevant concerning exhaustibility: Let X and Y be Hausdorff k -spaces with Y regular. A set K âŠ† Y X is compact if and only if 1. K is closed, 2. the set K (x) = {f (x) | f âˆˆ K } is compact for every x âˆˆ X , 3. the set f âˆˆK âˆ©F f âˆ’1 (V ) is open for every closed set F âŠ† Y X and every open set V âŠ† Y . Gale didnâ€™t assume Y to be a k -space and formulated this for the compact-open topology, but his theorem holds for the exponential topology if we require Y to be a k -space. Regarding compactness, we have already mentioned that a Hausdorff space has the same compact sets as its k -coreï¬‚ection, and that the exponential topology is the k -reï¬‚ection of the compact-open topology. Although there are more closed sets in the exponential topology, Galeâ€™s argument works with closedness of K in the exponential topology. This follows from the general considerations of Kelley [14, Chapter 7]. The last condition is a version of equi-continuity. Because X is not assumed to be compact, the set K cannot be globally bounded in any sense, but it is pointwise bounded in the sense of the second condition. This gives a characterization of compact subsets of Kleeneâ€“Kreisel spaces of the form NC and in particular of Kleeneâ€“Kreisel spaces of pure type, because N is regular. However, it is an open problem whether arbitrary Kleeneâ€“ Kreisel spaces are regular [3, 22], and this is partly why we are able to formulate and prove characterizations of exhaustible entire sets only for particular kinds of types in Section 3.6. Notice that when X = Y = N, this amounts to the well known characterization of compact subsets K of the Baire space NN as ï¬nitely branching trees. The equi-continuity condition, as in the case of the Heineâ€“Borel theorem, is superï¬‚uous, because any set is equi-continuous in this case as the topology of the exponent is discrete. Condition (1) says that the elements of K are the paths of a tree, and (2) says that the tree is ï¬nitely branching, because the compact subsets of the base space are ï¬nite. Lemma 3.1.1 and the remarks preceding it allow one to consider continuity of functions involving points of a k -space X , open sets and closed sets (using the function space S X and representing open sets and closed sets by their characteristic functions), and compact

20

sets (using the function space S S and representing compact sets by their universal quantiï¬cation functionals). We now reformulate Galeâ€™s theorem by expressing condition (3) as a continuous version of a slight strengthening of condition (2). Theorem 3.5.1. If X and Y are Hausdorff k -spaces with Y regular, a set K âŠ† Y X is compact if and only if 1. K is closed, and 2. (K âˆ© F )(x) is compact, continuously in F and x, for any closed set F âŠ† Y X and any x âˆˆ X . The dependence of (K âˆ© F )(x) in the parameters F and x is given by the functional X Y Î¦ : S Y Ã— X â†’ S S deï¬ned by Î¦(Ï‡F , x) = âˆ€(K âˆ©F )(x) , where we write Â¯ Ï‡F = Ï‡F c . Â¯ Proof. (â‡’): The set K is closed because Y X is Hausdorff. The set K âˆ© F is compact because F is closed. Because the evaluation map is continuous and because (K âˆ© F )(x) is the continuous image of K âˆ© F under evaluation at x, it is compact. To see that Î¦ is continuous, let v âˆˆ S Y . Then v (y ) = for all y âˆˆ (K âˆ© F )(x) â‡â‡’ v (f (x)) = for all f âˆˆ K âˆ© F â‡â‡’ f âˆˆ F c or v (f (x)) for all f âˆˆ K . Hence Î¦(w, x) = Î»v.âˆ€f âˆˆ K.w(f ) âˆ¨ v (f (x)), where (âˆ¨) : S Ã—S â†’ S is deï¬ned by a âˆ¨ b = iff a = or b = . Because the functional âˆ€K is continuous as K is compact, and because the category of k -spaces is cartesian closed and the above is a Î»-deï¬nition from continuous maps, Î¦ is continuous. (â‡): It sufï¬ces to show that Galeâ€™s conditions (1)-(3) hold. Condition (1) is the same as ours, and Gale (2) follows from our condition (2) with F = Y X . To prove Gale (3), let F âŠ† Y X be closed and V âŠ† Y be open. Then the set U = {x âˆˆ X | Î¦(Ï‡F , x)(Ï‡V ) = Â¯ is open because Î¦ is continuous, and xâˆˆU â‡â‡’ â‡â‡’ â‡â‡’ âˆ€(K âˆ©F )(x) (v ) = â‡â‡’ Ï‡V (y ) = for all y âˆˆ (K âˆ© F )(x) }

X

Ï‡V (f (x)) = for all f âˆˆ K âˆ© F â‡â‡’ f (x) âˆˆ V for all f âˆˆ K âˆ© F x âˆˆ f âˆˆK âˆ©F f âˆ’1 (V ),
f âˆˆK âˆ©F

which shows that the set

f âˆ’1 (V ) is the same as U and hence is open.

We now formulate and prove an analogue of Theorem 3.5.3, which replaces (i) the Sierpinski space S by the boolean domain B , (ii) Hausdorff k -spaces by Scott domains, (iii) compact subsets by topologically exhaustible entire subsets, (iv) closed subsets by topologically decidable sets (cf. Deï¬nitions 2.2.2 and 3.3.3). We again apply Galeâ€™s theorem, exploiting Hylandâ€™s characterization of Kleeneâ€“Kreisel spaces as k -spaces. The proof follows the same pattern as that of Theorem 3.5.1, but there are a number of additional steps. Firstly, using Galeâ€™s theorem, we get continuous maps deï¬ned on Kleeneâ€“Kreisel spaces. These are extended to continuous maps on domains using the Kleeneâ€“Kreisel density theorem and Scottâ€™s injectivity theorem, as in Lemma 3.2.4. (In Theorem 3.6.1, such an extension will be instead deï¬ned by an algorithm, but still relying on the density theorem.) Secondly, the set F in condition (2) is closed in Theorem 3.5.1 but is neither open nor closed in Theorem 3.5.3, although it has clopen shadow, because the Sierpinski space has been replaced by the boolean domain. To overcome this difï¬culty, we rely on the following version of Galeâ€™s theorem: 21

Remark 3.5.2. An inspection of the proof of Galeâ€™s theorem shows that it also holds if, in condition (3), the set F ranges over subbasic closed sets in the compact-open topology: 3 . the set f âˆˆK âˆ©N (Q,B ) f âˆ’1 (V ) is open for every compact set Q âŠ† X , every closed set B âŠ† Y , and every open set V âŠ† Y . In one direction this is clear: if condition (3) holds for all closed F , then it holds for F = N (Q, B ). For the other direction, notice that condition (3) is used only in the â€œLemmaâ€ [10, page 305] for F of this form (the sets Wx in the second last line of that page, and the set T of page 306). Let D = DÏƒ and C = CÏƒ for an arbitrary type Ïƒ , and recall the concepts and notation introduced in Deï¬nitions 2.2.7 and 3.3.3. Theorem 3.5.3. An entire set K âŠ† (D â†’ N ) is topologically exhaustible if and only if the following two conditions hold: 1. K is topologically co-semi-decidable. 2. The set (K âˆ© F )(x) is topologically exhaustible for any F that is topologically decidable on K , and any x âˆˆ D total, continuously in F and x. Here the dependence of (K âˆ© F )(x) in F and x is to be given by a functional Î“ : ((D â†’ N ) â†’ B) Ã— D â†’ ((N â†’ B ) â†’ B) such that Î“(ÏˆF , x) = âˆ€(K âˆ©F )(x) . Proof. (â‡’): (1): By Lemma 3.3.4, the shadow K = Ï(K ) âŠ† NC of K is compact and hence closed. Hence the map NC â†’ B that sends f âˆˆ K to âŠ¥ and f âˆˆ K to tt is continuous. By composition with the quotient map Ï : T â†’ NC , where T = TÏƒâ†’Î¹ , we get a map T â†’ B . Because T is dense in (D â†’ N ) and B is densely injective, the domain DÏƒâ†’Î¹ under the Scott topology is injective over dense embeddings, which means that this map extends to a continuous map (D â†’ N ) â†’ B . By construction, this exhibits K as a topologically co-semi-decidable subset of (D â†’ N ). (2): Deï¬ne Î“(ÏˆF , x) = Î»p.âˆ€f âˆˆ K.ÏˆF (f ) =â‡’ p(f (x)). The result then follows from the fact that the category of Scott domains under the Scott topology is cartesian closed, and hence functions that are Î»-deï¬nable from continuous maps are themselves continuous. (â‡): We apply Galeâ€™s theorem to show that the shadow K = Ï(K ) is compact. Then it is topologically exhaustible by Lemma 3.3.4. Gale (1): If K is topologically co-semi-decidable, then, by deï¬nition, we have a continuous function (D â†’ N ) â†’ B that maps f âˆˆ K to âŠ¥ and f âˆˆ K to tt. Hence K is closed in T because it is the inverse image of the closed set {âŠ¥} restricted to T . Because K is entire, it is closed under total equivalence by deï¬nition, and hence, because Ï : T â†’ NC is a quotient map, K is closed. Gale (2): The assumption gives that for any x âˆˆ D total, K (x) is exhaustible, considering F = (D â†’ N ). Because K is entire and x is total, K (x) âŠ† N. Hence by Lemma 3.3.4, K (x) is compact in N âŠ† N . Gale (3): Let F âŠ† NC be a subbasic open set of the form N (Q, V ) with Q âŠ† C compact and V âŠ† N (necessarily) clopen. Then the set Q = Ïâˆ’1 (Q) is entire and Kleeneâ€“ Kreisel compact, and hence, by Lemma 3.3.4, it is topologically exhaustible. Also, V is a topologically decidable subset of N . So the predicate p : (D â†’ N ) â†’ B deï¬ned by p(f ) = âˆ€x âˆˆ Q.Ï‡V (f (x)) is continuous and deï¬ned on K , and p = ÏˆF for F = T âˆ© pâˆ’1 (tt). Now deï¬ne u : D â†’ B by u(x) = Î“(ÏˆF , x)(Ï‡V ). Then u is continuous and u(x) = âˆ€(K âˆ©F )(x) (Ï‡V ) = âˆ€f âˆˆ K âˆ© F.Ï‡V (f (x)). Hence the set U = uâˆ’1 (tt) = {x âˆˆ T | âˆ€f âˆˆ K âˆ© F.Ï‡V (f (x)) = tt} is open. Therefore its shadow f âˆˆK âˆ© F f âˆ’1 (V ) is open, because it is closed under total equivalence and because Ï is a quotient map. 22

3.6 Arzelaâ€“Ascoli type characterization of exhaustible sets
At this stage of our investigation, such a characterization is available only for certain types, which include pure types, and for entire sets (for the reasons explained in Section 3.5). Let D = DÏƒ and C = CÏƒ for an arbitrary type Ïƒ . We establish the computational version of Theorem 3.5.3. Theorem 3.6.1. An entire set K âŠ† (D â†’ N ) is exhaustible if and only if the following two conditions hold: 1. K is co-semi-decidable. 2. The set (K âˆ© F )(x) is exhaustible for any F decidable on K , and any x âˆˆ D total, uniformly in F and x. Moreover, the equivalence is uniform. A few remarks are in order before embarking into the proof. The claim holds, with the same proof, if conditions (1) and (2) are replaced by any of the following conditions, respectively: 1 . K is topologically co-semi-decidable. 1 . K has closed shadow. 1 . The shadow of K is closed in the topology of pointwise convergence. 1 . K has compact shadow.
Î± 2 . The set (K âˆ© Fn )(x) is exhaustible, uniformly in n âˆˆ N , Î± âˆˆ N Ï‰ and x âˆˆ D total.

Recall (Section 3.4, proof of Theorem 3.4.2) that we deï¬ned
Î± Fn = {f âˆˆ (D â†’ N ) | âˆ€i < n.f (di ) = Î±i }.

In the formulation of the theorem, the fact that conditions (1) and (2) uniformly imply the exhaustibility of K is in principle given by a computable functional of type
Ï‡K c ÏˆF x âˆ€K âˆ©F (x) âˆ€K

z }| { z }| { z}|{ z }| { z }| { ((D â†’ N ) â†’ B) Ã— (((D â†’ N ) â†’ B) Ã— D â†’ ((N â†’ B) â†’ B)) â†’ (((D â†’ N ) â†’ B) â†’ B) . | {z }| {z } | {z }
condition 1 condition 2 conclusion

However, the computational information given by condition (1) is not used in the construction of the conclusion (although the topological information is used in its correctness proof). Moreover, the information given by condition (2) is not fully used in the construction. Replacing it by (2 ) we get
Î± n x
Î± âˆ€K âˆ©Fn (x)

(N

Ï‰

Ã— N Ã— D ) â†’ ((N â†’ B ) â†’ B )) â†’ (((D â†’ N ) â†’ B ) â†’ B) .
condition 2 conclusion

Additionally the pair Î±, n is really coding a ï¬nite sequence, and, as we have seen, exhaustible sets of natural numbers are uniformly equivalent to ï¬nite enumerations of natural numbers. Hence the above can be written as
Î±,n âˆ— x
Î± âˆ€K âˆ©Fn (x)

(( N Ã— D ) â†’
condition 2

Nâˆ—

) â†’ (((D â†’ N ) â†’ B) â†’ B) .
conclusion

23

Therefore the above characterization reduces the type level of âˆ€K by two. The last step of the proof of this theorem mimics topological proofs of Arzelaâ€“Ascoli type theorems (which we havenâ€™t included): to show that K âŠ† Y X is compact under assumptions such as those of Galeâ€™s theorem (Section 3.5), one ï¬rst concludes that xâˆˆX K (x) is compact by the Tychonoff theorem, then shows that the relative topology of K is the topology of pointwise convergence, and that it is pointwise closed, and hence concludes that it is homeomorphically embedded into the product as a closed subset, and therefore that it must be compact. In the proof below, we have replaced the Tychonoff theorem by its countable computational version given by Theorem 2.3.5, using a dense sequence of the exponent. The previous steps of the proof are needed in order to make this replacement possible, and they are modiï¬cations of the constructions developed in Section 3.4, Proof. (â‡’) (1): Theorem 3.4.2. (2): Deï¬ne âˆ€K âˆ©F (p) = âˆ€f âˆˆ K.ÏˆF (f ) =â‡’ p(f (x)). (â‡): By Theorem 3.5.3, the set K is topologically exhaustible, and hence is Kleeneâ€“ Kreisel compact by Lemma 3.3.4. We apply this to establish the correctness of the algorithms deï¬ned below. Deï¬ne P : (D â†’ N ) â†’ N Ï‰ by P (f )(i) = f (di ), as in the proof of Theorem 3.4.2, Î± where d âˆˆ DÏ‰ is a computable dense sequence, and let L = P (K ). Because Fn is Î± Î± Î± decidable on K , the set Kn = K âˆ© Fn is exhaustible by Proposition 2.3.1, and Kn (x) is exhaustible uniformly in Î±, n and x âˆˆ K by Proposition 2.3.2 applied to evaluation at x. Now modify the deï¬nition of r : N Ï‰ â†’ N Ï‰ given in Theorem 3.4.2 as follows: r(Î±)(n) = Î±n r (Î±) Âµy.âˆƒy âˆˆ Kn (dn ).y = y if âˆƒy âˆˆ Kn otherwise.
r (Î±)

(dn ).Î±n = y ,

Then r is computable, and satisï¬es r(Î±)(n) = Î±n if âˆƒf âˆˆ K.f (dn ) = Î±n âˆ§ âˆ€i < n.f (di ) = r(Î±)(i), Âµy.âˆƒf âˆˆ K.f (dn ) = y âˆ§ âˆ€i < n.f (di ) = r(Î±)(i) otherwise.

Hence it also satisï¬es r(Î±)(n) = Î±n if âˆƒÎ² âˆˆ L.Î²n = Î±n âˆ§ Î²i =n r(Î±), Âµy.âˆƒÎ² âˆˆ L.Î²n = y âˆ§ Î² =n r(Î±) otherwise.

This shows that r = rL for rL as deï¬ned in Theorem 3.4.2. But notice that, although the second and third equations hold, the algorithm is not the same as in Theorem 3.4.2. In fact, the second and third equations donâ€™t establish computability of r, because exhaustibility of K and L are not known at this stage of the proof. In any case, the last equation shows that r exhibits L as a total retract, using the fact that L, being the continuous P -image of K , is topologically exhaustible and hence is Kleeneâ€“Kreisel compact, as in Theorem 3.4.2 Similarly, modify the deï¬nition of E : N Ï‰ â†’ (D â†’ N ) in Theorem 3.4.2 as follows
r E (Î±)(x) = Âµy.âˆƒy âˆˆ Kn(Î±) (x).y = y ,

where n is the least number such that âˆ€y, y âˆˆ Kn (x).y = y . Because this condition r (Î±) is equivalent to âˆ€f, f âˆˆ Kn .f (x) = f (x), such a number exists by Lemma 3.4.3 and r (Î±) the compactness of the shadow of K . By uniform exhaustibility of the set Kn (x), this can be found uniformly in Î± and x, and hence E is computable. Moreover, although the deï¬nition of E is not the same, as before, we again have E = EL for EL deï¬ned as in Theorem 3.4.2.

r (Î±)

24

Finally, because K = K âˆ© F for F = (D â†’ N ), the set K (x) is exhaustible uniformly in x âˆˆ D total, and hence the set M = i K (di ) âŠ† N Ï‰ is searchable uniformly in x â†’ âˆ€K (x) . In fact, each K (di ) is searchable uniformly in i, by Theorem 3.4.2, and hence M is searchable by Theorem 2.3.5. Now L âŠ† M and hence the entire r-image of M is L, and hence L is searchable by Proposition 2.3.2. In turn K is the entire E -image of L and hence is also searchable. Therefore it is exhaustible.

4

Time-complexity considerations

We now discuss the experimental and theoretical run-time behaviour of algorithms for exhaustive search. The main contributions of this section are: (1) The development of an algorithm for exhaustive search that is experimentally fast in surprising instances, and that seems to be asymptotically faster than all known search algorithms, and possibly all search algorithms. (2) The introduction of a semantical notion of size for predicates so that the run-time of search algorithms can be expressed as a function of the size of the input predicate. (3) Conjectures about the run time of several algorithms. (4) Experimental evidence. While the considerations of the previous sections are conclusive and rigorously developed, those of this one are necessarily tentative: we lack mathematical techniques for reasoning about higher-type computational resources, in particular time. Whether or not our conjectures hold, the algorithm developed in this section is faster, in practice, than untrained intuition would concede to be possible.

4.1 The model of computation
We consider call-by-need evaluation [15, 18, 30]. For the language PCF, this is semantically equivalent to the call-by-name computational model. The essential operational difference of the call-by-name and the call-by-need computational models is that the latter avoids re-evaluations that take place in the former when the same variable is occurs twice in a program, which speeds up computations. Another crucial difference of call-by-need evaluation regarding speed is that substitutions are computed in constant time by pointer manipulation. One of the algorithms discussed here turns out to work directly in the call-by-value model, but (1) it is experimentally exponentially slower in this model, (2) we donâ€™t understand its run-time behaviour in this model at present, not even intuitively, and (3) the other algorithms diverge in this model (although, of course, they can be adapted to this model by the application of standard translation techniques of call-by-name into call-by-value [24]). These three issues regarding call-by-value computation should certainly be investigated in future research.

4.2 The experimental setup
The main emphasis of Section 4 is asymptotic rather than actual run-time behaviour. But it is also interesting to experimentally determine whether non-trivial instances of search over inï¬nite sets can be computed fast in practical standards (say in a few seconds). Moreover, experiments can disprove our asymptotic conjectures or conï¬rm them to some extent. For such experimental purposes, we need to consider a particular programming language, under a particular implementation, running in a particular architecture/ machine/ operating system. This is what we describe here. The programming language. We use the language Haskell [13], which includes PCF as a subset, and whose computation mechanism, known as lazy evaluation, coincides with call-by-need apart from a few minor and inessential differences [18]. The Haskell code for the experiments is included in Section 4.8 below. 25

The language implementation. We use the Glasgow Haskell interpreter ghci. For experiments regarding asymptotic behaviour, the use of an interpreter makes no difference. For practical considerations of speed, the compiler ghc of course gives a linear speedup, perhaps by an order of magnitude. The machine, architecture and operating system. The technological details given here are included for the sake of reproducibility of our experiments. What is important is that there is a machine that, at the time of writing, is capable of running the experiments with the reported speeds. We have used a Dell D410 Latitude laptop computer (manufactured in 2005), with 1Gb of memory running at 1.73 GHz (Intel Pentium M processor) under the operating system Gnu/Linux Debian/Ubuntu 7.10.

4.3 A ï¬rst experiment
Consider the three total functions u, v, w : B Ï‰ â†’ B deï¬ned (in mathematical vernacular or PCF) by u(Î±) v (Î±) w(Î±) = Î±(19Î±(220 ) + 399Î±(520 ) + 9177Î±(320 )), = Î±(19Î±(220 ) + 399Î±(620 ) + 9177Î±(320 )), = Î±k ,

where, for the deï¬nition of w, we take i= j k if Î±(320 ) then 483 else 0 = 19( if Î±(220 ) then 1 + i else i) = j + 19( if Î±(520 ) then 21 else 0).

In the above deï¬nitions, for the purposes of multiplication and addition, we identify the booleans ï¬€ , tt with the numbers 0, 1. Then clearly u = v , and it is not hard to see that u = w, although this was deliberately designed not to be immediate. Given an algorithm âˆ€ : (B Ï‰ â†’ B ) â†’ B for exhaustive search, one can deï¬ne a totalequality functional (==) by (f == g ) = âˆ€total Î± âˆˆ B Ï‰ .f (Î±) == g (Î±). For all total f, g , we have that f âˆ¼ g if and only if (f == g ) = tt. Experiment 4.3.1. How long does it take, in practice, to determine that u = v and u = w using exhaustive search over the Cantor space? Of course, this depends on the exhaustivesearch algorithm âˆ€ that one uses. Using any of the algorithms discussed above, the experiment runs out of memory before one gets the answer (and we predict that with unbounded memory one would have to wait for longer than the universe has existed to get an answer). But using an algorithm for exhaustive search deï¬ned in Section 4.7 below, the expressions u == v and u == w evaluate to ï¬€ and tt in respectively 0.03 secs and 0.15 secs. How can this be so fast, given that the algorithm uses the functions u, v and w as black boxes, without any knowledge of their syntactical representations? It is easy to see that the moduli of uniform continuity of u, v and w are 520 +1, 620 +1 and 520 +1 respectively (see Corollary 2.3.7). Hence the moduli of continuity of the predicates Î»Î±.u(Î±) = v (Î±) and Î»Î±.u(Î±) = w(Î±) are 620 + 1 and 520 + 1 respectively. Thus, in principle, if the moduli of 20 20 continuity are known, it is enough to check 26 +1 and 25 +1 cases respectively in order to determine that u and v are not equal, and that u and w are equal, respectively. Obviously, it is not possible to check that many cases in the reported time. 26

4.4 Run-time as a function of the size of a functional input
We wish to mathematically predict the run time of âˆ€(p) where âˆ€ : (B Ï‰ â†’ B ) â†’ B is an exhaustive search algorithm and p : B Ï‰ â†’ B is total. Moreover, we wish to have a mathematical guideline to get better algorithms if the current algorithms are not optimal. In fact, all algorithms considered so far in this paper, and that we know from the literature, are far from optimal, and we will propose an algorithm in Section 4.7, already alluded to in Section 4.3, which may be asymptotically optimal and in any case is experimentally faster than all the known algorithms. In order to predict the run time of âˆ€(p), it is natural to attempt to deï¬ne a notion of size for p, and express the run time of âˆ€(p) a function of the size of p. At ï¬rst sight, it may seem that the size of p can be measured syntactically only, or at least only from semantic models with enough intensional information, such as games models without extensional collapse. For example, we can have two equivalent predicates p and p such that p(Î±) â€œusesâ€ Î±17 once, but p (Î±) uses Î±17 twice. While the run time of âˆ€(p) and âˆ€(p ) will be different, we argue that use-repetition doesnâ€™t affect the asymptotic run-time behaviour of the algorithms considered here, and perhaps all possible algorithms. Moreover, we argue that it is possible to deï¬ne a natural notion of size based on Scott semantics that allows to formulate predictions of the run-times. We also argue that, although p is assumed to be total in our considerations, a sensible notion of size cannot be deï¬ned in terms of Kleeneâ€“Kreisel semantics. The size of a total predicate deï¬ned on the Cantor space. We propose a modiï¬cation of the notion of modulus of uniform continuity as a notion of size for total predicates on the Cantor space. Two notions of modulus of uniform continuity on the Cantor set arise often. The ï¬rst one, as in Corollary 2.3.6, says that there is a smallest number n = fan(p) such that for all total Î±, Î² âˆˆ BÏ‰ , if Î± =n Î² then p(Î±) = p(Î² ). The second one says that there is a smallest number m = m(p) such that p(Î±) = p(Î±|m ) for all total Î± âˆˆ B Ï‰ . Then fan(p) â‰¤ m(p) holds. Example 4.4.1. Deï¬ne p, p : B Ï‰ â†’ B by p(Î±) = Î±17 , Then p âˆ¼ p but p = p , and fan(p) = m(p) = fan(p ) = 18 but m(p ) = 101. Moreover, notice that and p p, because for any total Î±, one has p(Î±|17 ) = tt but p (Î±|17 ) = âŠ¥. One can say that p may look at position 100 of its argument Î± (this happens if Î±17 = tt), but p doesnâ€™t look at it. Notice that the fan-modulus is zero iff the predicate is constant on total elements, but that again the m-modulus of such a predicate can be bigger. We consider reï¬ned versions of these two notions. Deï¬nition 4.4.2. Given a set I âŠ† Ï‰ , deï¬ne, for Î±, Î² âˆˆ B Ï‰ , Î± =I Î² iff Î±i = Î²i for all i âˆˆ I , and Î±|I (i) = Î±i âŠ¥ if i âˆˆ I , otherwise. p (Î±) = Î±17 âˆ§ (Î±100 âˆ¨ Â¬Î±100 ).

Then there is a smallest set I = FAN(p) such that Î± =I Î² implies p(Î±) = p(Î² ) for all total Î±, Î² âˆˆ B Ï‰ , and there is a smallest set I = M (p) such that p(Î±) = p(Î±|I ) for all total Î± âˆˆ B Ï‰ . These sets exist and are ï¬nite by uniform continuity, and moreover FAN(p) âŠ† M (p) âŠ† {i | i < m(p)}. 27

Example 4.4.3. For p and p as deï¬ned in Example 4.4.1, FAN(p) = M (p) = FAN(p ) = {17}, M(p) = {17, 100}.

Similarly, FAN(Î»Î±. tt) = M (Î»Î±. tt) = âˆ…. For the predicates u, v, w deï¬ned in Section 4.3, we have that their FAN- and M -moduli agree and M (u) = M (w) M (v ) = {220 , 520 , 320 } âˆª { = {220 , 620 , 320 } âˆª { S | S âŠ† {19, 399, 9177}}, S | S âŠ† {19, 399, 9177}}.

The M -moduli of the predicates Î»Î±.u(Î±) = v (Î±) and Î»Î±.u(Î±) = w(Î±) are respectively M (u) âˆª {620 } and M (u), which have cardinalities 12 and 11. The set FAN(p) is uniformly decidable in any total p, with decision procedure i âˆˆ FAN(p) â‡â‡’ âˆƒÎ±, Î².Î±i = Î²i âˆ§ p(Î±) = p(Î² ). But the set M (p) is not, because its characteristic function depends non-monotonically on p (consider Example 4.4.1). But it is the set M (p) that arises in the time-complexity considerations of this section. One notion of size for p that weâ€™ll consider is the cardinality |M (p)| of the set M (p). The other is the number m(p).

4.5 The constant-cost hypothesis
We refer to the following, for either PCF or a subset of Haskell corresponding to PCF, as the constant-cost conjecture: Conjecture 4.5.1. For any total program p : B Ï‰ â†’ B there is a number n such that, for any program or oracle Î±, the evaluation of p(Î±) takes n steps or fewer. Here we are deliberately confusing syntax with semantics, but we hope the reader will both excuse us and be able to resolve or ignore the confusion. The idea is that, operationally speaking, the computation of p(Î±) ought not to be able to look at Î±i for i outside M (p), and hence there is a bound for how much of Î± the predicate p can look at, which is determined by p independently of Î±, even if Î±i is evaluated for the same i âˆˆ M (p) more than once. Although we are ofï¬cially working with the call-by-need model, our intuitive argument applies to the call-by-name model too, for which it should be easier to establish the conjecture, perhaps relying on computational adequacy of the Scott model or a related technique. Then the result would follow from the belief that call-by-need is bounded by call-by-name in number of evaluation steps, which should be true but, at the time of writing, we donâ€™t know whether has been rigorously formulated or proved. Hypothesis 4.5.2. We assume that such a number n exists, and we denote the smallest such number by E (p).

4.6

Bergerâ€™s algorithm run time

Recall Bergerâ€™s algorithm ÎµBerger deï¬ned in Remark 2.3.8, and consider the following simple modiï¬cation, which avoids re-evaluation of l in the call-by-need model of computation: ÎµBerger (p) = where l r = = tt #ÎµBerger (Î»Î±.p.p(tt #Î±)) ï¬€ #ÎµBerger (Î»Î±.p(ï¬€ #Î±)). 28 l r if p(l), otherwise,

Denote by âˆƒBerger and âˆƒBerger the exhaustors derived from ÎµBerger and ÎµBerger respectively as in Lemma 2.2.4 and by âˆ€Berger and âˆ€Berger the universal quantiï¬ers derived from De Morganâ€™s law. Experiment 4.6.1. âˆ€Berger (Î»Î±.Î±n ) runs in time exponential in n, but âˆ€Berger (Î»Î±.Î±n ) runs in time linear in n. However, âˆƒBerger (Î»Î±.Î±n == Î±n ) and âˆƒBerger (Î»Î±.Î±n == Î±n ) run in time exponential in n and roughly equal. For example, for n = 12, 13, 14, 15, 16 k the times are 0.22, 0.45, 0.93, 1.97, 4.19 secs. Both âˆ€Berger (Î»Î±. j =1 Î±n == Î±n ) and âˆ€Berger (Î»Î±. j =1 Î±n == Î±n ) run in time linear in k and exponential in n. For n = 12 and k = 1, 2, 3, 4, 5 one gets 0.23, 0.39, 0.55, 0.72, 0.86 seconds. Thus, apart from costs in evaluating the predicate, k doesnâ€™t affect the run time. Similar examples lead to: Conjecture 4.6.2. Exhaustive search âˆ€(p) with both Bergerâ€™s algorithm and the above variation run in time O 2m(p) Â· E (p) . Recall that E (p) is deï¬ned in Section 4.5 and m(p) in Section 4.4. The intuition behind the conjecture is that Bergerâ€™s algorithm and its variation explicitly construct a witness from left to right, and all witnesses of length smaller than the modulus of continuity are constructed in the worst case. In order to prove this conjecture and others, one could attempt to establish a connection between the denotational notion of modulus of continuity and the operational notion of call-by-need evaluation, similar to the notion of computational adequacy, or perhaps even generalizing the notion of computational adequacy. Notice that all our conjectures are for ground terms with a higher-type parameter.
k

4.7 Product-algorithms run time
We consider the product algorithm (Deï¬nition 2.3.4) and two variations that are intended to asymptotically improve its run time, the ï¬rst of which showed up in the proof of Theorem 2.3.5. The algorithm Î . As in Remark 2.3.8, use the product algorithm Î  to deï¬ne exhaustive search over the Cantor space. Experiment 4.7.1. We consider the computation of âˆ€(Î»Î±. i<|s| Î±si = Î±si ) where s is a ï¬nite sequence of length |s|. For s = 1, 2, 3 and s = 1, 2, 3, 4 one gets times 0.02 and 56.93 secs. respectively. For s = 1, 2, 3, 1k and k = 1, 2, 3, 4, 5, 6 one gets times 0.05, 0.08, 0.12, 0.16, 0.21, 0.26, 0.32 respectively, which seem roughly linear in k . Although the product functional also constructs the witness from left to right, it doesnâ€™t force the evaluation of all its entries, hence the appearance of |M (p)| rather than m(p) in the following, where M (p) is deï¬ned in Section 4.4. However, each time a partial witness is invoked, it is completely re-evaluated, which causes the doubly exponential behaviour. The linearity in the above experiment is accounted for by the factor E (p). Conjecture 4.7.2. Exhaustive search âˆ€(p) using the product algorithm O 22
|M (p)|

runs in time

Â· E (p)

Although this is exponentially worse than Bergerâ€™s algorithm and its obvious variation, there is a qualitative improvement: the run time depends on the cardinality of M (p) rather than the upper bound m(p) for the members of the set M (p). Our next algorithm, based on Î , tries to keep the smaller exponent but reduce the exponential behaviour from double to simple.

29

The algorithm Î  . able sets,

We now deï¬ne an alternative countable-product algorithms for searchÎ  : ((D â†’ B) â†’ D)Ï‰ â†’ ((DÏ‰ â†’ B) â†’ DÏ‰ ),

which is expected to reduce the doubly exponential time to exponential time. First deï¬ne tl : DÏ‰ â†’ DÏ‰ and (#) : D Ã— DÏ‰ â†’ DÏ‰ by tl(Î±) = Î»i.Î±i+1 , (x#Î±)(i) = x Î±iâˆ’1 if i = 0, otherwise.

Then Î±0 # tl(Î±) âˆ¼ Î± and tl(x#Î±) âˆ¼ Î± for total x âˆˆ D and Î± âˆˆ DÏ‰ . Moreover, the total equivalences are equalities except when Î± is non-strict. Using this notation, recursively deï¬ne Î  (Îµ)(p) = x0 #Î  (tl(Îµ))(Î»Î±.p(x0 #Î±)) where x0 = Îµ0 (Î»x.p(x#Î  (tl(Îµ))(Î»Î±.p(x#Î±)))). By course-of-values induction on n, one can show that Î  (Îµ)(p)(n) = Î (Îµ)(p)(n) for for every n âˆˆ N and every p âˆˆ (D â†’ B), and hence Î  = Î . Experiment 4.7.3. We consider the computation of âˆ€(Î»Î±. i<|s| Î±sci = Î±sci ) where s is a ï¬nite sequence of length |s| and c is a positive integer. When the length of s increases by 1, the time doubles, and the time is proportional to c. For example, for s = 1, 2, . . . , 11 and c âˆˆ {1, 10, 20, 30, 40, 50} the times are 0.14, 0.96, 1.86, 3.69, 4.64, 5.58 secs. The algorithm Î  is signiï¬cantly more efï¬cient than Î  and than Bergerâ€™s algorithm and its variation. The reason for this efï¬ciency comes from the fact that the variable x0 is used twice. We donâ€™t know whether its ï¬rst or second occurrence will be computed ï¬rst (if any at all is computed), but when it is used twice it is computed only once. This reduces the double exponential behaviour to an exponential one. However, it still has a linear-time overhead, due to the fact that the witness is produced from left to write, as in Bergerâ€™s algorithm, but this time on demand, as with the algorithm Î . The factor M (p) accounts for the fact that the witness is scanned for left to right each time the one of its entries is queried. Conjecture 4.7.4. Exhaustive search âˆ€(p) using the product algorithm O 2|M (p)| Â· E (p) Â· M (p) runs in time

The algorithm Î  . The next algorithm tries to reduce the linear time overhead of the above conjecture to logarithmic time. It is only with this algorithm that the experiment of Section 4.3 can be run in feasible time. In the conference version of this paper, we used trees assuming a language with explicit support from them, and we asked whether they could be avoided. They can, as we show now, in the obvious way: just encode inï¬nite, binarily branching sequences as inï¬nite sequences, in the known way. In fact, the algorithm based on this idea turns out to be much faster, experimentally. The product algorithm Î  : ((D â†’ B) â†’ D)Ï‰ â†’ ((DÏ‰ â†’ B) â†’ DÏ‰ ) attempts to logarithmically reduce the factor M (p) in the above conjecture. We regard a sequence t as an inï¬nite binarily branching tree with the elements of the sequence organized in a breadth-ï¬rst manner: the root is t(0), its left and right branches are t(1) and t(2), those of t(1) are t(3) and t(4), those of t(2) are t(5) and t(6), and in general those of t(n) are t(2n + 1) and t(2n + 2). With this in mind, deï¬ne functions 30

root : DÏ‰ â†’ D, left, right : DÏ‰ â†’ DÏ‰ , branch : D Ã— DÏ‰ Ã— DÏ‰ â†’ DÏ‰ by root(t) = t(0), left(t) = Î»i.t(2i + 1), ï£± ï£´x ï£² branch(x, l, r) = Î»i. l(iâˆ’1)/2 ï£´ ï£³ r(iâˆ’2)/2 right(t) = Î»i.t(2i + 2), if i = 0, if i is odd, otherwise.

Then, for total x âˆˆ D and l, r âˆˆ DÏ‰ , root(branch(x, l, r)) = x, and, for all total t âˆˆ DÏ‰ , branch(root(t), left(t), right(t)) âˆ¼ t. Moreover, the total equivalences are equalities except when l, r or t are non-strict. Using this notation, recursively deï¬ne Î  (Îµ)(p) = branch(x0 , l0 , r0 ) where Îµroot Îµleft Îµright âˆƒleft (p) âˆƒright (p) x0 l0 r0 = root(Îµ), = Î  (left(Îµ)), = Î  (right(Îµ)), = p(Îµleft (p)), = p(Îµright (p)), = Îµroot (Î»x.âˆƒleft (Î»l.âˆƒright (Î»r.p(branch(x, l, r))))), = Îµleft (Î»l.âˆƒright (Î»r.p(branch(x0 , l, r)))), = Îµright (Î»r.p(branch(x0 , l0 , r))). left(branch(x, l, r)) âˆ¼ l, right(branch(x, l, r)) âˆ¼ r,

Any set of natural numbers that has 0 as a member and is closed under Î»n.2n + 1 and Î»n.2n + 2 contains all natural numbers. Thus, to prove that a property holds for all natural numbers one can show that it holds for 0, and that whenever it holds for n it also holds for 2n + 1 and 2n + 2. It is easy to see, using this induction principle, that Î  (Îµ)(p)(n) = Î  (Îµ)(p)(n) and hence Î  = Î  = Î . The experiment reported in Sec. tion 4.3 was performed using the product algorithm Experiment 4.7.5. We consider the computation of âˆ€(Î»Î±. i<|s| Î±sci = Î±sci ) where s is a ï¬nite sequence of length |s| and c is a positive integer. When the length of s increases by 1, the time doubles, and the time is proportional to log c. For example, for s = 1, 2, . . . , 11 and c âˆˆ {60, 70, 80, 100, 1000, 2000, 4000, 8000, 16000} the times are 0.36, 0.38, 0.38, 0.38, 0.51, 0.55, 0.58, 0.62, 0.65 secs. Experiments similar to 4.6.1 show that the number of uses of the argument of the predicate has a linear effect, taken into account by the factor E (p) in the conjecture below. Again the idea here is that a shared variable, in this case x0 , which occurs in the definition of l0 and r0 , reduces run time of logarithmically, in the same way as did. But rather than scanning the whole witness from left to right, like , this algorithm scans a small number of small paths of the tree, which gives a further logarithmic reduction in time. Conjecture 4.7.6. Exhaustive search âˆ€(p) using the product algorithm O 2|M (p)| Â· E (p) Â·
kâˆˆM (p) log(k + 1) .

runs in time

31

We have performed many more experiments that back the above conjectures, but the above are sufï¬ciently illustrative examples. give rise to the asymptotically fastest search algorithm? We are tempted to Does conjecture that this is the case.

4.8 Haskell code for the experiments
We conclude this section with the Haskell code used in the above experiments. An expression of the form Î»x. . . . in PCF is written as \x -> ... in Haskell. Apart from this, the notation is the same as in PCF. Some encodings and abbreviations:
type type type type N = Integer Cantor = N -> Bool Searcher d = (d -> Bool) -> d Quantifier d = (d -> Bool) -> Bool

Bergerâ€™s functional and a variation:
(x # a)(i) = if i == 0 then x else a(i-1) tl a = \i -> a(i+1) berger, bergerâ€™ :: Searcher Cantor berger p = if p(True # berger(\a -> p(True # a))) then True # berger(\a -> p(True # a)) else False # berger(\a -> p(False # a)) bergerâ€™ p = if p l then l else r where l = True # bergerâ€™(\a -> p(True # a)) r = False # bergerâ€™(\a -> p(False # a))

The three product functionals:
prod, prodâ€™, prodâ€™â€™ :: (N -> Searcher d) -> Searcher(N -> d) prod e p n = e n (\x->q n x(prod(\i->e(i+n+1))(q n x))) where q n x a = p(\i -> if i < n then prod e p i else if i == n then x else a(i-n-1)) prodâ€™ e p = x#(prodâ€™(tl e)(\a->p(x#a))) where x = e 0(\x->p(x#(prodâ€™(tl e)(\a->p(x#a))))) branch x l r n = if n == 0 then x else if odd n then l ((n-1) â€˜divâ€˜ 2) else r ((n-2) â€˜divâ€˜ 2) root t = t 0 left t = \n -> t(2 * n + 1) right t = \n -> t(2 * n + 2) prodâ€™â€™ t p = branch x l r where findx = root t findl = prodâ€™â€™(left t) findr = prodâ€™â€™(right t) forsomel p = p(findl p) forsomer p = p(findr p) x = findx(\x -> forsomel(\l -> forsomer(\r -> p(branch x l r)))) l = findl(\l -> forsomer(\r -> p(branch x l r))) r = findr(\r -> p(branch x l r))

A search operator for booleans:
findbool :: Searcher Bool findbool p = p True

32

We have ï¬ve versions of search operators for the Cantor space and of each quantiï¬er. The version of the chosen algorithm is ranged over by v .
type Version = Int find find find find find find :: Version -> 0 = berger 1 = bergerâ€™ 2 = prod (\i 3 = prodâ€™ (\i 4 = prodâ€™â€™(\i Searcher Cantor

-> findbool) -> findbool) -> findbool)

forsome, forevery :: Version -> Quantifier Cantor forsome n p = p(find n p) forevery v p = not(forsome v (not.p))

Function equality again comes in ï¬ve versions:
equal :: Eq y => Version -> (Cantor -> y) -> (Cantor -> y) -> Bool equal v f g = forevery v(\x -> f x == g x)

The ï¬rst experiment:
coerce :: Bool -> N coerce x = if x then 1 else 0 u,v,w :: Cantor -> Bool u a = a(19*aâ€™(2Ë†20)+399*aâ€™(5Ë†20)+9177*aâ€™(3Ë†20)) where aâ€™ i = coerce(a i) v a = a(19*aâ€™(2Ë†20)+399*aâ€™(6Ë†20)+9177*aâ€™(3Ë†20)) where aâ€™ i = coerce(a i) wa=ak where i = if a(3Ë†20) then 483 else 0 j = 19 * if a(2Ë†20) then 1+i else i k = j + 19 * if a(5Ë†20) then 21 else 0

The other experiments are coded similarly.

5

Concluding remarks

The role of topology in computability theory. The algorithms developed in this work have purely computational speciï¬cations, which allow them to be applied without knowledge of specialized mathematical techniques in the theory of computation. However, the correctness proofs of some of the algorithms crucially rely on topological techniques. In this sense, this work is a genuine application of topology to computation: theorems formulated in the language of computation, proofs developed in the language of topology. But there is another sense in which topology proves to play a crucial role. Compact sets in topology are advertised as sets that behave, in many important respects, as if they were ï¬nite. Then exhaustively searchable sets ought to be compact. And compact sets are known to be closed under continuous images and under ï¬nite and inï¬nite products. Moreover, for countably based Hausdorff spaces, they are the continuous images of the Cantor space. Hence searchable sets ought to have corresponding closure properties and characterization, which is what this work establishes, motivated by these considerations. Thus, in a more abstract level, topology is applied as a paradigm for discovering unforeseen notions, algorithms and theorems in computability theory. The role of topology in complexity. Moreover, topology also plays a role in highertype complexity: we have applied the notion of uniform continuity to measure the size of functional inputs in the formulation of run times for higher-type algorithms. 33

Operational perspective. The correctness proofs of Section 2 can be directly interpreted in the operational setting [7, 8]. But a development of operational counter-parts for those of Section 3 is left as an open problem. This requires an operational reworking of Section 3.3, which seems challenging. Programming languages for total and partial computation . As we have seen, Kleeneâ€“ Kreisel functionals and Scott domains live in the cartesian closed category of compactly generated spaces. Additionally, the inclusion of Scott domains (the Scott-topology functor) into the category of compactly generated spaces preserves the cartesian-closed structure [9, 2]. Hence total and partial higher-type functionals coexist in the same cartesian closed category. One can envisage a higher-type system that simultaneously incorporates total and partial objects, and corresponding PCF-style languages. Among the formation rules, it would make sense to stipulate that Ïƒ â†’ Ï„ is a partial type whenever Ï„ is a partial type. In o its simplest form, such a language could include GÂ¨ delâ€™s system T for total types and PCF for partial types. Such a language would have simpliï¬ed, and made more transparent, much of the development of Section 3, where we could have beneï¬ted from functionals that take total inputs and produce potentially partial outputs. Such functionals are actually total, but their construction uses modes of deï¬nition that belong to the realm of partial computation. The system-T fragment could be further extended with computable functionals such as bar recursion and some of those developed here, once one has shown they are indeed total. Semantics of practical programming languages. For experimental considerations regarding theoretical conjectures, it is important that the programming language under consideration has precisely speciï¬ed denotational and/or operational semantics. For correctness proofs, a denotational semantics is enough, but, for complexity considerations, one also needs a sufï¬ciently concrete operational semantics. Very often, and particularly in higher-type computation, an abstract operational semantics is useless for complexity considerations. While it may be rather hard in practice to prove that an implementation of the language respects a given semantics, one should expect the implementer of the language to at least promise that they intend the language to satisfy a precisely deï¬ned semantical speciï¬cation, as is the case of the language ML. In Section 4, we could have been more precise in our experiments regarding correctness and complexity if the Haskell deï¬nition had included such a semantics. Run-time behaviour in the higher-type setting. Continuing from the previous paragraph, of course, it is natural to suppose that such deï¬nitions of a language will be backed by theoretical work, such as [25, 15, 18, 30]. But, even if the speciï¬cations of practical languages such as Haskell were based on this kind of work, this wouldnâ€™t have been enough to prove the conjectures of Section 4. At present, we lack mathematical technology to reason about the run-time behaviour of higher-type programs under call-by-need evaluation (the Haskell programming community is well aware of this). For higher-type computability theory to have a tangible inï¬‚uence in computer science, these questions have to be investigated and elucidated.

References
[1] S. Abramsky and A. Jung. Domain theory. In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, volume 3 of Oxford science publications, pages 1â€“168. 1994. [2] I. Battenfeld, M. SchrÂ¨ der, and A. Simpson. A convenient category of domains. In o Computation, meaning, and logic: articles dedicated to Gordon Plotkin, volume 172 of Electron. Notes Theor. Comput. Sci., pages 69â€“99. Elsevier, Amsterdam, 2007. 34

[3] A. Bauer, M.H. EscardÂ´ , and A.K. Simpson. Comparing functional paradigms for o exact real-number computation. volume 2380 of Lect. Not. Comp. Sci., pages 488â€“ 500, 2002. [4] M.J. Beeson. Foundations of Constructive Mathematics. Springer, 1985. [5] U. Berger. Totale Objekte und Mengen in der Bereichstheorie. PhD thesis, Mathematisches Institut der UniversitÂ¨ t MÂ¨ nchen, 1990. au [6] U. Berger. Total sets and objects in domain theory. Ann. Pure Appl. Logic, 60(2):91â€“ 117, 1993. [7] M.H. EscardÂ´ . Synthetic topology of data types and classical spaces. Electron. Notes o Theor. Comput. Sci., 87:21â€“156, 2004. [8] M.H. EscardÂ´ and W.K. Ho. Operational domain theory and topology of a sequential o programming language. In Proceedings of the 20th Annual IEEE Symposium on Logic In Computer Science, pages 427â€“436, 2005. [9] M.H. EscardÂ´ , J. Lawson, and A. Simpson. Comparing Cartesian closed categories o of (core) compactly generated spaces. Topology Appl., 143(1-3):105â€“145, 2004. [10] D. Gale. Compact sets of functions and function rings. Proc. Amer. Math. Soc., 1:303â€“308, 1950. [11] R. O. Gandy and J. M. E. Hyland. Computable and recursively countable functions of higher type. In Logic Colloquium 76 (Oxford, 1976), pages 407â€“438. Studies in Logic and Found. Math., Vol. 87. North-Holland, Amsterdam, 1977. [12] G. Gierz, K.H. Hofmann, K. Keimel, J.D. Lawson, M. Mislove, and D.S. Scott. Continuous Lattices and Domains. Cambridge University Press, 2003. [13] G. Hutton. Programming in Haskell. Cambridge University Press, 2007. [14] J.L. Kelley. General Topology. D. van Nostrand, New York, 1955. [15] J. Launchbury. A natural semantics for lazy evaluation. In Proceedings of the Twentieth Annual ACM SIGPLANâ€“SIGACT on Principles of Programming Languages, pages 144â€“154. ACM Press, 1993. [16] J.R. Longley. Notions of computability at higher types. I. In Logic Colloquium 2000, volume 19 of Lect. Notes Log., pages 32â€“142. Assoc. Symbol. Logic, Urbana, IL, 2005. [17] J.R. Longley. On the ubiquity of certain type structures. Mathematical Structures in Computer Science, 17:841â€“953, 2007. [18] J. Maraist, M. Odersky, and P. Wadler. The call-by-need lambda calculus. J. Funct. Programming, 8(3):275â€“317, 1998. [19] D. Normann. Recursion on the countable functionals, volume 811 of Lec. Not. Math. Springer, 1980. [20] D. Normann. Computability over the partial continuous functionals. J. Symbolic Logic, 65(3):1133â€“1142, 2000. [21] D. Normann. Comparing hierarchies of total functionals. Logical Methods in Computer Science, 1(2):1â€“28, 2005. [22] D. Normann. Comparing hierarchies of total functionals. Log. Methods Comput. Sci., 1(2):2:4, 28, 2005. 35

[23] D. Normann. Computing with functionalsâ€”computability theory or computer science? Bull. Symbolic Logic, 12(1):43â€“59, 2006. [24] G. D. Plotkin. Call-by-name, call-by-value and the Î»-calculus. Theoret. Comput. Sci., 1(2):125â€“159, 1975. [25] G.D. Plotkin. LCF considered as a programming language. Theoret. Comput. Sci., 5(1):223â€“255, 1977. [26] G.D. Plotkin. TÏ‰ as a universal domain. J. Comput. System Sci., 17:209â€“236, 1978. [27] G.D. Plotkin. Full abstraction, totality and PCF. Math. Structures Comput. Sci., 9(1):1â€“20, 1999. [28] D.S. Scott. Data types as lattices. SIAM J. Comput., 5:522â€“587, 1976. [29] D.S. Scott. A type-theoretical alternative to CUCH, ISWIM and OWHY. Theoret. Comput. Sci., 121:411â€“440, 1993. Reprint of a 1969 manuscript. [30] F.-R. Sinot. Call-by-need in token-passing nets. Math. Structures Comput. Sci., 16(4):639â€“666, 2006. [31] M.B. Smyth. Topology. In S. Abramsky, D.M. Gabbay, and T.S.E. Maibaum, editors, Handbook of Logic in Computer Science, volume 1 of Oxford science publications, pages 641â€“761. 1992.

Contents
1 2 Introduction Topologically inspired algorithms 2.1 Background on higher-type computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.2 Exhaustible and searchable sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.3 Building new searchable sets from old . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Topologically based algorithms 3.1 Background on compactly generated spaces . . . . . . 3.2 Background on Kleeneâ€“Kreisel functionals . . . . . . 3.3 Compactness of exhaustible sets . . . . . . . . . . . . 3.4 Some computational properties of exhaustible sets . . . 3.5 Arzelaâ€“Ascoli type characterizations of compact sets . 3.6 Arzelaâ€“Ascoli type characterization of exhaustible sets Time-complexity considerations 4.1 The model of computation . . . . . . . . . . . . . . 4.2 The experimental setup . . . . . . . . . . . . . . . . 4.3 A ï¬rst experiment . . . . . . . . . . . . . . . . . . 4.4 Run-time as a function of the size of a functional input 4.5 The constant-cost hypothesis . . . . . . . . . . . . . 4.6 Bergerâ€™s algorithm run time . . . . . . . . . . . . . 4.7 Product-algorithms run time . . . . . . . . . . . . . 4.8 Haskell code for the experiments . . . . . . . . . . . Concluding remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 3 3 5 6 10 11 12 14 16 19 23 25 25 25 26 27 28 28 29 32 33

3

4

5

This ï¬le, a Haskell ï¬le, and more experimental results can be found at:
http://www.cs.bham.ac.uk/âˆ¼mhe/papers/exhaustive-journal.pdf http://www.cs.bham.ac.uk/âˆ¼mhe/papers/exhaustive-journal.hs http://www.cs.bham.ac.uk/âˆ¼mhe/papers/exhaustive-experimental-results.txt

36

