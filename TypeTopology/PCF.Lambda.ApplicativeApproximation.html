<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>PCF.Lambda.ApplicativeApproximation</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Brendan Hart 2019-2020

</a><a id="25" class="Markup">\begin{code}</a>

<a id="39" class="Symbol">{-#</a> <a id="43" class="Keyword">OPTIONS</a> <a id="51" class="Pragma">--safe</a> <a id="58" class="Pragma">--without-K</a> <a id="70" class="Symbol">#-}</a>

<a id="75" class="Keyword">open</a> <a id="80" class="Keyword">import</a> <a id="87" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="100" class="Keyword">open</a> <a id="105" class="Keyword">import</a> <a id="112" href="UF.PropTrunc.html" class="Module">UF.PropTrunc</a>

<a id="126" class="Keyword">module</a> <a id="133" href="PCF.Lambda.ApplicativeApproximation.html" class="Module">PCF.Lambda.ApplicativeApproximation</a>
        <a id="177" class="Symbol">(</a><a id="178" href="PCF.Lambda.ApplicativeApproximation.html#178" class="Bound">pt</a> <a id="181" class="Symbol">:</a> <a id="183" href="UF.PropTrunc.html#486" class="Record">propositional-truncations-exist</a><a id="214" class="Symbol">)</a>
       <a id="223" class="Keyword">where</a>

<a id="230" class="Keyword">open</a> <a id="235" href="UF.PropTrunc.html#792" class="Module">PropositionalTruncation</a> <a id="259" href="PCF.Lambda.ApplicativeApproximation.html#178" class="Bound">pt</a>

<a id="263" class="Keyword">open</a> <a id="268" class="Keyword">import</a> <a id="275" href="PCF.Lambda.AbstractSyntax.html" class="Module">PCF.Lambda.AbstractSyntax</a> <a id="301" href="PCF.Lambda.ApplicativeApproximation.html#178" class="Bound">pt</a>
<a id="304" class="Keyword">open</a> <a id="309" class="Keyword">import</a> <a id="316" href="PCF.Lambda.BigStep.html" class="Module">PCF.Lambda.BigStep</a> <a id="335" href="PCF.Lambda.ApplicativeApproximation.html#178" class="Bound">pt</a>

<a id="_⊏̰_"></a><a id="339" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">_⊏̰_</a> <a id="344" class="Symbol">:</a> <a id="346" class="Symbol">{</a><a id="347" href="PCF.Lambda.ApplicativeApproximation.html#347" class="Bound">σ</a> <a id="349" class="Symbol">:</a> <a id="351" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="355" class="Symbol">}</a> <a id="357" class="Symbol">→</a> <a id="359" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="363" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="366" href="PCF.Lambda.ApplicativeApproximation.html#347" class="Bound">σ</a> <a id="368" class="Symbol">→</a> <a id="370" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="374" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="377" href="PCF.Lambda.ApplicativeApproximation.html#347" class="Bound">σ</a> <a id="379" class="Symbol">→</a> <a id="381" href="Agda.Primitive.html#915" class="Primitive">𝓤₀</a> <a id="384" href="MLTT.Universes.html#3976" class="Function Operator">̇</a>
<a id="386" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">_⊏̰_</a> <a id="391" class="Symbol">{</a><a id="392" href="PCF.Lambda.AbstractSyntax.html#549" class="InductiveConstructor">ι</a><a id="393" class="Symbol">}</a>      <a id="400" href="PCF.Lambda.ApplicativeApproximation.html#400" class="Bound">M</a> <a id="402" href="PCF.Lambda.ApplicativeApproximation.html#402" class="Bound">N</a> <a id="404" class="Symbol">=</a> <a id="406" class="Symbol">(</a><a id="407" href="PCF.Lambda.ApplicativeApproximation.html#407" class="Bound">n</a> <a id="409" class="Symbol">:</a> <a id="411" href="MLTT.Natural-Numbers-Type.html#96" class="Datatype">ℕ</a><a id="412" class="Symbol">)</a> <a id="414" class="Symbol">→</a> <a id="416" href="PCF.Lambda.ApplicativeApproximation.html#400" class="Bound">M</a> <a id="418" href="PCF.Lambda.BigStep.html#2080" class="Function Operator">⇓</a> <a id="420" href="PCF.Lambda.AbstractSyntax.html#3699" class="Function">numeral</a> <a id="428" href="PCF.Lambda.ApplicativeApproximation.html#407" class="Bound">n</a> <a id="430" class="Symbol">→</a> <a id="432" href="PCF.Lambda.ApplicativeApproximation.html#402" class="Bound">N</a> <a id="434" href="PCF.Lambda.BigStep.html#2080" class="Function Operator">⇓</a> <a id="436" href="PCF.Lambda.AbstractSyntax.html#3699" class="Function">numeral</a> <a id="444" href="PCF.Lambda.ApplicativeApproximation.html#407" class="Bound">n</a>
<a id="446" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">_⊏̰_</a> <a id="451" class="Symbol">{</a><a id="452" href="PCF.Lambda.ApplicativeApproximation.html#452" class="Bound">σ</a> <a id="454" href="PCF.Lambda.AbstractSyntax.html#559" class="InductiveConstructor Operator">⇒</a> <a id="456" href="PCF.Lambda.ApplicativeApproximation.html#456" class="Bound">σ₁</a><a id="458" class="Symbol">}</a> <a id="460" href="PCF.Lambda.ApplicativeApproximation.html#460" class="Bound">M</a> <a id="462" href="PCF.Lambda.ApplicativeApproximation.html#462" class="Bound">N</a> <a id="464" class="Symbol">=</a> <a id="466" class="Symbol">(</a><a id="467" href="PCF.Lambda.ApplicativeApproximation.html#467" class="Bound">P</a> <a id="469" class="Symbol">:</a> <a id="471" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="475" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="478" href="PCF.Lambda.ApplicativeApproximation.html#452" class="Bound">σ</a><a id="479" class="Symbol">)</a> <a id="481" class="Symbol">→</a> <a id="483" class="Symbol">(</a><a id="484" href="PCF.Lambda.ApplicativeApproximation.html#460" class="Bound">M</a> <a id="486" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="488" href="PCF.Lambda.ApplicativeApproximation.html#467" class="Bound">P</a><a id="489" class="Symbol">)</a> <a id="491" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="494" class="Symbol">(</a><a id="495" href="PCF.Lambda.ApplicativeApproximation.html#462" class="Bound">N</a> <a id="497" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="499" href="PCF.Lambda.ApplicativeApproximation.html#467" class="Bound">P</a><a id="500" class="Symbol">)</a>

<a id="⊏̰-reflexive"></a><a id="503" href="PCF.Lambda.ApplicativeApproximation.html#503" class="Function">⊏̰-reflexive</a> <a id="516" class="Symbol">:</a> <a id="518" class="Symbol">{</a><a id="519" href="PCF.Lambda.ApplicativeApproximation.html#519" class="Bound">σ</a> <a id="521" class="Symbol">:</a> <a id="523" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="527" class="Symbol">}</a> <a id="529" class="Symbol">→</a> <a id="531" class="Symbol">(</a><a id="532" href="PCF.Lambda.ApplicativeApproximation.html#532" class="Bound">M</a> <a id="534" class="Symbol">:</a> <a id="536" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="540" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="543" href="PCF.Lambda.ApplicativeApproximation.html#519" class="Bound">σ</a><a id="544" class="Symbol">)</a> <a id="546" class="Symbol">→</a> <a id="548" href="PCF.Lambda.ApplicativeApproximation.html#532" class="Bound">M</a> <a id="550" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="553" href="PCF.Lambda.ApplicativeApproximation.html#532" class="Bound">M</a>
<a id="555" href="PCF.Lambda.ApplicativeApproximation.html#503" class="Function">⊏̰-reflexive</a> <a id="568" class="Symbol">{</a><a id="569" href="PCF.Lambda.AbstractSyntax.html#549" class="InductiveConstructor">ι</a><a id="570" class="Symbol">}</a>      <a id="577" href="PCF.Lambda.ApplicativeApproximation.html#577" class="Bound">M</a> <a id="579" class="Symbol">=</a> <a id="581" class="Symbol">λ</a> <a id="583" href="PCF.Lambda.ApplicativeApproximation.html#583" class="Bound">n</a> <a id="585" href="PCF.Lambda.ApplicativeApproximation.html#585" class="Bound">x</a> <a id="587" class="Symbol">→</a> <a id="589" href="PCF.Lambda.ApplicativeApproximation.html#585" class="Bound">x</a>
<a id="591" href="PCF.Lambda.ApplicativeApproximation.html#503" class="Function">⊏̰-reflexive</a> <a id="604" class="Symbol">{</a><a id="605" href="PCF.Lambda.ApplicativeApproximation.html#605" class="Bound">σ</a> <a id="607" href="PCF.Lambda.AbstractSyntax.html#559" class="InductiveConstructor Operator">⇒</a> <a id="609" href="PCF.Lambda.ApplicativeApproximation.html#609" class="Bound">σ₁</a><a id="611" class="Symbol">}</a> <a id="613" href="PCF.Lambda.ApplicativeApproximation.html#613" class="Bound">M</a> <a id="615" class="Symbol">=</a> <a id="617" class="Symbol">λ</a> <a id="619" href="PCF.Lambda.ApplicativeApproximation.html#619" class="Bound">P</a> <a id="621" class="Symbol">→</a> <a id="623" href="PCF.Lambda.ApplicativeApproximation.html#503" class="Function">⊏̰-reflexive</a> <a id="636" class="Symbol">(</a><a id="637" href="PCF.Lambda.ApplicativeApproximation.html#613" class="Bound">M</a> <a id="639" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="641" href="PCF.Lambda.ApplicativeApproximation.html#619" class="Bound">P</a><a id="642" class="Symbol">)</a>

<a id="⊏̰-transitive"></a><a id="645" href="PCF.Lambda.ApplicativeApproximation.html#645" class="Function">⊏̰-transitive</a> <a id="659" class="Symbol">:</a> <a id="661" class="Symbol">{</a><a id="662" href="PCF.Lambda.ApplicativeApproximation.html#662" class="Bound">σ</a> <a id="664" class="Symbol">:</a> <a id="666" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="670" class="Symbol">}</a> <a id="672" class="Symbol">{</a><a id="673" href="PCF.Lambda.ApplicativeApproximation.html#673" class="Bound">M</a> <a id="675" href="PCF.Lambda.ApplicativeApproximation.html#675" class="Bound">N</a> <a id="677" href="PCF.Lambda.ApplicativeApproximation.html#677" class="Bound">L</a> <a id="679" class="Symbol">:</a> <a id="681" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="685" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="688" href="PCF.Lambda.ApplicativeApproximation.html#662" class="Bound">σ</a><a id="689" class="Symbol">}</a> <a id="691" class="Symbol">→</a> <a id="693" href="PCF.Lambda.ApplicativeApproximation.html#673" class="Bound">M</a> <a id="695" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="698" href="PCF.Lambda.ApplicativeApproximation.html#675" class="Bound">N</a> <a id="700" class="Symbol">→</a> <a id="702" href="PCF.Lambda.ApplicativeApproximation.html#675" class="Bound">N</a> <a id="704" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="707" href="PCF.Lambda.ApplicativeApproximation.html#677" class="Bound">L</a> <a id="709" class="Symbol">→</a> <a id="711" href="PCF.Lambda.ApplicativeApproximation.html#673" class="Bound">M</a> <a id="713" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="716" href="PCF.Lambda.ApplicativeApproximation.html#677" class="Bound">L</a>
<a id="718" href="PCF.Lambda.ApplicativeApproximation.html#645" class="Function">⊏̰-transitive</a> <a id="732" class="Symbol">{</a><a id="733" href="PCF.Lambda.AbstractSyntax.html#549" class="InductiveConstructor">ι</a><a id="734" class="Symbol">}</a> <a id="736" class="Symbol">{</a><a id="737" href="PCF.Lambda.ApplicativeApproximation.html#737" class="Bound">M</a><a id="738" class="Symbol">}</a> <a id="740" class="Symbol">{</a><a id="741" href="PCF.Lambda.ApplicativeApproximation.html#741" class="Bound">N</a><a id="742" class="Symbol">}</a> <a id="744" class="Symbol">{</a><a id="745" href="PCF.Lambda.ApplicativeApproximation.html#745" class="Bound">L</a><a id="746" class="Symbol">}</a> <a id="748" href="PCF.Lambda.ApplicativeApproximation.html#748" class="Bound">p₁</a> <a id="751" href="PCF.Lambda.ApplicativeApproximation.html#751" class="Bound">p₂</a> <a id="754" href="PCF.Lambda.ApplicativeApproximation.html#754" class="Bound">n</a> <a id="756" href="PCF.Lambda.ApplicativeApproximation.html#756" class="Bound">step</a> <a id="761" class="Symbol">=</a> <a id="763" href="PCF.Lambda.ApplicativeApproximation.html#774" class="Function">γ</a>
 <a id="766" class="Keyword">where</a>
  <a id="774" href="PCF.Lambda.ApplicativeApproximation.html#774" class="Function">γ</a> <a id="776" class="Symbol">:</a> <a id="778" href="PCF.Lambda.ApplicativeApproximation.html#745" class="Bound">L</a> <a id="780" href="PCF.Lambda.BigStep.html#2080" class="Function Operator">⇓</a> <a id="782" href="PCF.Lambda.AbstractSyntax.html#3699" class="Function">numeral</a> <a id="790" href="PCF.Lambda.ApplicativeApproximation.html#754" class="Bound">n</a>
  <a id="794" href="PCF.Lambda.ApplicativeApproximation.html#774" class="Function">γ</a> <a id="796" class="Symbol">=</a> <a id="798" href="PCF.Lambda.ApplicativeApproximation.html#751" class="Bound">p₂</a> <a id="801" href="PCF.Lambda.ApplicativeApproximation.html#754" class="Bound">n</a> <a id="803" class="Symbol">(</a><a id="804" href="PCF.Lambda.ApplicativeApproximation.html#748" class="Bound">p₁</a> <a id="807" href="PCF.Lambda.ApplicativeApproximation.html#754" class="Bound">n</a> <a id="809" href="PCF.Lambda.ApplicativeApproximation.html#756" class="Bound">step</a><a id="813" class="Symbol">)</a>

<a id="816" href="PCF.Lambda.ApplicativeApproximation.html#645" class="Function">⊏̰-transitive</a> <a id="830" class="Symbol">{</a><a id="831" href="PCF.Lambda.ApplicativeApproximation.html#831" class="Bound">σ</a> <a id="833" href="PCF.Lambda.AbstractSyntax.html#559" class="InductiveConstructor Operator">⇒</a> <a id="835" href="PCF.Lambda.ApplicativeApproximation.html#835" class="Bound">σ₁</a><a id="837" class="Symbol">}</a> <a id="839" class="Symbol">{</a><a id="840" href="PCF.Lambda.ApplicativeApproximation.html#840" class="Bound">M</a><a id="841" class="Symbol">}</a> <a id="843" class="Symbol">{</a><a id="844" href="PCF.Lambda.ApplicativeApproximation.html#844" class="Bound">N</a><a id="845" class="Symbol">}</a> <a id="847" class="Symbol">{</a><a id="848" href="PCF.Lambda.ApplicativeApproximation.html#848" class="Bound">L</a><a id="849" class="Symbol">}</a> <a id="851" href="PCF.Lambda.ApplicativeApproximation.html#851" class="Bound">p₁</a> <a id="854" href="PCF.Lambda.ApplicativeApproximation.html#854" class="Bound">p₂</a> <a id="857" href="PCF.Lambda.ApplicativeApproximation.html#857" class="Bound">P</a> <a id="859" class="Symbol">=</a> <a id="861" href="PCF.Lambda.ApplicativeApproximation.html#872" class="Function">γ</a>
 <a id="864" class="Keyword">where</a>
  <a id="872" href="PCF.Lambda.ApplicativeApproximation.html#872" class="Function">γ</a> <a id="874" class="Symbol">:</a> <a id="876" class="Symbol">(</a><a id="877" href="PCF.Lambda.ApplicativeApproximation.html#840" class="Bound">M</a> <a id="879" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="881" href="PCF.Lambda.ApplicativeApproximation.html#857" class="Bound">P</a><a id="882" class="Symbol">)</a> <a id="884" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="887" class="Symbol">(</a><a id="888" href="PCF.Lambda.ApplicativeApproximation.html#848" class="Bound">L</a> <a id="890" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="892" href="PCF.Lambda.ApplicativeApproximation.html#857" class="Bound">P</a><a id="893" class="Symbol">)</a>
  <a id="897" href="PCF.Lambda.ApplicativeApproximation.html#872" class="Function">γ</a> <a id="899" class="Symbol">=</a> <a id="901" href="PCF.Lambda.ApplicativeApproximation.html#645" class="Function">⊏̰-transitive</a> <a id="915" class="Symbol">(</a><a id="916" href="PCF.Lambda.ApplicativeApproximation.html#851" class="Bound">p₁</a> <a id="919" href="PCF.Lambda.ApplicativeApproximation.html#857" class="Bound">P</a><a id="920" class="Symbol">)</a> <a id="922" class="Symbol">(</a><a id="923" href="PCF.Lambda.ApplicativeApproximation.html#854" class="Bound">p₂</a> <a id="926" href="PCF.Lambda.ApplicativeApproximation.html#857" class="Bound">P</a><a id="927" class="Symbol">)</a>

<a id="⊏̰-lemma"></a><a id="930" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="939" class="Symbol">:</a> <a id="941" class="Symbol">{</a><a id="942" href="PCF.Lambda.ApplicativeApproximation.html#942" class="Bound">σ</a> <a id="944" class="Symbol">:</a> <a id="946" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="950" class="Symbol">}</a> <a id="952" class="Symbol">(</a><a id="953" href="PCF.Lambda.ApplicativeApproximation.html#953" class="Bound">M</a> <a id="955" href="PCF.Lambda.ApplicativeApproximation.html#955" class="Bound">M&#39;</a> <a id="958" class="Symbol">:</a> <a id="960" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="964" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="967" href="PCF.Lambda.ApplicativeApproximation.html#942" class="Bound">σ</a><a id="968" class="Symbol">)</a>
        <a id="978" class="Symbol">→</a> <a id="980" class="Symbol">((</a><a id="982" href="PCF.Lambda.ApplicativeApproximation.html#982" class="Bound">V</a> <a id="984" class="Symbol">:</a> <a id="986" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="990" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="993" href="PCF.Lambda.ApplicativeApproximation.html#942" class="Bound">σ</a><a id="994" class="Symbol">)</a> <a id="996" class="Symbol">→</a> <a id="998" href="PCF.Lambda.ApplicativeApproximation.html#953" class="Bound">M</a> <a id="1000" href="PCF.Lambda.BigStep.html#323" class="Datatype Operator">⇓&#39;</a> <a id="1003" href="PCF.Lambda.ApplicativeApproximation.html#982" class="Bound">V</a> <a id="1005" class="Symbol">→</a> <a id="1007" href="PCF.Lambda.ApplicativeApproximation.html#955" class="Bound">M&#39;</a> <a id="1010" href="PCF.Lambda.BigStep.html#323" class="Datatype Operator">⇓&#39;</a> <a id="1013" href="PCF.Lambda.ApplicativeApproximation.html#982" class="Bound">V</a><a id="1014" class="Symbol">)</a>
        <a id="1024" class="Symbol">→</a> <a id="1026" href="PCF.Lambda.ApplicativeApproximation.html#953" class="Bound">M</a> <a id="1028" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="1031" href="PCF.Lambda.ApplicativeApproximation.html#955" class="Bound">M&#39;</a>
<a id="1034" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="1043" class="Symbol">{</a><a id="1044" href="PCF.Lambda.AbstractSyntax.html#549" class="InductiveConstructor">ι</a><a id="1045" class="Symbol">}</a>     <a id="1051" href="PCF.Lambda.ApplicativeApproximation.html#1051" class="Bound">M</a> <a id="1053" href="PCF.Lambda.ApplicativeApproximation.html#1053" class="Bound">M&#39;</a> <a id="1056" href="PCF.Lambda.ApplicativeApproximation.html#1056" class="Bound">f</a> <a id="1058" href="PCF.Lambda.ApplicativeApproximation.html#1058" class="Bound">n</a> <a id="1060" href="PCF.Lambda.ApplicativeApproximation.html#1060" class="Bound">x</a> <a id="1062" class="Symbol">=</a> <a id="1064" href="UF.PropTrunc.html#1817" class="Function">∥∥-functor</a> <a id="1075" class="Symbol">(λ</a> <a id="1078" href="PCF.Lambda.ApplicativeApproximation.html#1078" class="Bound">x₁</a> <a id="1081" class="Symbol">→</a> <a id="1083" href="PCF.Lambda.ApplicativeApproximation.html#1056" class="Bound">f</a> <a id="1085" class="Symbol">(</a><a id="1086" href="PCF.Lambda.AbstractSyntax.html#3699" class="Function">numeral</a> <a id="1094" href="PCF.Lambda.ApplicativeApproximation.html#1058" class="Bound">n</a><a id="1095" class="Symbol">)</a> <a id="1097" href="PCF.Lambda.ApplicativeApproximation.html#1078" class="Bound">x₁</a><a id="1099" class="Symbol">)</a> <a id="1101" href="PCF.Lambda.ApplicativeApproximation.html#1060" class="Bound">x</a>
<a id="1103" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="1112" class="Symbol">{</a><a id="1113" href="PCF.Lambda.ApplicativeApproximation.html#1113" class="Bound">σ</a> <a id="1115" href="PCF.Lambda.AbstractSyntax.html#559" class="InductiveConstructor Operator">⇒</a> <a id="1117" href="PCF.Lambda.ApplicativeApproximation.html#1117" class="Bound">τ</a><a id="1118" class="Symbol">}</a> <a id="1120" href="PCF.Lambda.ApplicativeApproximation.html#1120" class="Bound">M</a> <a id="1122" href="PCF.Lambda.ApplicativeApproximation.html#1122" class="Bound">M&#39;</a> <a id="1125" href="PCF.Lambda.ApplicativeApproximation.html#1125" class="Bound">f</a> <a id="1127" href="PCF.Lambda.ApplicativeApproximation.html#1127" class="Bound">P</a>   <a id="1131" class="Symbol">=</a> <a id="1133" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="1142" class="Symbol">(</a><a id="1143" href="PCF.Lambda.ApplicativeApproximation.html#1120" class="Bound">M</a> <a id="1145" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1147" href="PCF.Lambda.ApplicativeApproximation.html#1127" class="Bound">P</a><a id="1148" class="Symbol">)</a> <a id="1150" class="Symbol">(</a><a id="1151" href="PCF.Lambda.ApplicativeApproximation.html#1122" class="Bound">M&#39;</a> <a id="1154" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1156" href="PCF.Lambda.ApplicativeApproximation.html#1127" class="Bound">P</a><a id="1157" class="Symbol">)</a> <a id="1159" href="PCF.Lambda.ApplicativeApproximation.html#1170" class="Function">γ</a>
 <a id="1162" class="Keyword">where</a>
  <a id="1170" href="PCF.Lambda.ApplicativeApproximation.html#1170" class="Function">γ</a> <a id="1172" class="Symbol">:</a> <a id="1174" class="Symbol">(</a><a id="1175" href="PCF.Lambda.ApplicativeApproximation.html#1175" class="Bound">V</a> <a id="1177" class="Symbol">:</a> <a id="1179" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="1183" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="1186" href="PCF.Lambda.ApplicativeApproximation.html#1117" class="Bound">τ</a><a id="1187" class="Symbol">)</a> <a id="1189" class="Symbol">→</a> <a id="1191" class="Symbol">(</a><a id="1192" href="PCF.Lambda.ApplicativeApproximation.html#1120" class="Bound">M</a> <a id="1194" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1196" href="PCF.Lambda.ApplicativeApproximation.html#1127" class="Bound">P</a><a id="1197" class="Symbol">)</a> <a id="1199" href="PCF.Lambda.BigStep.html#323" class="Datatype Operator">⇓&#39;</a> <a id="1202" href="PCF.Lambda.ApplicativeApproximation.html#1175" class="Bound">V</a> <a id="1204" class="Symbol">→</a> <a id="1206" class="Symbol">(</a><a id="1207" href="PCF.Lambda.ApplicativeApproximation.html#1122" class="Bound">M&#39;</a> <a id="1210" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1212" href="PCF.Lambda.ApplicativeApproximation.html#1127" class="Bound">P</a><a id="1213" class="Symbol">)</a> <a id="1215" href="PCF.Lambda.BigStep.html#323" class="Datatype Operator">⇓&#39;</a> <a id="1218" href="PCF.Lambda.ApplicativeApproximation.html#1175" class="Bound">V</a>
  <a id="1222" href="PCF.Lambda.ApplicativeApproximation.html#1170" class="Function">γ</a> <a id="1224" href="PCF.Lambda.ApplicativeApproximation.html#1224" class="Bound">V</a> <a id="1226" class="Symbol">(</a><a id="1227" href="PCF.Lambda.BigStep.html#1855" class="InductiveConstructor">·-step</a> <a id="1234" class="Symbol">{_}</a> <a id="1238" class="Symbol">{_}</a> <a id="1242" class="Symbol">{_}</a> <a id="1246" class="Symbol">{_}</a> <a id="1250" class="Symbol">{_}</a> <a id="1254" class="Symbol">{</a><a id="1255" href="PCF.Lambda.ApplicativeApproximation.html#1255" class="Bound">E</a><a id="1256" class="Symbol">}</a> <a id="1258" href="PCF.Lambda.ApplicativeApproximation.html#1258" class="Bound">x</a> <a id="1260" href="PCF.Lambda.ApplicativeApproximation.html#1260" class="Bound">x₁</a><a id="1262" class="Symbol">)</a> <a id="1264" class="Symbol">=</a> <a id="1266" href="PCF.Lambda.BigStep.html#1855" class="InductiveConstructor">·-step</a> <a id="1273" href="PCF.Lambda.ApplicativeApproximation.html#1297" class="Function">M&#39;-step</a> <a id="1281" href="PCF.Lambda.ApplicativeApproximation.html#1260" class="Bound">x₁</a>
   <a id="1287" class="Keyword">where</a>
    <a id="1297" href="PCF.Lambda.ApplicativeApproximation.html#1297" class="Function">M&#39;-step</a> <a id="1305" class="Symbol">:</a> <a id="1307" href="PCF.Lambda.ApplicativeApproximation.html#1122" class="Bound">M&#39;</a> <a id="1310" href="PCF.Lambda.BigStep.html#323" class="Datatype Operator">⇓&#39;</a> <a id="1313" href="PCF.Lambda.AbstractSyntax.html#1182" class="InductiveConstructor">ƛ</a> <a id="1315" href="PCF.Lambda.ApplicativeApproximation.html#1255" class="Bound">E</a>
    <a id="1321" href="PCF.Lambda.ApplicativeApproximation.html#1297" class="Function">M&#39;-step</a> <a id="1329" class="Symbol">=</a> <a id="1331" href="PCF.Lambda.ApplicativeApproximation.html#1125" class="Bound">f</a> <a id="1333" class="Symbol">(</a><a id="1334" href="PCF.Lambda.AbstractSyntax.html#1182" class="InductiveConstructor">ƛ</a> <a id="1336" href="PCF.Lambda.ApplicativeApproximation.html#1255" class="Bound">E</a><a id="1337" class="Symbol">)</a> <a id="1339" href="PCF.Lambda.ApplicativeApproximation.html#1258" class="Bound">x</a>

<a id="β-⊏̰"></a><a id="1342" href="PCF.Lambda.ApplicativeApproximation.html#1342" class="Function">β-⊏̰</a> <a id="1347" class="Symbol">:</a> <a id="1349" class="Symbol">{</a><a id="1350" href="PCF.Lambda.ApplicativeApproximation.html#1350" class="Bound">σ</a> <a id="1352" href="PCF.Lambda.ApplicativeApproximation.html#1352" class="Bound">τ</a> <a id="1354" class="Symbol">:</a> <a id="1356" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="1360" class="Symbol">}</a> <a id="1362" class="Symbol">{</a><a id="1363" href="PCF.Lambda.ApplicativeApproximation.html#1363" class="Bound">M</a> <a id="1365" class="Symbol">:</a> <a id="1367" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="1371" class="Symbol">(</a><a id="1372" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="1375" href="PCF.Lambda.AbstractSyntax.html#380" class="InductiveConstructor Operator">’</a> <a id="1377" href="PCF.Lambda.ApplicativeApproximation.html#1350" class="Bound">σ</a><a id="1378" class="Symbol">)</a> <a id="1380" href="PCF.Lambda.ApplicativeApproximation.html#1352" class="Bound">τ</a><a id="1381" class="Symbol">}</a> <a id="1383" class="Symbol">{</a><a id="1384" href="PCF.Lambda.ApplicativeApproximation.html#1384" class="Bound">N</a> <a id="1386" class="Symbol">:</a> <a id="1388" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="1392" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="1395" href="PCF.Lambda.ApplicativeApproximation.html#1350" class="Bound">σ</a><a id="1396" class="Symbol">}</a>
    <a id="1402" class="Symbol">→</a> <a id="1404" class="Symbol">(</a><a id="1405" href="PCF.Lambda.ApplicativeApproximation.html#1363" class="Bound">M</a> <a id="1407" href="PCF.Lambda.AbstractSyntax.html#3552" class="Function Operator">[</a> <a id="1409" href="PCF.Lambda.ApplicativeApproximation.html#1384" class="Bound">N</a> <a id="1411" href="PCF.Lambda.AbstractSyntax.html#3552" class="Function Operator">]</a><a id="1412" class="Symbol">)</a> <a id="1414" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="1417" class="Symbol">(</a><a id="1418" href="PCF.Lambda.AbstractSyntax.html#1182" class="InductiveConstructor">ƛ</a> <a id="1420" href="PCF.Lambda.ApplicativeApproximation.html#1363" class="Bound">M</a> <a id="1422" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1424" href="PCF.Lambda.ApplicativeApproximation.html#1384" class="Bound">N</a><a id="1425" class="Symbol">)</a>
<a id="1427" href="PCF.Lambda.ApplicativeApproximation.html#1342" class="Function">β-⊏̰</a> <a id="1432" class="Symbol">{</a><a id="1433" href="PCF.Lambda.ApplicativeApproximation.html#1433" class="Bound">σ</a><a id="1434" class="Symbol">}</a> <a id="1436" class="Symbol">{</a><a id="1437" href="PCF.Lambda.ApplicativeApproximation.html#1437" class="Bound">τ</a><a id="1438" class="Symbol">}</a> <a id="1440" class="Symbol">{</a><a id="1441" href="PCF.Lambda.ApplicativeApproximation.html#1441" class="Bound">M</a><a id="1442" class="Symbol">}</a> <a id="1444" class="Symbol">{</a><a id="1445" href="PCF.Lambda.ApplicativeApproximation.html#1445" class="Bound">N</a><a id="1446" class="Symbol">}</a> <a id="1448" class="Symbol">=</a> <a id="1450" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="1459" class="Symbol">(</a><a id="1460" href="PCF.Lambda.ApplicativeApproximation.html#1441" class="Bound">M</a> <a id="1462" href="PCF.Lambda.AbstractSyntax.html#3552" class="Function Operator">[</a> <a id="1464" href="PCF.Lambda.ApplicativeApproximation.html#1445" class="Bound">N</a> <a id="1466" href="PCF.Lambda.AbstractSyntax.html#3552" class="Function Operator">]</a><a id="1467" class="Symbol">)</a> <a id="1469" class="Symbol">(</a><a id="1470" href="PCF.Lambda.AbstractSyntax.html#1182" class="InductiveConstructor">ƛ</a> <a id="1472" href="PCF.Lambda.ApplicativeApproximation.html#1441" class="Bound">M</a> <a id="1474" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1476" href="PCF.Lambda.ApplicativeApproximation.html#1445" class="Bound">N</a><a id="1477" class="Symbol">)</a> <a id="1479" class="Symbol">(λ</a> <a id="1482" href="PCF.Lambda.ApplicativeApproximation.html#1482" class="Bound">V</a> <a id="1484" href="PCF.Lambda.ApplicativeApproximation.html#1484" class="Bound">x</a> <a id="1486" class="Symbol">→</a> <a id="1488" href="PCF.Lambda.BigStep.html#1855" class="InductiveConstructor">·-step</a> <a id="1495" href="PCF.Lambda.BigStep.html#508" class="InductiveConstructor">ƛ-id</a> <a id="1500" href="PCF.Lambda.ApplicativeApproximation.html#1484" class="Bound">x</a><a id="1501" class="Symbol">)</a>

<a id="fix-⊏̰"></a><a id="1504" href="PCF.Lambda.ApplicativeApproximation.html#1504" class="Function">fix-⊏̰</a> <a id="1511" class="Symbol">:</a> <a id="1513" class="Symbol">{</a><a id="1514" href="PCF.Lambda.ApplicativeApproximation.html#1514" class="Bound">σ</a> <a id="1516" class="Symbol">:</a> <a id="1518" href="PCF.Lambda.AbstractSyntax.html#530" class="Datatype">type</a><a id="1522" class="Symbol">}</a> <a id="1524" class="Symbol">{</a><a id="1525" href="PCF.Lambda.ApplicativeApproximation.html#1525" class="Bound">M</a> <a id="1527" class="Symbol">:</a> <a id="1529" href="PCF.Lambda.AbstractSyntax.html#824" class="Datatype">PCF</a> <a id="1533" href="PCF.Lambda.AbstractSyntax.html#362" class="InductiveConstructor">⟨⟩</a> <a id="1536" class="Symbol">(</a><a id="1537" href="PCF.Lambda.ApplicativeApproximation.html#1514" class="Bound">σ</a> <a id="1539" href="PCF.Lambda.AbstractSyntax.html#559" class="InductiveConstructor Operator">⇒</a> <a id="1541" href="PCF.Lambda.ApplicativeApproximation.html#1514" class="Bound">σ</a><a id="1542" class="Symbol">)}</a> <a id="1545" class="Symbol">→</a> <a id="1547" class="Symbol">(</a><a id="1548" href="PCF.Lambda.ApplicativeApproximation.html#1525" class="Bound">M</a> <a id="1550" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1552" class="Symbol">(</a><a id="1553" href="PCF.Lambda.AbstractSyntax.html#1466" class="InductiveConstructor">Fix</a> <a id="1557" href="PCF.Lambda.ApplicativeApproximation.html#1525" class="Bound">M</a><a id="1558" class="Symbol">))</a> <a id="1561" href="PCF.Lambda.ApplicativeApproximation.html#339" class="Function Operator">⊏̰</a> <a id="1564" class="Symbol">(</a><a id="1565" href="PCF.Lambda.AbstractSyntax.html#1466" class="InductiveConstructor">Fix</a> <a id="1569" href="PCF.Lambda.ApplicativeApproximation.html#1525" class="Bound">M</a><a id="1570" class="Symbol">)</a>
<a id="1572" href="PCF.Lambda.ApplicativeApproximation.html#1504" class="Function">fix-⊏̰</a> <a id="1579" class="Symbol">{</a><a id="1580" href="PCF.Lambda.ApplicativeApproximation.html#1580" class="Bound">σ</a><a id="1581" class="Symbol">}</a> <a id="1583" class="Symbol">{</a><a id="1584" href="PCF.Lambda.ApplicativeApproximation.html#1584" class="Bound">M</a><a id="1585" class="Symbol">}</a> <a id="1587" class="Symbol">=</a> <a id="1589" href="PCF.Lambda.ApplicativeApproximation.html#930" class="Function">⊏̰-lemma</a> <a id="1598" class="Symbol">(</a><a id="1599" href="PCF.Lambda.ApplicativeApproximation.html#1584" class="Bound">M</a> <a id="1601" href="PCF.Lambda.AbstractSyntax.html#1278" class="InductiveConstructor Operator">·</a> <a id="1603" href="PCF.Lambda.AbstractSyntax.html#1466" class="InductiveConstructor">Fix</a> <a id="1607" href="PCF.Lambda.ApplicativeApproximation.html#1584" class="Bound">M</a><a id="1608" class="Symbol">)</a> <a id="1610" class="Symbol">(</a><a id="1611" href="PCF.Lambda.AbstractSyntax.html#1466" class="InductiveConstructor">Fix</a> <a id="1615" href="PCF.Lambda.ApplicativeApproximation.html#1584" class="Bound">M</a><a id="1616" class="Symbol">)</a> <a id="1618" class="Symbol">(λ</a> <a id="1621" href="PCF.Lambda.ApplicativeApproximation.html#1621" class="Bound">V</a> <a id="1623" href="PCF.Lambda.ApplicativeApproximation.html#1623" class="Bound">x</a> <a id="1625" class="Symbol">→</a> <a id="1627" href="PCF.Lambda.BigStep.html#1713" class="InductiveConstructor">Fix-step</a> <a id="1636" href="PCF.Lambda.ApplicativeApproximation.html#1623" class="Bound">x</a><a id="1637" class="Symbol">)</a>

<a id="1640" class="Markup">\end{code}</a><a id="1650" class="Background">
</a></pre></body></html>