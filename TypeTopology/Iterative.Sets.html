<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Iterative.Sets</title><link rel="stylesheet" href="Agda.css"><script type="text/javascript" src="highlight-hover.js"></script></head><body><pre class="Agda"><a id="1" class="Background">Martin Escardo &amp; Tom de Jong, June 2023.

Iterative sets.

We define the type of iterative sets as a subtype of that of multisets.

  * H. R. Gylterud, &quot;From multisets to sets in homotopy type theory&quot;.
    The Journal of Symbolic Logic, vol. 83, no. 3, pp. 1132–1146,
    2018. https://doi.org/10.1017/jsl.2017.84

See the module Iterative.index for further bibliographic references.

The previous module Iterative.Multisets doesn&#39;t make significant use
of univalence, and so we assumed it only for specific
constructions. But here the use of univalence is more pervasive, and
so we assume it globally.

</a><a id="605" class="Markup">\begin{code}</a>

<a id="619" class="Symbol">{-#</a> <a id="623" class="Keyword">OPTIONS</a> <a id="631" class="Pragma">--safe</a> <a id="638" class="Pragma">--without-K</a> <a id="650" class="Pragma">--lossy-unification</a> <a id="670" class="Symbol">#-}</a>

<a id="675" class="Keyword">open</a> <a id="680" class="Keyword">import</a> <a id="687" href="MLTT.Spartan.html" class="Module">MLTT.Spartan</a>
<a id="700" class="Keyword">open</a> <a id="705" class="Keyword">import</a> <a id="712" href="UF.Univalence.html" class="Module">UF.Univalence</a>

<a id="727" class="Keyword">module</a> <a id="734" href="Iterative.Sets.html" class="Module">Iterative.Sets</a>
        <a id="757" class="Symbol">(</a><a id="758" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="761" class="Symbol">:</a> <a id="763" href="UF.Univalence.html#494" class="Function">Univalence</a><a id="773" class="Symbol">)</a>
        <a id="783" class="Symbol">(</a><a id="784" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="786" class="Symbol">:</a> <a id="788" href="Agda.Primitive.html#742" class="Postulate">Universe</a><a id="796" class="Symbol">)</a>
       <a id="805" class="Keyword">where</a>

<a id="812" class="Keyword">open</a> <a id="817" class="Keyword">import</a> <a id="824" href="UF.FunExt.html" class="Module">UF.FunExt</a>
<a id="834" class="Keyword">open</a> <a id="839" class="Keyword">import</a> <a id="846" href="UF.UA-FunExt.html" class="Module">UF.UA-FunExt</a>

<a id="860" class="Keyword">private</a>
 <a id="𝓤⁺"></a><a id="869" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="872" class="Symbol">:</a> <a id="874" href="Agda.Primitive.html#742" class="Postulate">Universe</a>
 <a id="884" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="887" class="Symbol">=</a> <a id="889" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="891" href="Agda.Primitive.html#931" class="Primitive Operator">⁺</a>

 <a id="fe"></a><a id="895" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="898" class="Symbol">:</a> <a id="900" href="UF.FunExt.html#1047" class="Function">Fun-Ext</a>
 <a id="909" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="912" class="Symbol">=</a> <a id="914" href="UF.UA-FunExt.html#2577" class="Function">Univalence-gives-Fun-Ext</a> <a id="939" href="Iterative.Sets.html#758" class="Bound">ua</a>

 <a id="fe&#39;"></a><a id="944" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="948" class="Symbol">:</a> <a id="950" href="UF.FunExt.html#995" class="Function">FunExt</a>
 <a id="958" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="962" href="Iterative.Sets.html#962" class="Bound">𝓤</a> <a id="964" href="Iterative.Sets.html#964" class="Bound">𝓥</a> <a id="966" class="Symbol">=</a> <a id="968" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="971" class="Symbol">{</a><a id="972" href="Iterative.Sets.html#962" class="Bound">𝓤</a><a id="973" class="Symbol">}</a> <a id="975" class="Symbol">{</a><a id="976" href="Iterative.Sets.html#964" class="Bound">𝓥</a><a id="977" class="Symbol">}</a>

<a id="980" class="Keyword">open</a> <a id="985" class="Keyword">import</a> <a id="992" href="Iterative.Multisets.html" class="Module">Iterative.Multisets</a> <a id="1012" href="Iterative.Sets.html#784" class="Bound">𝓤</a>
<a id="1014" class="Keyword">open</a> <a id="1019" class="Keyword">import</a> <a id="1026" href="Ordinals.Notions.html" class="Module">Ordinals.Notions</a>
<a id="1043" class="Keyword">open</a> <a id="1048" class="Keyword">import</a> <a id="1055" href="UF.Base.html" class="Module">UF.Base</a>
<a id="1063" class="Keyword">open</a> <a id="1068" class="Keyword">import</a> <a id="1075" href="UF.DiscreteAndSeparated.html" class="Module">UF.DiscreteAndSeparated</a>
<a id="1099" class="Keyword">open</a> <a id="1104" class="Keyword">import</a> <a id="1111" href="UF.Embeddings.html" class="Module">UF.Embeddings</a>
<a id="1125" class="Keyword">open</a> <a id="1130" class="Keyword">import</a> <a id="1137" href="UF.Equiv.html" class="Module">UF.Equiv</a>
<a id="1146" class="Keyword">open</a> <a id="1151" class="Keyword">import</a> <a id="1158" href="UF.EquivalenceExamples.html" class="Module">UF.EquivalenceExamples</a>
<a id="1181" class="Keyword">open</a> <a id="1186" class="Keyword">import</a> <a id="1193" href="UF.PairFun.html" class="Module">UF.PairFun</a>
<a id="1204" class="Keyword">open</a> <a id="1209" class="Keyword">import</a> <a id="1216" href="UF.Retracts.html" class="Module">UF.Retracts</a>
<a id="1228" class="Keyword">open</a> <a id="1233" class="Keyword">import</a> <a id="1240" href="UF.Sets.html" class="Module">UF.Sets</a>
<a id="1248" class="Keyword">open</a> <a id="1253" class="Keyword">import</a> <a id="1260" href="UF.Size.html" class="Module">UF.Size</a>
<a id="1268" class="Keyword">open</a> <a id="1273" class="Keyword">import</a> <a id="1280" href="UF.Subsingletons.html" class="Module">UF.Subsingletons</a>
<a id="1297" class="Keyword">open</a> <a id="1302" class="Keyword">import</a> <a id="1309" href="UF.Subsingletons-FunExt.html" class="Module">UF.Subsingletons-FunExt</a>
<a id="1333" class="Keyword">open</a> <a id="1338" class="Keyword">import</a> <a id="1345" href="W.Type.html" class="Module">W.Type</a>

<a id="1353" class="Markup">\end{code}</a><a id="1363" class="Background">

An iterative set is a multiset whose subforests are all
embeddings. The effect of that is that the membership relation on
iterative sets is proposition-valued, rather than just type-valued, as
is the case for general multisets.

</a><a id="1594" class="Markup">\begin{code}</a>

<a id="is-iterative-set"></a><a id="1608" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1625" class="Symbol">:</a> <a id="1627" href="Iterative.Multisets.html#691" class="Function">𝕄</a> <a id="1629" class="Symbol">→</a> <a id="1631" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="1634" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="1636" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1653" class="Symbol">(</a><a id="1654" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="1659" href="Iterative.Sets.html#1659" class="Bound">X</a> <a id="1661" href="Iterative.Sets.html#1661" class="Bound">φ</a><a id="1662" class="Symbol">)</a> <a id="1664" class="Symbol">=</a> <a id="1666" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="1679" href="Iterative.Sets.html#1661" class="Bound">φ</a>
                            <a id="1709" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="1711" class="Symbol">((</a><a id="1713" href="Iterative.Sets.html#1713" class="Bound">x</a> <a id="1715" class="Symbol">:</a> <a id="1717" href="Iterative.Sets.html#1659" class="Bound">X</a><a id="1718" class="Symbol">)</a> <a id="1720" class="Symbol">→</a> <a id="1722" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1739" class="Symbol">(</a><a id="1740" href="Iterative.Sets.html#1661" class="Bound">φ</a> <a id="1742" href="Iterative.Sets.html#1713" class="Bound">x</a><a id="1743" class="Symbol">))</a>
<a id="1746" class="Markup">\end{code}</a><a id="1756" class="Background">

It is convenient to name the projections for the sake of clarity:

</a><a id="1825" class="Markup">\begin{code}</a>

<a id="𝕄-forest-is-embedding"></a><a id="1839" href="Iterative.Sets.html#1839" class="Function">𝕄-forest-is-embedding</a> <a id="1861" class="Symbol">:</a> <a id="1863" class="Symbol">(</a><a id="1864" href="Iterative.Sets.html#1864" class="Bound">M</a> <a id="1866" class="Symbol">:</a> <a id="1868" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="1869" class="Symbol">)</a>
                      <a id="1893" class="Symbol">→</a> <a id="1895" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="1912" href="Iterative.Sets.html#1864" class="Bound">M</a>
                      <a id="1936" class="Symbol">→</a> <a id="1938" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="1951" class="Symbol">(</a><a id="1952" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="1961" href="Iterative.Sets.html#1864" class="Bound">M</a><a id="1962" class="Symbol">)</a>
<a id="1964" href="Iterative.Sets.html#1839" class="Function">𝕄-forest-is-embedding</a> <a id="1986" class="Symbol">(</a><a id="1987" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="1992" class="Symbol">_</a> <a id="1994" class="Symbol">_)</a> <a id="1997" class="Symbol">=</a> <a id="1999" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a>

<a id="𝕄-subtrees-are-iterative"></a><a id="2004" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a> <a id="2029" class="Symbol">:</a> <a id="2031" class="Symbol">(</a><a id="2032" href="Iterative.Sets.html#2032" class="Bound">M</a> <a id="2034" class="Symbol">:</a> <a id="2036" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="2037" class="Symbol">)</a>
                         <a id="2064" class="Symbol">→</a> <a id="2066" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2083" href="Iterative.Sets.html#2032" class="Bound">M</a>
                         <a id="2110" class="Symbol">→</a> <a id="2112" class="Symbol">(</a><a id="2113" href="Iterative.Sets.html#2113" class="Bound">x</a> <a id="2115" class="Symbol">:</a> <a id="2117" href="Iterative.Multisets.html#1708" class="Function">𝕄-root</a> <a id="2124" href="Iterative.Sets.html#2032" class="Bound">M</a><a id="2125" class="Symbol">)</a> <a id="2127" class="Symbol">→</a> <a id="2129" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2146" class="Symbol">(</a><a id="2147" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="2156" href="Iterative.Sets.html#2032" class="Bound">M</a> <a id="2158" href="Iterative.Sets.html#2113" class="Bound">x</a><a id="2159" class="Symbol">)</a>
<a id="2161" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a> <a id="2186" class="Symbol">(</a><a id="2187" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="2192" class="Symbol">_</a> <a id="2194" class="Symbol">_)</a> <a id="2197" class="Symbol">=</a> <a id="2199" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a>

<a id="2204" class="Markup">\end{code}</a><a id="2214" class="Background">

It is crucial that the notion of iterative set is property rather than
data:

</a><a id="2294" class="Markup">\begin{code}</a>

<a id="being-iset-is-prop"></a><a id="2308" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2327" class="Symbol">:</a> <a id="2329" class="Symbol">(</a><a id="2330" href="Iterative.Sets.html#2330" class="Bound">M</a> <a id="2332" class="Symbol">:</a> <a id="2334" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="2335" class="Symbol">)</a> <a id="2337" class="Symbol">→</a> <a id="2339" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="2347" class="Symbol">(</a><a id="2348" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2365" href="Iterative.Sets.html#2330" class="Bound">M</a><a id="2366" class="Symbol">)</a>
<a id="2368" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2387" class="Symbol">(</a><a id="2388" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="2393" href="Iterative.Sets.html#2393" class="Bound">X</a> <a id="2395" href="Iterative.Sets.html#2395" class="Bound">φ</a><a id="2396" class="Symbol">)</a> <a id="2398" class="Symbol">=</a>
 <a id="2401" href="UF.Subsingletons.html#4800" class="Function">×-is-prop</a>
  <a id="2413" class="Symbol">(</a><a id="2414" href="UF.Embeddings.html#691" class="Function">being-embedding-is-prop</a> <a id="2438" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="2441" href="Iterative.Sets.html#2395" class="Bound">φ</a><a id="2442" class="Symbol">)</a>
  <a id="2446" class="Symbol">(</a><a id="2447" href="UF.Subsingletons-FunExt.html#614" class="Function">Π-is-prop</a> <a id="2457" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="2460" class="Symbol">(λ</a> <a id="2463" href="Iterative.Sets.html#2463" class="Bound">x</a> <a id="2465" class="Symbol">→</a> <a id="2467" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="2486" class="Symbol">(</a><a id="2487" href="Iterative.Sets.html#2395" class="Bound">φ</a> <a id="2489" href="Iterative.Sets.html#2463" class="Bound">x</a><a id="2490" class="Symbol">)))</a>

<a id="2495" class="Markup">\end{code}</a><a id="2505" class="Background">

The type of iterative sets as a subtype of that of iterative
multisets:

</a><a id="2580" class="Markup">\begin{code}</a>

<a id="𝕍"></a><a id="2594" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2596" class="Symbol">:</a> <a id="2598" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="2601" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="2603" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2605" class="Symbol">=</a> <a id="2607" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="2609" href="Iterative.Sets.html#2609" class="Bound">M</a> <a id="2611" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="2613" href="Iterative.Multisets.html#691" class="Function">𝕄</a> <a id="2615" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="2617" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2634" href="Iterative.Sets.html#2609" class="Bound">M</a>

<a id="𝕍-is-locally-small"></a><a id="2637" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="2656" class="Symbol">:</a> <a id="2658" href="UF.Size.html#27103" class="Function">is-locally-small</a> <a id="2675" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="2677" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="2696" class="Symbol">=</a> <a id="2698" href="UF.Size.html#29676" class="Function">subtype-is-locally-small</a>
                      <a id="2745" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>
                      <a id="2786" class="Symbol">(</a><a id="2787" href="Iterative.Multisets.html#7444" class="Function">𝕄-is-locally-small</a> <a id="2806" href="Iterative.Sets.html#758" class="Bound">ua</a><a id="2808" class="Symbol">)</a>
<a id="2810" class="Markup">\end{code}</a><a id="2820" class="Background">

We again name the projections for the sake of clarity:

</a><a id="2878" class="Markup">\begin{code}</a>

<a id="underlying-mset"></a><a id="2892" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="2908" class="Symbol">:</a> <a id="2910" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="2912" class="Symbol">→</a> <a id="2914" href="Iterative.Multisets.html#691" class="Function">𝕄</a>
<a id="2916" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="2932" class="Symbol">=</a> <a id="2934" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a>

<a id="isets-are-iterative"></a><a id="2939" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="2959" class="Symbol">:</a> <a id="2961" class="Symbol">(</a><a id="2962" href="Iterative.Sets.html#2962" class="Bound">A</a> <a id="2964" class="Symbol">:</a> <a id="2966" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="2967" class="Symbol">)</a> <a id="2969" class="Symbol">→</a> <a id="2971" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="2988" class="Symbol">(</a><a id="2989" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3005" href="Iterative.Sets.html#2962" class="Bound">A</a><a id="3006" class="Symbol">)</a>
<a id="3008" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="3028" class="Symbol">=</a> <a id="3030" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a>

<a id="3035" class="Markup">\end{code}</a><a id="3045" class="Background">

Because the notion of iterative set is property, we get that 𝕍 is
indeed a subtype of 𝕄.

</a><a id="3137" class="Markup">\begin{code}</a>

<a id="underlying-mset-is-embedding"></a><a id="3151" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a> <a id="3180" class="Symbol">:</a> <a id="3182" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="3195" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a>
<a id="3211" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a> <a id="3240" class="Symbol">=</a> <a id="3242" href="UF.Embeddings.html#8619" class="Function">pr₁-is-embedding</a> <a id="3259" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>

<a id="3279" class="Markup">\end{code}</a><a id="3289" class="Background">

We define the root and the forest of an iterative set in terms of
those for multisets, but we need to add a &quot;proof obligation&quot; in the
case of the forest.

</a><a id="3446" class="Markup">\begin{code}</a>

<a id="𝕍-root"></a><a id="3460" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3467" class="Symbol">:</a> <a id="3469" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="3471" class="Symbol">→</a> <a id="3473" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="3475" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="3477" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3484" href="Iterative.Sets.html#3484" class="Bound">A</a> <a id="3486" class="Symbol">=</a> <a id="3488" href="Iterative.Multisets.html#1708" class="Function">𝕄-root</a> <a id="3495" class="Symbol">(</a><a id="3496" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3512" href="Iterative.Sets.html#3484" class="Bound">A</a><a id="3513" class="Symbol">)</a>

<a id="𝕍-forest"></a><a id="3516" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="3525" class="Symbol">:</a> <a id="3527" class="Symbol">(</a><a id="3528" href="Iterative.Sets.html#3528" class="Bound">A</a> <a id="3530" class="Symbol">:</a> <a id="3532" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="3533" class="Symbol">)</a> <a id="3535" class="Symbol">→</a> <a id="3537" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="3544" href="Iterative.Sets.html#3528" class="Bound">A</a> <a id="3546" class="Symbol">→</a> <a id="3548" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="3550" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="3559" href="Iterative.Sets.html#3559" class="Bound">A</a> <a id="3561" href="Iterative.Sets.html#3561" class="Bound">x</a> <a id="3563" class="Symbol">=</a> <a id="3565" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="3574" class="Symbol">(</a><a id="3575" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3591" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3592" class="Symbol">)</a> <a id="3594" href="Iterative.Sets.html#3561" class="Bound">x</a> <a id="3596" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
               <a id="3613" href="Iterative.Sets.html#2004" class="Function">𝕄-subtrees-are-iterative</a>
                <a id="3654" class="Symbol">(</a><a id="3655" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="3671" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3672" class="Symbol">)</a>
                <a id="3690" class="Symbol">(</a><a id="3691" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="3711" href="Iterative.Sets.html#3559" class="Bound">A</a><a id="3712" class="Symbol">)</a>
                <a id="3730" href="Iterative.Sets.html#3561" class="Bound">x</a>

<a id="3733" class="Markup">\end{code}</a><a id="3743" class="Background">

A criterion for equality in 𝕍:

</a><a id="3777" class="Markup">\begin{code}</a>

<a id="to-𝕍-＝"></a><a id="3791" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="3798" class="Symbol">:</a> <a id="3800" class="Symbol">{</a><a id="3801" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3803" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3805" class="Symbol">:</a> <a id="3807" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="3809" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="3811" class="Symbol">}</a>
          <a id="3823" class="Symbol">{</a><a id="3824" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="3826" class="Symbol">:</a> <a id="3828" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3830" class="Symbol">→</a> <a id="3832" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="3833" class="Symbol">}</a>
          <a id="3845" class="Symbol">{</a><a id="3846" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="3848" class="Symbol">:</a> <a id="3850" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3852" class="Symbol">→</a> <a id="3854" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="3855" class="Symbol">}</a>
        <a id="3865" class="Symbol">→</a> <a id="3867" class="Symbol">(</a><a id="3868" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="3870" href="Iterative.Sets.html#3870" class="Bound">p</a> <a id="3872" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="3874" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3876" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3878" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3880" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="3882" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="3884" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="3886" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="3888" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="3890" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="3898" href="Iterative.Sets.html#3870" class="Bound">p</a><a id="3899" class="Symbol">)</a>
        <a id="3909" class="Symbol">→</a> <a id="3911" class="Symbol">(</a><a id="3912" href="Iterative.Sets.html#3912" class="Bound">i</a> <a id="3914" class="Symbol">:</a> <a id="3916" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="3933" class="Symbol">(</a><a id="3934" class="InductiveConstructor">ssup</a> <a id="3939" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="3941" href="Iterative.Sets.html#3824" class="Bound">φ</a><a id="3942" class="Symbol">))</a>
          <a id="3955" class="Symbol">(</a><a id="3956" href="Iterative.Sets.html#3956" class="Bound">j</a> <a id="3958" class="Symbol">:</a> <a id="3960" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="3977" class="Symbol">(</a><a id="3978" class="InductiveConstructor">ssup</a> <a id="3983" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="3985" href="Iterative.Sets.html#3846" class="Bound">γ</a><a id="3986" class="Symbol">))</a>
        <a id="3997" class="Symbol">→</a> <a id="3999" class="Symbol">(</a><a id="4000" class="InductiveConstructor">ssup</a> <a id="4005" href="Iterative.Sets.html#3801" class="Bound">X</a> <a id="4007" href="Iterative.Sets.html#3824" class="Bound">φ</a> <a id="4009" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4011" href="Iterative.Sets.html#3912" class="Bound">i</a><a id="4012" class="Symbol">)</a> <a id="4014" href="MLTT.Identity-Type.html#181" class="Function">＝[</a> <a id="4017" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4019" href="MLTT.Identity-Type.html#181" class="Function">]</a> <a id="4021" class="Symbol">(</a><a id="4022" class="InductiveConstructor">ssup</a> <a id="4027" href="Iterative.Sets.html#3803" class="Bound">Y</a> <a id="4029" href="Iterative.Sets.html#3846" class="Bound">γ</a> <a id="4031" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4033" href="Iterative.Sets.html#3956" class="Bound">j</a><a id="4034" class="Symbol">)</a>
<a id="4036" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="4043" href="Iterative.Sets.html#4043" class="Bound">σ</a> <a id="4045" href="Iterative.Sets.html#4045" class="Bound">i</a> <a id="4047" href="Iterative.Sets.html#4047" class="Bound">j</a> <a id="4049" class="Symbol">=</a> <a id="4051" href="UF.Subsingletons.html#4964" class="Function">to-subtype-＝</a> <a id="4064" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="4083" class="Symbol">(</a><a id="4084" href="Iterative.Multisets.html#3576" class="Function">to-𝕄-＝</a> <a id="4091" href="Iterative.Sets.html#4043" class="Bound">σ</a><a id="4092" class="Symbol">)</a>

<a id="4095" class="Markup">\end{code}</a><a id="4105" class="Background">

We define membership of iterative sets in terms of that for multisets:

</a><a id="4179" class="Markup">\begin{code}</a>

<a id="_∈_"></a><a id="4193" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="4197" class="Symbol">:</a> <a id="4199" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4201" class="Symbol">→</a> <a id="4203" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4205" class="Symbol">→</a> <a id="4207" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="4210" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="4212" href="Iterative.Sets.html#4212" class="Bound">A</a> <a id="4214" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4216" href="Iterative.Sets.html#4216" class="Bound">B</a> <a id="4218" class="Symbol">=</a> <a id="4220" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4236" href="Iterative.Sets.html#4212" class="Bound">A</a> <a id="4238" href="Iterative.Multisets.html#2316" class="Function Operator">⁅</a> <a id="4240" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4256" href="Iterative.Sets.html#4216" class="Bound">B</a>

<a id="4259" class="Markup">\end{code}</a><a id="4269" class="Background">

As is the case for iterative multisets, there is a resized down,
equivalent definition of membership.

</a><a id="4374" class="Markup">\begin{code}</a>

<a id="_∈⁻_"></a><a id="4388" href="Iterative.Sets.html#4388" class="Function Operator">_∈⁻_</a> <a id="4393" class="Symbol">:</a> <a id="4395" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4397" class="Symbol">→</a> <a id="4399" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="4401" class="Symbol">→</a> <a id="4403" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="4405" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="4407" href="Iterative.Sets.html#4407" class="Bound">A</a> <a id="4409" href="Iterative.Sets.html#4388" class="Function Operator">∈⁻</a> <a id="4412" href="Iterative.Sets.html#4412" class="Bound">B</a> <a id="4414" class="Symbol">=</a> <a id="4416" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4432" href="Iterative.Sets.html#4407" class="Bound">A</a> <a id="4434" href="Iterative.Multisets.html#7731" class="Function Operator">⁅⁻</a> <a id="4437" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4453" href="Iterative.Sets.html#4412" class="Bound">B</a>

<a id="∈⁻≃∈"></a><a id="4456" href="Iterative.Sets.html#4456" class="Function">∈⁻≃∈</a> <a id="4461" class="Symbol">:</a> <a id="4463" class="Symbol">(</a><a id="4464" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4466" href="Iterative.Sets.html#4466" class="Bound">B</a> <a id="4468" class="Symbol">:</a> <a id="4470" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4471" class="Symbol">)</a> <a id="4473" class="Symbol">→</a> <a id="4475" class="Symbol">(</a><a id="4476" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4478" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4480" href="Iterative.Sets.html#4466" class="Bound">B</a><a id="4481" class="Symbol">)</a> <a id="4483" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="4485" class="Symbol">(</a><a id="4486" href="Iterative.Sets.html#4464" class="Bound">A</a> <a id="4488" href="Iterative.Sets.html#4388" class="Function Operator">∈⁻</a> <a id="4491" href="Iterative.Sets.html#4466" class="Bound">B</a><a id="4492" class="Symbol">)</a>
<a id="4494" href="Iterative.Sets.html#4456" class="Function">∈⁻≃∈</a> <a id="4499" href="Iterative.Sets.html#4499" class="Bound">A</a> <a id="4501" href="Iterative.Sets.html#4501" class="Bound">B</a> <a id="4503" class="Symbol">=</a> <a id="4505" href="Iterative.Multisets.html#7795" class="Function">⁅⁻≃⁅</a> <a id="4510" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="4513" class="Symbol">(</a><a id="4514" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4530" href="Iterative.Sets.html#4499" class="Bound">A</a><a id="4531" class="Symbol">)</a> <a id="4533" class="Symbol">(</a><a id="4534" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4550" href="Iterative.Sets.html#4501" class="Bound">B</a><a id="4551" class="Symbol">)</a>

<a id="4554" class="Markup">\end{code}</a><a id="4564" class="Background">

As discussed above, the membership relation becomes a proposition
precisely because we required forests to be embeddings to define the
subtype of iterative sets.

</a><a id="4729" class="Markup">\begin{code}</a>

<a id="∈-is-prop-valued"></a><a id="4743" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="4760" class="Symbol">:</a> <a id="4762" class="Symbol">(</a><a id="4763" href="Iterative.Sets.html#4763" class="Bound">A</a> <a id="4765" href="Iterative.Sets.html#4765" class="Bound">B</a> <a id="4767" class="Symbol">:</a> <a id="4769" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4770" class="Symbol">)</a> <a id="4772" class="Symbol">→</a> <a id="4774" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="4782" class="Symbol">(</a><a id="4783" href="Iterative.Sets.html#4763" class="Bound">A</a> <a id="4785" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4787" href="Iterative.Sets.html#4765" class="Bound">B</a><a id="4788" class="Symbol">)</a>
<a id="4790" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="4807" class="Symbol">(</a><a id="4808" href="Iterative.Sets.html#4808" class="Bound">M</a> <a id="4810" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4812" class="Symbol">_)</a> <a id="4815" class="Symbol">(</a><a id="4816" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="4821" href="Iterative.Sets.html#4821" class="Bound">X</a> <a id="4823" href="Iterative.Sets.html#4823" class="Bound">φ</a> <a id="4825" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4827" href="Iterative.Sets.html#4827" class="Bound">φ-emb</a> <a id="4833" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="4835" class="Symbol">_)</a> <a id="4838" class="Symbol">=</a> <a id="4840" href="Iterative.Sets.html#4827" class="Bound">φ-emb</a> <a id="4846" href="Iterative.Sets.html#4808" class="Bound">M</a>

<a id="𝕍-forest-∈"></a><a id="4849" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="4860" class="Symbol">:</a> <a id="4862" class="Symbol">(</a><a id="4863" href="Iterative.Sets.html#4863" class="Bound">A</a> <a id="4865" class="Symbol">:</a> <a id="4867" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="4868" class="Symbol">)</a> <a id="4870" class="Symbol">(</a><a id="4871" href="Iterative.Sets.html#4871" class="Bound">x</a> <a id="4873" class="Symbol">:</a> <a id="4875" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="4882" href="Iterative.Sets.html#4863" class="Bound">A</a><a id="4883" class="Symbol">)</a> <a id="4885" class="Symbol">→</a> <a id="4887" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="4896" href="Iterative.Sets.html#4863" class="Bound">A</a> <a id="4898" href="Iterative.Sets.html#4871" class="Bound">x</a> <a id="4900" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="4902" href="Iterative.Sets.html#4863" class="Bound">A</a>
<a id="4904" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="4915" href="Iterative.Sets.html#4915" class="Bound">A</a> <a id="4917" href="Iterative.Sets.html#4917" class="Bound">x</a> <a id="4919" class="Symbol">=</a> <a id="4921" href="Iterative.Multisets.html#2924" class="Function">𝕄-forest-⁅</a> <a id="4932" class="Symbol">(</a><a id="4933" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="4949" href="Iterative.Sets.html#4915" class="Bound">A</a><a id="4950" class="Symbol">)</a> <a id="4952" href="Iterative.Sets.html#4917" class="Bound">x</a>

<a id="4955" class="Markup">\end{code}</a><a id="4965" class="Background">

The subset relation is defined in the usual way and is
proposition-valued:

</a><a id="5043" class="Markup">\begin{code}</a>

<a id="_⊆_"></a><a id="5057" href="Iterative.Sets.html#5057" class="Function Operator">_⊆_</a> <a id="5061" class="Symbol">:</a> <a id="5063" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="5065" class="Symbol">→</a> <a id="5067" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="5069" class="Symbol">→</a> <a id="5071" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="5074" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
<a id="5076" href="Iterative.Sets.html#5076" class="Bound">A</a> <a id="5078" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5080" href="Iterative.Sets.html#5080" class="Bound">B</a> <a id="5082" class="Symbol">=</a> <a id="5084" class="Symbol">(</a><a id="5085" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5087" class="Symbol">:</a> <a id="5089" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">→</a> <a id="5094" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5096" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="5098" href="Iterative.Sets.html#5076" class="Bound">A</a> <a id="5100" class="Symbol">→</a> <a id="5102" href="Iterative.Sets.html#5085" class="Bound">C</a> <a id="5104" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="5106" href="Iterative.Sets.html#5080" class="Bound">B</a>

<a id="⊆-is-prop-valued"></a><a id="5109" href="Iterative.Sets.html#5109" class="Function">⊆-is-prop-valued</a> <a id="5126" class="Symbol">:</a> <a id="5128" class="Symbol">(</a><a id="5129" href="Iterative.Sets.html#5129" class="Bound">A</a> <a id="5131" href="Iterative.Sets.html#5131" class="Bound">B</a> <a id="5133" class="Symbol">:</a> <a id="5135" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5136" class="Symbol">)</a> <a id="5138" class="Symbol">→</a> <a id="5140" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="5148" class="Symbol">(</a><a id="5149" href="Iterative.Sets.html#5129" class="Bound">A</a> <a id="5151" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5153" href="Iterative.Sets.html#5131" class="Bound">B</a><a id="5154" class="Symbol">)</a>
<a id="5156" href="Iterative.Sets.html#5109" class="Function">⊆-is-prop-valued</a> <a id="5173" href="Iterative.Sets.html#5173" class="Bound">A</a> <a id="5175" href="Iterative.Sets.html#5175" class="Bound">B</a> <a id="5177" class="Symbol">=</a> <a id="5179" href="UF.Subsingletons-FunExt.html#4856" class="Function">Π₂-is-prop</a> <a id="5190" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="5193" class="Symbol">(λ</a> <a id="5196" href="Iterative.Sets.html#5196" class="Bound">C</a> <a id="5198" href="Iterative.Sets.html#5198" class="Bound">_</a> <a id="5200" class="Symbol">→</a> <a id="5202" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="5219" href="Iterative.Sets.html#5196" class="Bound">C</a> <a id="5221" href="Iterative.Sets.html#5175" class="Bound">B</a><a id="5222" class="Symbol">)</a>

<a id="5225" class="Markup">\end{code}</a><a id="5235" class="Background">

It is in the following that the univalence axiom is used for the first
time, to establish the extensionality axiom for iterative sets:

</a><a id="5373" class="Markup">\begin{code}</a>

<a id="∈-is-extensional"></a><a id="5387" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="5404" class="Symbol">:</a> <a id="5406" class="Symbol">(</a><a id="5407" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5409" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5411" class="Symbol">:</a> <a id="5413" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="5414" class="Symbol">)</a> <a id="5416" class="Symbol">→</a> <a id="5418" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5420" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5422" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5424" class="Symbol">→</a> <a id="5426" href="Iterative.Sets.html#5409" class="Bound">B</a> <a id="5428" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5430" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Iterative.Sets.html#5407" class="Bound">A</a> <a id="5436" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5438" href="Iterative.Sets.html#5409" class="Bound">B</a>
<a id="5440" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="5457" href="Iterative.Sets.html#5457" class="Bound">A</a><a id="5458" class="Symbol">@(</a><a id="5460" href="Iterative.Sets.html#5460" class="Bound">M</a><a id="5461" class="Symbol">@(</a><a id="5463" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="5468" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5470" href="Iterative.Sets.html#5470" class="Bound">φ</a><a id="5471" class="Symbol">)</a> <a id="5473" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5475" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a> <a id="5481" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5483" href="Iterative.Sets.html#5483" class="Bound">g</a><a id="5484" class="Symbol">)</a>
                 <a id="5503" href="Iterative.Sets.html#5503" class="Bound">B</a><a id="5504" class="Symbol">@(</a><a id="5506" href="Iterative.Sets.html#5506" class="Bound">N</a><a id="5507" class="Symbol">@(</a><a id="5509" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="5514" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5516" href="Iterative.Sets.html#5516" class="Bound">γ</a><a id="5517" class="Symbol">)</a> <a id="5519" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5521" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a> <a id="5527" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5529" href="Iterative.Sets.html#5529" class="Bound">h</a><a id="5530" class="Symbol">)</a> <a id="5532" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5534" href="Iterative.Sets.html#5534" class="Bound">v</a> <a id="5536" class="Symbol">=</a> <a id="5538" href="Iterative.Sets.html#6410" class="Function">V</a>
 <a id="5541" class="Keyword">where</a>
  <a id="5549" href="Iterative.Sets.html#5549" class="Function">have-uv</a> <a id="5557" class="Symbol">:</a> <a id="5559" class="Symbol">(</a><a id="5560" href="Iterative.Sets.html#5457" class="Bound">A</a> <a id="5562" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5564" href="Iterative.Sets.html#5503" class="Bound">B</a><a id="5565" class="Symbol">)</a> <a id="5567" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="5569" class="Symbol">(</a><a id="5570" href="Iterative.Sets.html#5503" class="Bound">B</a> <a id="5572" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="5574" href="Iterative.Sets.html#5457" class="Bound">A</a><a id="5575" class="Symbol">)</a>
  <a id="5579" href="Iterative.Sets.html#5549" class="Function">have-uv</a> <a id="5587" class="Symbol">=</a> <a id="5589" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5591" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5593" href="Iterative.Sets.html#5534" class="Bound">v</a>

  <a id="5598" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5600" class="Symbol">:</a> <a id="5602" class="Symbol">(</a><a id="5603" href="Iterative.Sets.html#5603" class="Bound">x</a> <a id="5605" class="Symbol">:</a> <a id="5607" href="Iterative.Sets.html#5468" class="Bound">X</a><a id="5608" class="Symbol">)</a> <a id="5610" class="Symbol">→</a> <a id="5612" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="5614" href="Iterative.Sets.html#5614" class="Bound">y</a> <a id="5616" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="5618" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5620" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="5622" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5624" href="Iterative.Sets.html#5614" class="Bound">y</a> <a id="5626" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5628" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5630" href="Iterative.Sets.html#5603" class="Bound">x</a>
  <a id="5634" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5636" href="Iterative.Sets.html#5636" class="Bound">x</a> <a id="5638" class="Symbol">=</a> <a id="5640" href="Iterative.Sets.html#5532" class="Bound">u</a> <a id="5642" class="Symbol">(</a><a id="5643" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5645" href="Iterative.Sets.html#5636" class="Bound">x</a> <a id="5647" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5649" href="Iterative.Sets.html#5483" class="Bound">g</a> <a id="5651" href="Iterative.Sets.html#5636" class="Bound">x</a><a id="5652" class="Symbol">)</a> <a id="5654" class="Symbol">(</a><a id="5655" href="Iterative.Multisets.html#2924" class="Function">𝕄-forest-⁅</a> <a id="5666" href="Iterative.Sets.html#5460" class="Bound">M</a> <a id="5668" href="Iterative.Sets.html#5636" class="Bound">x</a><a id="5669" class="Symbol">)</a>

  <a id="5674" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5677" class="Symbol">:</a> <a id="5679" class="Symbol">(</a><a id="5680" href="Iterative.Sets.html#5680" class="Bound">y</a> <a id="5682" class="Symbol">:</a> <a id="5684" href="Iterative.Sets.html#5514" class="Bound">Y</a><a id="5685" class="Symbol">)</a> <a id="5687" class="Symbol">→</a> <a id="5689" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="5691" href="Iterative.Sets.html#5691" class="Bound">x</a> <a id="5693" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="5695" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5697" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="5699" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5701" href="Iterative.Sets.html#5691" class="Bound">x</a> <a id="5703" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="5705" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5707" href="Iterative.Sets.html#5680" class="Bound">y</a>
  <a id="5711" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5714" href="Iterative.Sets.html#5714" class="Bound">y</a> <a id="5716" class="Symbol">=</a> <a id="5718" href="Iterative.Sets.html#5534" class="Bound">v</a> <a id="5720" class="Symbol">(</a><a id="5721" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5723" href="Iterative.Sets.html#5714" class="Bound">y</a> <a id="5725" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="5727" href="Iterative.Sets.html#5529" class="Bound">h</a> <a id="5729" href="Iterative.Sets.html#5714" class="Bound">y</a><a id="5730" class="Symbol">)</a> <a id="5732" class="Symbol">(</a><a id="5733" href="Iterative.Multisets.html#2924" class="Function">𝕄-forest-⁅</a> <a id="5744" href="Iterative.Sets.html#5506" class="Bound">N</a> <a id="5746" href="Iterative.Sets.html#5714" class="Bound">y</a><a id="5747" class="Symbol">)</a>

  <a id="5752" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5754" class="Symbol">:</a> <a id="5756" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="5758" class="Symbol">→</a> <a id="5760" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="5764" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5766" href="Iterative.Sets.html#5766" class="Bound">x</a> <a id="5768" class="Symbol">=</a> <a id="5770" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5774" class="Symbol">(</a><a id="5775" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5777" href="Iterative.Sets.html#5766" class="Bound">x</a><a id="5778" class="Symbol">)</a>

  <a id="5783" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5787" class="Symbol">:</a> <a id="5789" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="5791" class="Symbol">→</a> <a id="5793" href="Iterative.Sets.html#5468" class="Bound">X</a>
  <a id="5797" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5801" href="Iterative.Sets.html#5801" class="Bound">y</a> <a id="5803" class="Symbol">=</a> <a id="5805" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="5809" class="Symbol">(</a><a id="5810" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5813" href="Iterative.Sets.html#5801" class="Bound">y</a><a id="5814" class="Symbol">)</a>

  <a id="5819" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="5821" class="Symbol">:</a> <a id="5823" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5827" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5829" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5831" href="MLTT.Id.html#1891" class="Function Operator">∼</a> <a id="5833" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="5838" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="5840" href="Iterative.Sets.html#5840" class="Bound">x</a> <a id="5842" class="Symbol">=</a> <a id="5844" href="UF.Embeddings.html#5107" class="Function">embeddings-are-lc</a> <a id="5862" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5864" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a>
         <a id="5879" class="Symbol">(</a><a id="5880" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5882" class="Symbol">(</a><a id="5883" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5887" class="Symbol">(</a><a id="5888" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5890" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5891" class="Symbol">))</a> <a id="5894" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="5897" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="5901" class="Symbol">(</a><a id="5902" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="5905" class="Symbol">(</a><a id="5906" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5908" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5909" class="Symbol">))</a> <a id="5912" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
          <a id="5924" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="5926" class="Symbol">(</a><a id="5927" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5929" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5930" class="Symbol">)</a>       <a id="5938" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="5941" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="5945" class="Symbol">(</a><a id="5946" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="5948" href="Iterative.Sets.html#5840" class="Bound">x</a><a id="5949" class="Symbol">)</a> <a id="5951" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
          <a id="5963" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="5965" href="Iterative.Sets.html#5840" class="Bound">x</a>           <a id="5977" href="MLTT.Id.html#2787" class="Function Operator">∎</a><a id="5978" class="Symbol">)</a>

  <a id="5983" href="Iterative.Sets.html#5983" class="Function">ε</a> <a id="5985" class="Symbol">:</a> <a id="5987" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="5989" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="5991" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="5995" href="MLTT.Id.html#1891" class="Function Operator">∼</a> <a id="5997" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="6002" href="Iterative.Sets.html#5983" class="Function">ε</a> <a id="6004" href="Iterative.Sets.html#6004" class="Bound">y</a> <a id="6006" class="Symbol">=</a> <a id="6008" href="UF.Embeddings.html#5107" class="Function">embeddings-are-lc</a> <a id="6026" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6028" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a>
         <a id="6043" class="Symbol">(</a><a id="6044" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6046" class="Symbol">(</a><a id="6047" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6049" class="Symbol">(</a><a id="6050" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6054" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6055" class="Symbol">))</a> <a id="6058" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="6061" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6065" class="Symbol">(</a><a id="6066" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="6068" class="Symbol">(</a><a id="6069" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6073" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6074" class="Symbol">))</a> <a id="6077" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
          <a id="6089" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="6091" class="Symbol">(</a><a id="6092" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6096" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6097" class="Symbol">)</a>     <a id="6103" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="6106" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6110" class="Symbol">(</a><a id="6111" href="Iterative.Sets.html#5674" class="Function">II</a> <a id="6114" href="Iterative.Sets.html#6004" class="Bound">y</a><a id="6115" class="Symbol">)</a> <a id="6117" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
          <a id="6129" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6131" href="Iterative.Sets.html#6004" class="Bound">y</a>           <a id="6143" href="MLTT.Id.html#2787" class="Function Operator">∎</a><a id="6144" class="Symbol">)</a>

  <a id="6149" href="Iterative.Sets.html#6149" class="Function">𝕗</a> <a id="6151" class="Symbol">:</a> <a id="6153" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6155" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="6157" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="6161" href="Iterative.Sets.html#6149" class="Function">𝕗</a> <a id="6163" class="Symbol">=</a> <a id="6165" href="UF.Equiv.html#7224" class="Function">qinveq</a> <a id="6172" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6174" class="Symbol">(</a><a id="6175" href="Iterative.Sets.html#5783" class="Function">f⁻¹</a> <a id="6179" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6181" href="Iterative.Sets.html#5819" class="Function">η</a> <a id="6183" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6185" href="Iterative.Sets.html#5983" class="Function">ε</a><a id="6186" class="Symbol">)</a>

  <a id="6191" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6193" class="Symbol">:</a> <a id="6195" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6197" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6199" href="Iterative.Sets.html#5514" class="Bound">Y</a>
  <a id="6203" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6205" class="Symbol">=</a> <a id="6207" href="UF.Univalence.html#905" class="Function">eqtoid</a> <a id="6214" class="Symbol">(</a><a id="6215" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="6218" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="6219" class="Symbol">)</a> <a id="6221" href="Iterative.Sets.html#5468" class="Bound">X</a> <a id="6223" href="Iterative.Sets.html#5514" class="Bound">Y</a> <a id="6225" href="Iterative.Sets.html#6149" class="Function">𝕗</a>

  <a id="6230" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6234" class="Symbol">:</a> <a id="6236" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="6244" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6246" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6248" href="Iterative.Sets.html#5752" class="Function">f</a>
  <a id="6252" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6256" class="Symbol">=</a> <a id="6258" href="UF.Univalence.html#1668" class="Function">Idtofun-eqtoid</a> <a id="6273" class="Symbol">(</a><a id="6274" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="6277" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="6278" class="Symbol">)</a> <a id="6280" href="Iterative.Sets.html#6149" class="Function">𝕗</a>

  <a id="6285" href="Iterative.Sets.html#6285" class="Function">IV</a> <a id="6288" class="Symbol">=</a> <a id="6290" class="Symbol">λ</a> <a id="6292" href="Iterative.Sets.html#6292" class="Bound">x</a> <a id="6294" class="Symbol">→</a>
   <a id="6299" href="Iterative.Sets.html#5470" class="Bound">φ</a> <a id="6301" href="Iterative.Sets.html#6292" class="Bound">x</a>             <a id="6315" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="6318" class="Symbol">(</a><a id="6319" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="6323" class="Symbol">(</a><a id="6324" href="Iterative.Sets.html#5598" class="Function">I</a> <a id="6326" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6327" class="Symbol">))</a><a id="6329" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a> <a id="6332" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="6337" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6339" class="Symbol">(</a><a id="6340" href="Iterative.Sets.html#5752" class="Function">f</a> <a id="6342" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6343" class="Symbol">)</a>         <a id="6353" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="6356" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="6359" class="Symbol">(λ</a> <a id="6362" href="Iterative.Sets.html#6362" class="Bound">-</a> <a id="6364" class="Symbol">→</a> <a id="6366" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6368" class="Symbol">(</a><a id="6369" href="Iterative.Sets.html#6362" class="Bound">-</a> <a id="6371" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6372" class="Symbol">))</a> <a id="6375" class="Symbol">(</a><a id="6376" href="Iterative.Sets.html#6230" class="Function">III</a> <a id="6380" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="6382" class="Symbol">)</a> <a id="6384" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="6389" href="Iterative.Sets.html#5516" class="Bound">γ</a> <a id="6391" class="Symbol">(</a><a id="6392" href="UF.Base.html#2303" class="Function">Idtofun</a> <a id="6400" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6402" href="Iterative.Sets.html#6292" class="Bound">x</a><a id="6403" class="Symbol">)</a> <a id="6405" href="MLTT.Id.html#2787" class="Function Operator">∎</a>

  <a id="6410" href="Iterative.Sets.html#6410" class="Function">V</a> <a id="6412" class="Symbol">:</a> <a id="6414" href="Iterative.Sets.html#5457" class="Bound">A</a> <a id="6416" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="6418" href="Iterative.Sets.html#5503" class="Bound">B</a>
  <a id="6422" href="Iterative.Sets.html#6410" class="Function">V</a> <a id="6424" class="Symbol">=</a> <a id="6426" href="Iterative.Sets.html#3791" class="Function">to-𝕍-＝</a> <a id="6433" class="Symbol">(</a><a id="6434" href="Iterative.Sets.html#6191" class="Function">p</a> <a id="6436" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6438" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="6446" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="6449" href="Iterative.Sets.html#6285" class="Function">IV</a><a id="6451" class="Symbol">)</a> <a id="6453" class="Symbol">(</a><a id="6454" href="Iterative.Sets.html#5475" class="Bound">φ-emb</a> <a id="6460" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6462" href="Iterative.Sets.html#5483" class="Bound">g</a><a id="6463" class="Symbol">)</a> <a id="6465" class="Symbol">(</a><a id="6466" href="Iterative.Sets.html#5521" class="Bound">γ-emb</a> <a id="6472" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="6474" href="Iterative.Sets.html#5529" class="Bound">h</a><a id="6475" class="Symbol">)</a>

<a id="6478" class="Markup">\end{code}</a><a id="6488" class="Background">

It follows that 𝕍 is 0-type, or set, in the sense of the HoTT
book. But notice that we now have two notions of set in this
discussion: the &quot;material&quot; (iterative set) one and the &quot;structural&quot;
one (0-type or set). The reader should keep this distinction in mind
for the comments and code below.

The following uses the fact that any type with an extensional order is
automatically a set.

</a><a id="6877" class="Markup">\begin{code}</a>

<a id="𝕍-is-set"></a><a id="6891" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="6900" class="Symbol">:</a> <a id="6902" href="UF.Sets.html#709" class="Function">is-set</a> <a id="6909" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="6911" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="6920" class="Symbol">=</a> <a id="6922" href="Ordinals.Notions.html#7855" class="Function">extensionally-ordered-types-are-sets</a> <a id="6959" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="6963" href="Iterative.Sets.html#944" class="Function">fe&#39;</a>
            <a id="6979" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a>
            <a id="7008" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a>

<a id="7026" class="Markup">\end{code}</a><a id="7036" class="Background">

Here is a second, more direct, proof of this fact.

The following says that ssup φ ＝ M is a proposition for every M : 𝕄
if φ is an embedding.

The following doesn&#39;t seem to have been observed before in the
literature.

</a><a id="7257" class="Markup">\begin{code}</a>

<a id="𝕄-ssup-is-h-isolated"></a><a id="7271" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="7292" class="Symbol">:</a> <a id="7294" class="Symbol">(</a><a id="7295" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7297" class="Symbol">:</a> <a id="7299" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="7301" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="7303" class="Symbol">)</a> <a id="7305" class="Symbol">(</a><a id="7306" href="Iterative.Sets.html#7306" class="Bound">φ</a> <a id="7308" class="Symbol">:</a> <a id="7310" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7312" class="Symbol">→</a> <a id="7314" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="7315" class="Symbol">)</a>
                     <a id="7338" class="Symbol">→</a> <a id="7340" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="7353" href="Iterative.Sets.html#7306" class="Bound">φ</a>
                     <a id="7376" class="Symbol">→</a> <a id="7378" href="UF.Sets.html#402" class="Function">is-h-isolated</a> <a id="7392" class="Symbol">(</a><a id="7393" class="InductiveConstructor">ssup</a> <a id="7398" href="Iterative.Sets.html#7295" class="Bound">X</a> <a id="7400" href="Iterative.Sets.html#7306" class="Bound">φ</a><a id="7401" class="Symbol">)</a>
<a id="7403" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="7424" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7426" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7428" href="Iterative.Sets.html#7428" class="Bound">φ-emb</a> <a id="7434" class="Symbol">{</a><a id="7435" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7436" class="Symbol">}</a> <a id="7438" class="Symbol">=</a> <a id="7440" href="Iterative.Sets.html#7771" class="Function">III</a>
 <a id="7445" class="Keyword">where</a>
  <a id="7453" href="Iterative.Sets.html#7453" class="Function">I</a> <a id="7455" class="Symbol">=</a> <a id="7457" class="Symbol">(</a><a id="7458" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7463" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7465" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7467" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7469" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7470" class="Symbol">)</a>                        <a id="7495" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="7498" href="UF.EquivalenceExamples.html#25145" class="Function">＝-flip</a> <a id="7505" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="7513" class="Symbol">(</a><a id="7514" href="Iterative.Sets.html#7435" class="Bound">M</a> <a id="7516" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7518" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7523" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7525" href="Iterative.Sets.html#7426" class="Bound">φ</a><a id="7526" class="Symbol">)</a>                        <a id="7551" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="7554" href="Iterative.Multisets.html#4447" class="Function">𝕄-＝&#39;</a> <a id="7559" href="Iterative.Sets.html#7435" class="Bound">M</a> <a id="7561" class="Symbol">(</a><a id="7562" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7567" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7569" href="Iterative.Sets.html#7426" class="Bound">φ</a><a id="7570" class="Symbol">)</a> <a id="7572" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
      <a id="7580" href="Notation.General.html#398" class="Function">fiber</a> <a id="7586" class="Symbol">((</a><a id="7588" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7590" href="MLTT.Pi.html#513" class="Function Operator">∘_</a><a id="7592" class="Symbol">)</a> <a id="7594" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7596" href="UF.Base.html#2303" class="Function">Idtofun</a><a id="7603" class="Symbol">)</a> <a id="7605" class="Symbol">(</a><a id="7606" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="7615" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7616" class="Symbol">)</a>  <a id="7619" href="UF.Equiv.html#2815" class="Function Operator">■</a>

  <a id="7624" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7627" class="Symbol">:</a> <a id="7629" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="7642" class="Symbol">((</a><a id="7644" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7646" href="MLTT.Pi.html#513" class="Function Operator">∘_</a><a id="7648" class="Symbol">)</a> <a id="7650" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="7652" href="UF.Base.html#2303" class="Function">Idtofun</a><a id="7659" class="Symbol">)</a>
  <a id="7663" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7666" class="Symbol">=</a> <a id="7668" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a>
        <a id="7691" class="Symbol">(</a><a id="7692" href="UF.Embeddings.html#19912" class="Function">Idtofun-is-embedding</a> <a id="7713" class="Symbol">(</a><a id="7714" href="Iterative.Sets.html#758" class="Bound">ua</a> <a id="7717" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="7718" class="Symbol">)</a> <a id="7720" href="Iterative.Sets.html#895" class="Function">fe</a><a id="7722" class="Symbol">)</a>
        <a id="7732" class="Symbol">(</a><a id="7733" href="UF.Embeddings.html#12977" class="Function">postcomp-is-embedding</a> <a id="7755" href="Iterative.Sets.html#944" class="Function">fe&#39;</a> <a id="7759" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7761" href="Iterative.Sets.html#7428" class="Bound">φ-emb</a><a id="7766" class="Symbol">)</a>

  <a id="7771" href="Iterative.Sets.html#7771" class="Function">III</a> <a id="7775" class="Symbol">:</a> <a id="7777" href="UF.Subsingletons.html#469" class="Function">is-prop</a> <a id="7785" class="Symbol">(</a><a id="7786" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="7791" href="Iterative.Sets.html#7424" class="Bound">X</a> <a id="7793" href="Iterative.Sets.html#7426" class="Bound">φ</a> <a id="7795" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="7797" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7798" class="Symbol">)</a>
  <a id="7802" href="Iterative.Sets.html#7771" class="Function">III</a> <a id="7806" class="Symbol">=</a> <a id="7808" href="UF.Equiv.html#8620" class="Function">equiv-to-prop</a> <a id="7822" href="Iterative.Sets.html#7453" class="Function">I</a> <a id="7824" class="Symbol">(</a><a id="7825" href="Iterative.Sets.html#7624" class="Function">II</a> <a id="7828" class="Symbol">(</a><a id="7829" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="7838" href="Iterative.Sets.html#7435" class="Bound">M</a><a id="7839" class="Symbol">))</a>

<a id="7843" class="Markup">\end{code}</a><a id="7853" class="Background">

And a particular case of this is that if M is an iterative set then
M ＝ N is a proposition for every *multiset* N.

</a><a id="7971" class="Markup">\begin{code}</a>

<a id="isets-are-h-isolated"></a><a id="7985" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8006" class="Symbol">:</a> <a id="8008" class="Symbol">(</a><a id="8009" href="Iterative.Sets.html#8009" class="Bound">M</a> <a id="8011" class="Symbol">:</a> <a id="8013" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="8014" class="Symbol">)</a>
                     <a id="8037" class="Symbol">→</a> <a id="8039" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="8056" href="Iterative.Sets.html#8009" class="Bound">M</a>
                     <a id="8079" class="Symbol">→</a> <a id="8081" href="UF.Sets.html#402" class="Function">is-h-isolated</a> <a id="8095" href="Iterative.Sets.html#8009" class="Bound">M</a>
<a id="8097" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8118" class="Symbol">(</a><a id="8119" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="8124" href="Iterative.Sets.html#8124" class="Bound">X</a> <a id="8126" href="Iterative.Sets.html#8126" class="Bound">φ</a><a id="8127" class="Symbol">)</a> <a id="8129" class="Symbol">(</a><a id="8130" href="Iterative.Sets.html#8130" class="Bound">φ-emb</a> <a id="8136" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8138" class="Symbol">_)</a> <a id="8141" class="Symbol">=</a> <a id="8143" href="Iterative.Sets.html#7271" class="Function">𝕄-ssup-is-h-isolated</a> <a id="8164" href="Iterative.Sets.html#8124" class="Bound">X</a> <a id="8166" href="Iterative.Sets.html#8126" class="Bound">φ</a> <a id="8168" href="Iterative.Sets.html#8130" class="Bound">φ-emb</a>

<a id="8175" class="Markup">\end{code}</a><a id="8185" class="Background">

Because a subtype of any type whatsoever consisting of h-isolated
elements is a 0-type, we get a second proof that the type of iterative
sets is a 0-type.

</a><a id="8343" class="Markup">\begin{code}</a>

<a id="𝕍-is-set&#39;"></a><a id="8357" href="Iterative.Sets.html#8357" class="Function">𝕍-is-set&#39;</a> <a id="8367" class="Symbol">:</a> <a id="8369" href="UF.Sets.html#709" class="Function">is-set</a> <a id="8376" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="8378" href="Iterative.Sets.html#8357" class="Function">𝕍-is-set&#39;</a> <a id="8388" class="Symbol">{</a><a id="8389" href="Iterative.Sets.html#8389" class="Bound">M</a> <a id="8391" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8393" href="Iterative.Sets.html#8393" class="Bound">M-is-is-set</a><a id="8404" class="Symbol">}</a> <a id="8406" class="Symbol">=</a>
 <a id="8409" href="UF.Equiv.html#8620" class="Function">equiv-to-prop</a>
  <a id="8425" class="Symbol">(</a><a id="8426" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="8432" class="Symbol">(</a><a id="8433" href="UF.Embeddings.html#8920" class="Function">to-subtype-＝-≃</a> <a id="8448" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a><a id="8466" class="Symbol">))</a>
  <a id="8471" class="Symbol">(</a><a id="8472" href="Iterative.Sets.html#7985" class="Function">isets-are-h-isolated</a> <a id="8493" href="Iterative.Sets.html#8389" class="Bound">M</a> <a id="8495" href="Iterative.Sets.html#8393" class="Bound">M-is-is-set</a><a id="8506" class="Symbol">)</a>

<a id="8509" class="Markup">\end{code}</a><a id="8519" class="Background">

By definition, an iterative multiset is an iterative set if its
𝕄-forests are all embeddings. The 𝕍-forests are also embeddings:

</a><a id="8651" class="Markup">\begin{code}</a>

<a id="𝕍-forest-is-embedding"></a><a id="8665" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="8687" class="Symbol">:</a> <a id="8689" class="Symbol">(</a><a id="8690" href="Iterative.Sets.html#8690" class="Bound">A</a> <a id="8692" class="Symbol">:</a> <a id="8694" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="8695" class="Symbol">)</a> <a id="8697" class="Symbol">→</a> <a id="8699" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="8712" class="Symbol">(</a><a id="8713" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="8722" href="Iterative.Sets.html#8690" class="Bound">A</a><a id="8723" class="Symbol">)</a>
<a id="8725" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="8747" href="Iterative.Sets.html#8747" class="Bound">A</a><a id="8748" class="Symbol">@(</a><a id="8750" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="8755" href="Iterative.Sets.html#8755" class="Bound">X</a> <a id="8757" href="Iterative.Sets.html#8757" class="Bound">φ</a> <a id="8759" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8761" href="Iterative.Sets.html#8761" class="Bound">φ-emb</a> <a id="8767" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="8769" href="Iterative.Sets.html#8769" class="Bound">φ-iter</a><a id="8775" class="Symbol">)</a> <a id="8777" class="Symbol">=</a>
 <a id="8780" href="UF.PairFun.html#5312" class="Function">pair-fun-is-embedding-special</a> <a id="8810" href="Iterative.Sets.html#8757" class="Bound">φ</a> <a id="8812" href="Iterative.Sets.html#8769" class="Bound">φ-iter</a> <a id="8819" href="Iterative.Sets.html#8761" class="Bound">φ-emb</a> <a id="8825" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a>

<a id="8845" class="Markup">\end{code}</a><a id="8855" class="Background">

We construct elements of 𝕄 using the constructor ssup. We now
introduce a corresponding constructor 𝕍-ssup to construct elements of
the type 𝕍.

</a><a id="9002" class="Markup">\begin{code}</a>

<a id="𝕍-ssup"></a><a id="9016" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9023" class="Symbol">:</a> <a id="9025" class="Symbol">(</a><a id="9026" href="Iterative.Sets.html#9026" class="Bound">X</a> <a id="9028" class="Symbol">:</a> <a id="9030" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9032" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="9034" class="Symbol">)</a> <a id="9036" class="Symbol">(</a><a id="9037" href="Iterative.Sets.html#9037" class="Bound">ϕ</a> <a id="9039" class="Symbol">:</a> <a id="9041" href="Iterative.Sets.html#9026" class="Bound">X</a> <a id="9043" class="Symbol">→</a> <a id="9045" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9046" class="Symbol">)</a> <a id="9048" class="Symbol">→</a> <a id="9050" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9063" href="Iterative.Sets.html#9037" class="Bound">ϕ</a> <a id="9065" class="Symbol">→</a> <a id="9067" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="9069" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9076" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9078" href="Iterative.Sets.html#9078" class="Bound">ϕ</a> <a id="9080" href="Iterative.Sets.html#9080" class="Bound">ϕ-emb</a> <a id="9086" class="Symbol">=</a> <a id="9088" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="9093" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9095" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9097" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9099" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9105" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="9107" href="Iterative.Sets.html#9162" class="Function">φ-iset</a>
 <a id="9115" class="Keyword">where</a>
  <a id="9123" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9125" class="Symbol">:</a> <a id="9127" href="Iterative.Sets.html#9076" class="Bound">X</a> <a id="9129" class="Symbol">→</a> <a id="9131" href="Iterative.Multisets.html#691" class="Function">𝕄</a>
  <a id="9135" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9137" class="Symbol">=</a> <a id="9139" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="9155" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9157" href="Iterative.Sets.html#9078" class="Bound">ϕ</a>

  <a id="9162" href="Iterative.Sets.html#9162" class="Function">φ-iset</a> <a id="9169" class="Symbol">:</a> <a id="9171" class="Symbol">(</a><a id="9172" href="Iterative.Sets.html#9172" class="Bound">x</a> <a id="9174" class="Symbol">:</a> <a id="9176" href="Iterative.Sets.html#9076" class="Bound">X</a><a id="9177" class="Symbol">)</a> <a id="9179" class="Symbol">→</a> <a id="9181" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="9198" class="Symbol">(</a><a id="9199" href="Iterative.Sets.html#9123" class="Function">φ</a> <a id="9201" href="Iterative.Sets.html#9172" class="Bound">x</a><a id="9202" class="Symbol">)</a>
  <a id="9206" href="Iterative.Sets.html#9162" class="Function">φ-iset</a> <a id="9213" class="Symbol">=</a> <a id="9215" href="Iterative.Sets.html#2939" class="Function">isets-are-iterative</a> <a id="9235" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="9237" href="Iterative.Sets.html#9078" class="Bound">ϕ</a>

  <a id="9242" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9248" class="Symbol">:</a> <a id="9250" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9263" href="Iterative.Sets.html#9123" class="Function">φ</a>
  <a id="9267" href="Iterative.Sets.html#9242" class="Function">φ-emb</a> <a id="9273" class="Symbol">=</a> <a id="9275" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a> <a id="9290" href="Iterative.Sets.html#9080" class="Bound">ϕ-emb</a> <a id="9296" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a>

<a id="9326" class="Markup">\end{code}</a><a id="9336" class="Background">

It behaves as expected with respect to the corresponding destructors:

</a><a id="9409" class="Markup">\begin{code}</a>

<a id="𝕍-ssup-root"></a><a id="9423" href="Iterative.Sets.html#9423" class="Function">𝕍-ssup-root</a> <a id="9435" class="Symbol">:</a> <a id="9437" class="Symbol">(</a><a id="9438" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9440" class="Symbol">:</a> <a id="9442" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9444" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="9446" class="Symbol">)</a> <a id="9448" class="Symbol">(</a><a id="9449" href="Iterative.Sets.html#9449" class="Bound">ϕ</a> <a id="9451" class="Symbol">:</a> <a id="9453" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9455" class="Symbol">→</a> <a id="9457" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9458" class="Symbol">)</a> <a id="9460" class="Symbol">(</a><a id="9461" href="Iterative.Sets.html#9461" class="Bound">e</a> <a id="9463" class="Symbol">:</a> <a id="9465" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9478" href="Iterative.Sets.html#9449" class="Bound">ϕ</a><a id="9479" class="Symbol">)</a>
            <a id="9493" class="Symbol">→</a> <a id="9495" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="9502" class="Symbol">(</a><a id="9503" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9510" href="Iterative.Sets.html#9438" class="Bound">X</a> <a id="9512" href="Iterative.Sets.html#9449" class="Bound">ϕ</a> <a id="9514" href="Iterative.Sets.html#9461" class="Bound">e</a><a id="9515" class="Symbol">)</a> <a id="9517" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="9519" href="Iterative.Sets.html#9438" class="Bound">X</a>
<a id="9521" href="Iterative.Sets.html#9423" class="Function">𝕍-ssup-root</a> <a id="9533" href="Iterative.Sets.html#9533" class="Bound">X</a> <a id="9535" href="Iterative.Sets.html#9535" class="Bound">ϕ</a> <a id="9537" href="Iterative.Sets.html#9537" class="Bound">e</a> <a id="9539" class="Symbol">=</a> <a id="9541" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-ssup-forest"></a><a id="9547" href="Iterative.Sets.html#9547" class="Function">𝕍-ssup-forest</a> <a id="9561" class="Symbol">:</a> <a id="9563" class="Symbol">(</a><a id="9564" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9566" class="Symbol">:</a> <a id="9568" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="9570" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="9572" class="Symbol">)</a> <a id="9574" class="Symbol">(</a><a id="9575" href="Iterative.Sets.html#9575" class="Bound">ϕ</a> <a id="9577" class="Symbol">:</a> <a id="9579" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9581" class="Symbol">→</a> <a id="9583" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9584" class="Symbol">)</a> <a id="9586" class="Symbol">(</a><a id="9587" href="Iterative.Sets.html#9587" class="Bound">e</a> <a id="9589" class="Symbol">:</a> <a id="9591" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9604" href="Iterative.Sets.html#9575" class="Bound">ϕ</a><a id="9605" class="Symbol">)</a>
              <a id="9621" class="Symbol">→</a> <a id="9623" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9632" class="Symbol">(</a><a id="9633" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9640" href="Iterative.Sets.html#9564" class="Bound">X</a> <a id="9642" href="Iterative.Sets.html#9575" class="Bound">ϕ</a> <a id="9644" href="Iterative.Sets.html#9587" class="Bound">e</a><a id="9645" class="Symbol">)</a> <a id="9647" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="9649" href="Iterative.Sets.html#9575" class="Bound">ϕ</a>
<a id="9651" href="Iterative.Sets.html#9547" class="Function">𝕍-ssup-forest</a> <a id="9665" href="Iterative.Sets.html#9665" class="Bound">X</a> <a id="9667" href="Iterative.Sets.html#9667" class="Bound">ϕ</a> <a id="9669" href="Iterative.Sets.html#9669" class="Bound">e</a> <a id="9671" class="Symbol">=</a> <a id="9673" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="9679" class="Markup">\end{code}</a><a id="9689" class="Background">

Notice that the identifications are definitional.

We have the following η rules for 𝕍, where the first is more general
and the second is more natural. In both cases the identifications are
not definitional.

</a><a id="9900" class="Markup">\begin{code}</a>

<a id="𝕍-η&#39;"></a><a id="9914" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="9919" class="Symbol">:</a> <a id="9921" class="Symbol">(</a><a id="9922" href="Iterative.Sets.html#9922" class="Bound">A</a> <a id="9924" class="Symbol">:</a> <a id="9926" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="9927" class="Symbol">)</a> <a id="9929" class="Symbol">(</a><a id="9930" href="Iterative.Sets.html#9930" class="Bound">e</a> <a id="9932" class="Symbol">:</a> <a id="9934" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="9947" class="Symbol">(</a><a id="9948" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9957" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9958" class="Symbol">))</a>
     <a id="9966" class="Symbol">→</a> <a id="9968" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="9975" class="Symbol">(</a><a id="9976" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="9983" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9984" class="Symbol">)</a> <a id="9986" class="Symbol">(</a><a id="9987" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="9996" href="Iterative.Sets.html#9922" class="Bound">A</a><a id="9997" class="Symbol">)</a> <a id="9999" href="Iterative.Sets.html#9930" class="Bound">e</a> <a id="10001" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10003" href="Iterative.Sets.html#9922" class="Bound">A</a>
<a id="10005" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="10010" class="Symbol">(</a><a id="10011" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="10016" class="Symbol">_</a> <a id="10018" class="Symbol">_</a> <a id="10020" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="10022" class="Symbol">_)</a> <a id="10025" class="Symbol">_</a> <a id="10027" class="Symbol">=</a> <a id="10029" href="UF.Subsingletons.html#4964" class="Function">to-subtype-＝</a> <a id="10042" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="10061" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-η"></a><a id="10067" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10071" class="Symbol">:</a> <a id="10073" class="Symbol">(</a><a id="10074" href="Iterative.Sets.html#10074" class="Bound">A</a> <a id="10076" class="Symbol">:</a> <a id="10078" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10079" class="Symbol">)</a> <a id="10081" class="Symbol">→</a> <a id="10083" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10090" class="Symbol">(</a><a id="10091" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10098" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10099" class="Symbol">)</a> <a id="10101" class="Symbol">(</a><a id="10102" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10111" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10112" class="Symbol">)</a> <a id="10114" class="Symbol">(</a><a id="10115" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="10137" href="Iterative.Sets.html#10074" class="Bound">A</a><a id="10138" class="Symbol">)</a> <a id="10140" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10142" href="Iterative.Sets.html#10074" class="Bound">A</a>
<a id="10144" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10148" href="Iterative.Sets.html#10148" class="Bound">A</a> <a id="10150" class="Symbol">=</a> <a id="10152" href="Iterative.Sets.html#9914" class="Function">𝕍-η&#39;</a> <a id="10157" href="Iterative.Sets.html#10148" class="Bound">A</a> <a id="10159" class="Symbol">(</a><a id="10160" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="10182" href="Iterative.Sets.html#10148" class="Bound">A</a><a id="10183" class="Symbol">)</a>

<a id="10186" class="Markup">\end{code}</a><a id="10196" class="Background">

Here are two characterizations of the membership relation:

</a><a id="10258" class="Markup">\begin{code}</a>

<a id="∈-behaviour"></a><a id="10272" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="10284" class="Symbol">:</a> <a id="10286" class="Symbol">(</a><a id="10287" href="Iterative.Sets.html#10287" class="Bound">A</a> <a id="10289" class="Symbol">:</a> <a id="10291" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10292" class="Symbol">)</a> <a id="10294" class="Symbol">(</a><a id="10295" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10297" class="Symbol">:</a> <a id="10299" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="10301" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="10303" class="Symbol">)</a> <a id="10305" class="Symbol">(</a><a id="10306" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10308" class="Symbol">:</a> <a id="10310" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10312" class="Symbol">→</a> <a id="10314" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10315" class="Symbol">)</a> <a id="10317" class="Symbol">(</a><a id="10318" href="Iterative.Sets.html#10318" class="Bound">e</a> <a id="10320" class="Symbol">:</a> <a id="10322" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="10335" href="Iterative.Sets.html#10306" class="Bound">ϕ</a><a id="10336" class="Symbol">)</a>
            <a id="10350" class="Symbol">→</a> <a id="10352" href="Iterative.Sets.html#10287" class="Bound">A</a> <a id="10354" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10356" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10363" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10365" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10367" href="Iterative.Sets.html#10318" class="Bound">e</a> <a id="10369" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10371" class="Symbol">(</a><a id="10372" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10374" href="Iterative.Sets.html#10374" class="Bound">x</a> <a id="10376" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10378" href="Iterative.Sets.html#10295" class="Bound">X</a> <a id="10380" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10382" href="Iterative.Sets.html#10306" class="Bound">ϕ</a> <a id="10384" href="Iterative.Sets.html#10374" class="Bound">x</a> <a id="10386" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10388" href="Iterative.Sets.html#10287" class="Bound">A</a><a id="10389" class="Symbol">)</a>
<a id="10391" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="10403" href="Iterative.Sets.html#10403" class="Bound">A</a> <a id="10405" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10407" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10409" href="Iterative.Sets.html#10409" class="Bound">e</a> <a id="10411" class="Symbol">=</a>
 <a id="10414" class="Symbol">(</a><a id="10415" href="Iterative.Sets.html#10403" class="Bound">A</a> <a id="10417" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10419" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="10426" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10428" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10430" href="Iterative.Sets.html#10409" class="Bound">e</a><a id="10431" class="Symbol">)</a>                                     <a id="10469" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="10472" href="UF.Equiv.html#1517" class="Function">≃-refl</a> <a id="10479" class="Symbol">_</a> <a id="10481" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
 <a id="10484" class="Symbol">(</a><a id="10485" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10487" href="Iterative.Sets.html#10487" class="Bound">x</a> <a id="10489" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10491" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10493" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10495" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10511" class="Symbol">(</a><a id="10512" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10514" href="Iterative.Sets.html#10487" class="Bound">x</a><a id="10515" class="Symbol">)</a> <a id="10517" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10519" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10535" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10536" class="Symbol">)</a> <a id="10538" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="10541" href="UF.EquivalenceExamples.html#3378" class="Function">Σ-cong</a> <a id="10548" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10550" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
 <a id="10553" class="Symbol">(</a><a id="10554" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10556" href="Iterative.Sets.html#10556" class="Bound">x</a> <a id="10558" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10560" href="Iterative.Sets.html#10405" class="Bound">X</a> <a id="10562" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10564" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10566" href="Iterative.Sets.html#10556" class="Bound">x</a> <a id="10568" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10570" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10571" class="Symbol">)</a>                                   <a id="10607" href="UF.Equiv.html#2815" class="Function Operator">■</a>
  <a id="10611" class="Keyword">where</a>
   <a id="10620" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10622" class="Symbol">:</a> <a id="10624" class="Symbol">(</a><a id="10625" href="Iterative.Sets.html#10625" class="Bound">x</a> <a id="10627" class="Symbol">:</a> <a id="10629" href="Iterative.Sets.html#10405" class="Bound">X</a><a id="10630" class="Symbol">)</a> <a id="10632" class="Symbol">→</a> <a id="10634" class="Symbol">(</a><a id="10635" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10651" class="Symbol">(</a><a id="10652" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10654" href="Iterative.Sets.html#10625" class="Bound">x</a><a id="10655" class="Symbol">)</a> <a id="10657" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10659" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="10675" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10676" class="Symbol">)</a> <a id="10678" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10680" class="Symbol">(</a><a id="10681" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10683" href="Iterative.Sets.html#10625" class="Bound">x</a> <a id="10685" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10687" href="Iterative.Sets.html#10403" class="Bound">A</a><a id="10688" class="Symbol">)</a>
   <a id="10693" href="Iterative.Sets.html#10620" class="Function">I</a> <a id="10695" href="Iterative.Sets.html#10695" class="Bound">x</a> <a id="10697" class="Symbol">=</a> <a id="10699" href="UF.Embeddings.html#7365" class="Function">embedding-criterion-converse</a>
          <a id="10738" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a>
          <a id="10764" href="Iterative.Sets.html#3151" class="Function">underlying-mset-is-embedding</a>
          <a id="10803" class="Symbol">(</a><a id="10804" href="Iterative.Sets.html#10407" class="Bound">ϕ</a> <a id="10806" href="Iterative.Sets.html#10695" class="Bound">x</a><a id="10807" class="Symbol">)</a>
          <a id="10819" href="Iterative.Sets.html#10403" class="Bound">A</a>

<a id="∈-behaviour&#39;"></a><a id="10822" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="10835" class="Symbol">:</a> <a id="10837" class="Symbol">(</a><a id="10838" href="Iterative.Sets.html#10838" class="Bound">A</a> <a id="10840" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10842" class="Symbol">:</a> <a id="10844" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="10845" class="Symbol">)</a> <a id="10847" class="Symbol">→</a> <a id="10849" href="Iterative.Sets.html#10838" class="Bound">A</a> <a id="10851" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10853" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10855" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10857" class="Symbol">(</a><a id="10858" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10860" href="Iterative.Sets.html#10860" class="Bound">x</a> <a id="10862" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10864" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10871" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10873" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10875" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10884" href="Iterative.Sets.html#10840" class="Bound">B</a> <a id="10886" href="Iterative.Sets.html#10860" class="Bound">x</a> <a id="10888" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10890" href="Iterative.Sets.html#10838" class="Bound">A</a><a id="10891" class="Symbol">)</a>
<a id="10893" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="10906" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="10908" href="Iterative.Sets.html#10908" class="Bound">B</a> <a id="10910" class="Symbol">=</a>
 <a id="10913" href="MLTT.Id.html#735" class="Function">transport</a>
  <a id="10925" class="Symbol">(λ</a> <a id="10928" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10930" class="Symbol">→</a> <a id="10932" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="10934" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="10936" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10938" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="10940" class="Symbol">(</a><a id="10941" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="10943" href="Iterative.Sets.html#10943" class="Bound">x</a> <a id="10945" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="10947" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="10954" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10956" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="10958" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="10967" href="Iterative.Sets.html#10928" class="Bound">-</a> <a id="10969" href="Iterative.Sets.html#10943" class="Bound">x</a> <a id="10971" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="10973" href="Iterative.Sets.html#10906" class="Bound">A</a><a id="10974" class="Symbol">))</a>
  <a id="10979" class="Symbol">(</a><a id="10980" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="10984" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="10985" class="Symbol">)</a>
  <a id="10989" class="Symbol">(</a><a id="10990" href="Iterative.Sets.html#10272" class="Function">∈-behaviour</a> <a id="11002" href="Iterative.Sets.html#10906" class="Bound">A</a> <a id="11004" class="Symbol">(</a><a id="11005" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="11012" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11013" class="Symbol">)</a> <a id="11015" class="Symbol">(</a><a id="11016" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11025" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11026" class="Symbol">)</a> <a id="11028" class="Symbol">(</a><a id="11029" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="11051" href="Iterative.Sets.html#10908" class="Bound">B</a><a id="11052" class="Symbol">))</a>

<a id="11056" class="Keyword">private</a>
 <a id="∈-remark"></a><a id="11065" href="Iterative.Sets.html#11065" class="Function">∈-remark</a> <a id="11074" class="Symbol">:</a> <a id="11076" class="Symbol">(</a><a id="11077" href="Iterative.Sets.html#11077" class="Bound">A</a> <a id="11079" href="Iterative.Sets.html#11079" class="Bound">B</a> <a id="11081" class="Symbol">:</a> <a id="11083" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="11084" class="Symbol">)</a> <a id="11086" class="Symbol">→</a> <a id="11088" href="Iterative.Sets.html#11077" class="Bound">A</a> <a id="11090" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="11092" href="Iterative.Sets.html#11079" class="Bound">B</a> <a id="11094" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="11096" href="Notation.General.html#398" class="Function">fiber</a> <a id="11102" class="Symbol">(</a><a id="11103" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11112" href="Iterative.Sets.html#11079" class="Bound">B</a><a id="11113" class="Symbol">)</a> <a id="11115" href="Iterative.Sets.html#11077" class="Bound">A</a>
 <a id="11118" href="Iterative.Sets.html#11065" class="Function">∈-remark</a> <a id="11127" class="Symbol">=</a> <a id="11129" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a>

<a id="11143" class="Markup">\end{code}</a><a id="11153" class="Background">

It also follows from the facts that 𝕍 is a set and that 𝕍-forest is an
embedding that the root of any iterative set is a 0-type:

</a><a id="11285" class="Markup">\begin{code}</a>

<a id="𝕍-root-is-set"></a><a id="11299" href="Iterative.Sets.html#11299" class="Function">𝕍-root-is-set</a> <a id="11313" class="Symbol">:</a> <a id="11315" class="Symbol">(</a><a id="11316" href="Iterative.Sets.html#11316" class="Bound">A</a> <a id="11318" class="Symbol">:</a> <a id="11320" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="11321" class="Symbol">)</a> <a id="11323" class="Symbol">→</a> <a id="11325" href="UF.Sets.html#709" class="Function">is-set</a> <a id="11332" class="Symbol">(</a><a id="11333" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="11340" href="Iterative.Sets.html#11316" class="Bound">A</a><a id="11341" class="Symbol">)</a>
<a id="11343" href="Iterative.Sets.html#11299" class="Function">𝕍-root-is-set</a> <a id="11357" href="Iterative.Sets.html#11357" class="Bound">A</a> <a id="11359" class="Symbol">=</a> <a id="11361" href="UF.Embeddings.html#5596" class="Function">subtypes-of-sets-are-sets</a>
                   <a id="11406" class="Symbol">(</a><a id="11407" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="11416" href="Iterative.Sets.html#11357" class="Bound">A</a><a id="11417" class="Symbol">)</a>
                   <a id="11438" class="Symbol">(</a><a id="11439" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="11461" href="Iterative.Sets.html#11357" class="Bound">A</a><a id="11462" class="Symbol">)</a>
                   <a id="11483" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a>
<a id="11492" class="Markup">\end{code}</a><a id="11502" class="Background">

It would be nice if we could define 𝕍 inductively as follows:

 data 𝕍 : 𝓤⁺ ̇ where
  𝕍-ssup : (X : 𝓤 ̇ ) (φ : X → 𝕍) → is-embedding φ → 𝕍

However, this is not a strictly positive definition, for the criterion
of strict positivity adopted by Agda, and so it is not accepted.

Nevertheless, all iterative sets *are* generated by the &quot;constructor&quot;
𝕍-ssup, in the following sense, so that we can view 𝕍 as really
inductively defined by the above data declaration.

The following result, implementing the above idea, seems to be new.

</a><a id="12036" class="Markup">\begin{code}</a>

<a id="𝕍-Induction&#39;"></a><a id="12050" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a>
 <a id="12064" class="Symbol">:</a> <a id="12066" class="Symbol">(</a><a id="12067" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12069" class="Symbol">:</a> <a id="12071" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="12073" class="Symbol">→</a> <a id="12075" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="12077" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="12079" class="Symbol">)</a>
   <a id="12084" class="Symbol">(</a><a id="12085" href="Iterative.Sets.html#12085" class="Bound">f</a> <a id="12087" class="Symbol">:</a> <a id="12089" class="Symbol">(</a><a id="12090" href="Iterative.Sets.html#12090" class="Bound">A</a> <a id="12092" class="Symbol">:</a> <a id="12094" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12095" class="Symbol">)</a> <a id="12097" class="Symbol">→</a> <a id="12099" class="Symbol">((</a><a id="12101" href="Iterative.Sets.html#12101" class="Bound">x</a> <a id="12103" class="Symbol">:</a> <a id="12105" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="12112" href="Iterative.Sets.html#12090" class="Bound">A</a><a id="12113" class="Symbol">)</a> <a id="12115" class="Symbol">→</a> <a id="12117" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12119" class="Symbol">(</a><a id="12120" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12129" href="Iterative.Sets.html#12090" class="Bound">A</a> <a id="12131" href="Iterative.Sets.html#12101" class="Bound">x</a><a id="12132" class="Symbol">))</a> <a id="12135" class="Symbol">→</a> <a id="12137" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12139" href="Iterative.Sets.html#12090" class="Bound">A</a><a id="12140" class="Symbol">)</a>
 <a id="12143" class="Symbol">→</a> <a id="12145" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="12147" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12149" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="12151" class="Symbol">((</a><a id="12153" href="Iterative.Sets.html#12153" class="Bound">A</a> <a id="12155" class="Symbol">:</a> <a id="12157" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12158" class="Symbol">)</a> <a id="12160" class="Symbol">→</a> <a id="12162" href="Iterative.Sets.html#12067" class="Bound">P</a> <a id="12164" href="Iterative.Sets.html#12153" class="Bound">A</a><a id="12165" class="Symbol">)</a>
       <a id="12174" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="12176" class="Symbol">((</a><a id="12178" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12180" class="Symbol">:</a> <a id="12182" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12183" class="Symbol">)</a> <a id="12185" class="Symbol">→</a> <a id="12187" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12189" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12191" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12193" href="Iterative.Sets.html#12085" class="Bound">f</a> <a id="12195" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12197" class="Symbol">(λ</a> <a id="12200" href="Iterative.Sets.html#12200" class="Bound">x</a> <a id="12202" class="Symbol">→</a> <a id="12204" href="Iterative.Sets.html#12147" class="Bound">h</a> <a id="12206" class="Symbol">(</a><a id="12207" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12216" href="Iterative.Sets.html#12178" class="Bound">A</a> <a id="12218" href="Iterative.Sets.html#12200" class="Bound">x</a><a id="12219" class="Symbol">)))</a>
<a id="12223" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="12236" href="Iterative.Sets.html#12236" class="Bound">P</a> <a id="12238" href="Iterative.Sets.html#12238" class="Bound">f</a> <a id="12240" class="Symbol">=</a> <a id="12242" class="Symbol">(λ</a> <a id="12245" class="Symbol">(</a><a id="12246" href="Iterative.Sets.html#12246" class="Bound">M</a> <a id="12248" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12250" href="Iterative.Sets.html#12250" class="Bound">i</a><a id="12251" class="Symbol">)</a> <a id="12253" class="Symbol">→</a> <a id="12255" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12257" href="Iterative.Sets.html#12246" class="Bound">M</a> <a id="12259" href="Iterative.Sets.html#12250" class="Bound">i</a><a id="12260" class="Symbol">)</a> <a id="12262" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12264" href="Iterative.Sets.html#12398" class="Function">p</a>
 <a id="12267" class="Keyword">where</a>
  <a id="12275" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12277" class="Symbol">:</a> <a id="12279" class="Symbol">(</a><a id="12280" href="Iterative.Sets.html#12280" class="Bound">M</a> <a id="12282" class="Symbol">:</a> <a id="12284" href="Iterative.Multisets.html#691" class="Function">𝕄</a><a id="12285" class="Symbol">)</a> <a id="12287" class="Symbol">(</a><a id="12288" href="Iterative.Sets.html#12288" class="Bound">i</a> <a id="12290" class="Symbol">:</a> <a id="12292" href="Iterative.Sets.html#1608" class="Function">is-iterative-set</a> <a id="12309" href="Iterative.Sets.html#12280" class="Bound">M</a><a id="12310" class="Symbol">)</a> <a id="12312" class="Symbol">→</a> <a id="12314" href="Iterative.Sets.html#12236" class="Bound">P</a> <a id="12316" class="Symbol">(</a><a id="12317" href="Iterative.Sets.html#12280" class="Bound">M</a> <a id="12319" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12321" href="Iterative.Sets.html#12288" class="Bound">i</a><a id="12322" class="Symbol">)</a>
  <a id="12326" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12328" href="Iterative.Sets.html#12328" class="Bound">M</a><a id="12329" class="Symbol">@(</a><a id="12331" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12336" href="Iterative.Sets.html#12336" class="Bound">X</a> <a id="12338" href="Iterative.Sets.html#12338" class="Bound">φ</a><a id="12339" class="Symbol">)</a> <a id="12341" href="Iterative.Sets.html#12341" class="Bound">i</a><a id="12342" class="Symbol">@(_</a> <a id="12346" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12348" href="Iterative.Sets.html#12348" class="Bound">φ-iter</a><a id="12354" class="Symbol">)</a> <a id="12356" class="Symbol">=</a> <a id="12358" href="Iterative.Sets.html#12238" class="Bound">f</a> <a id="12360" class="Symbol">(</a><a id="12361" href="Iterative.Sets.html#12328" class="Bound">M</a> <a id="12363" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12365" href="Iterative.Sets.html#12341" class="Bound">i</a><a id="12366" class="Symbol">)</a> <a id="12368" class="Symbol">(λ</a> <a id="12371" href="Iterative.Sets.html#12371" class="Bound">x</a> <a id="12373" class="Symbol">→</a> <a id="12375" href="Iterative.Sets.html#12275" class="Function">H</a> <a id="12377" class="Symbol">(</a><a id="12378" href="Iterative.Sets.html#12338" class="Bound">φ</a> <a id="12380" href="Iterative.Sets.html#12371" class="Bound">x</a><a id="12381" class="Symbol">)</a> <a id="12383" class="Symbol">(</a><a id="12384" href="Iterative.Sets.html#12348" class="Bound">φ-iter</a> <a id="12391" href="Iterative.Sets.html#12371" class="Bound">x</a><a id="12392" class="Symbol">))</a>

  <a id="12398" href="Iterative.Sets.html#12398" class="Function">p</a> <a id="12400" class="Symbol">:</a> <a id="12402" class="Symbol">(</a><a id="12403" href="Iterative.Sets.html#12403" class="Bound">A</a> <a id="12405" class="Symbol">:</a> <a id="12407" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12408" class="Symbol">)</a> <a id="12410" class="Symbol">→</a> <a id="12412" class="Symbol">_</a> <a id="12414" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12416" class="Symbol">_</a>
  <a id="12420" href="Iterative.Sets.html#12398" class="Function">p</a> <a id="12422" class="Symbol">(</a><a id="12423" href="Iterative.Sets.html#12423" class="Bound">M</a><a id="12424" class="Symbol">@(</a><a id="12426" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12431" href="Iterative.Sets.html#12431" class="Bound">X</a> <a id="12433" href="Iterative.Sets.html#12433" class="Bound">φ</a><a id="12434" class="Symbol">)</a> <a id="12436" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12438" href="Iterative.Sets.html#12438" class="Bound">i</a><a id="12439" class="Symbol">@(_</a> <a id="12443" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12445" href="Iterative.Sets.html#12445" class="Bound">φ-iter</a><a id="12451" class="Symbol">))</a> <a id="12454" class="Symbol">=</a> <a id="12456" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a>

<a id="𝕍-Induction"></a><a id="12462" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a>
 <a id="12475" class="Symbol">:</a> <a id="12477" class="Symbol">(</a><a id="12478" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12480" class="Symbol">:</a> <a id="12482" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="12484" class="Symbol">→</a> <a id="12486" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="12488" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="12490" class="Symbol">)</a>
 <a id="12493" class="Symbol">→</a> <a id="12495" class="Symbol">(</a><a id="12496" href="Iterative.Sets.html#12496" class="Bound">f</a> <a id="12498" class="Symbol">:</a> <a id="12500" class="Symbol">(</a><a id="12501" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12503" class="Symbol">:</a> <a id="12505" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="12507" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="12509" class="Symbol">)</a> <a id="12511" class="Symbol">(</a><a id="12512" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12514" class="Symbol">:</a> <a id="12516" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12518" class="Symbol">→</a> <a id="12520" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12521" class="Symbol">)</a> <a id="12523" class="Symbol">(</a><a id="12524" href="Iterative.Sets.html#12524" class="Bound">e</a> <a id="12526" class="Symbol">:</a> <a id="12528" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="12541" href="Iterative.Sets.html#12512" class="Bound">ϕ</a><a id="12542" class="Symbol">)</a>
      <a id="12550" class="Symbol">→</a> <a id="12552" class="Symbol">((</a><a id="12554" href="Iterative.Sets.html#12554" class="Bound">x</a> <a id="12556" class="Symbol">:</a> <a id="12558" href="Iterative.Sets.html#12501" class="Bound">X</a><a id="12559" class="Symbol">)</a> <a id="12561" class="Symbol">→</a> <a id="12563" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12565" class="Symbol">(</a><a id="12566" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12568" href="Iterative.Sets.html#12554" class="Bound">x</a><a id="12569" class="Symbol">))</a>
      <a id="12578" class="Symbol">→</a> <a id="12580" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12582" class="Symbol">(</a><a id="12583" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12590" href="Iterative.Sets.html#12501" class="Bound">X</a> <a id="12592" href="Iterative.Sets.html#12512" class="Bound">ϕ</a> <a id="12594" href="Iterative.Sets.html#12524" class="Bound">e</a><a id="12595" class="Symbol">))</a>
 <a id="12599" class="Symbol">→</a> <a id="12601" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="12603" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12605" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="12607" class="Symbol">((</a><a id="12609" href="Iterative.Sets.html#12609" class="Bound">A</a> <a id="12611" class="Symbol">:</a> <a id="12613" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12614" class="Symbol">)</a> <a id="12616" class="Symbol">→</a> <a id="12618" href="Iterative.Sets.html#12478" class="Bound">P</a> <a id="12620" href="Iterative.Sets.html#12609" class="Bound">A</a><a id="12621" class="Symbol">)</a>
       <a id="12630" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="12632" class="Symbol">((</a><a id="12634" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12636" class="Symbol">:</a> <a id="12638" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="12640" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="12642" class="Symbol">)</a> <a id="12644" class="Symbol">(</a><a id="12645" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12647" class="Symbol">:</a> <a id="12649" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12651" class="Symbol">→</a> <a id="12653" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12654" class="Symbol">)</a> <a id="12656" class="Symbol">(</a><a id="12657" href="Iterative.Sets.html#12657" class="Bound">e</a> <a id="12659" class="Symbol">:</a> <a id="12661" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="12674" href="Iterative.Sets.html#12645" class="Bound">ϕ</a><a id="12675" class="Symbol">)</a>
       <a id="12684" class="Symbol">→</a> <a id="12686" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12688" class="Symbol">(</a><a id="12689" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12696" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12698" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12700" href="Iterative.Sets.html#12657" class="Bound">e</a><a id="12701" class="Symbol">)</a> <a id="12703" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="12705" href="Iterative.Sets.html#12496" class="Bound">f</a> <a id="12707" href="Iterative.Sets.html#12634" class="Bound">X</a> <a id="12709" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12711" href="Iterative.Sets.html#12657" class="Bound">e</a> <a id="12713" class="Symbol">(λ</a> <a id="12716" href="Iterative.Sets.html#12716" class="Bound">x</a> <a id="12718" class="Symbol">→</a> <a id="12720" href="Iterative.Sets.html#12603" class="Bound">h</a> <a id="12722" class="Symbol">(</a><a id="12723" href="Iterative.Sets.html#12645" class="Bound">ϕ</a> <a id="12725" href="Iterative.Sets.html#12716" class="Bound">x</a><a id="12726" class="Symbol">)))</a>
<a id="12730" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="12742" class="Symbol">{</a><a id="12743" href="Iterative.Sets.html#12743" class="Bound">𝓥</a><a id="12744" class="Symbol">}</a> <a id="12746" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12748" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="12750" class="Symbol">=</a> <a id="12752" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="12754" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12756" href="Iterative.Sets.html#13183" class="Function">IV</a>
 <a id="12760" class="Keyword">where</a>
  <a id="12768" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="12771" class="Symbol">:</a> <a id="12773" class="Symbol">(</a><a id="12774" href="Iterative.Sets.html#12774" class="Bound">A</a> <a id="12776" class="Symbol">:</a> <a id="12778" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="12779" class="Symbol">)</a> <a id="12781" class="Symbol">→</a> <a id="12783" class="Symbol">((</a><a id="12785" href="Iterative.Sets.html#12785" class="Bound">x</a> <a id="12787" class="Symbol">:</a> <a id="12789" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="12796" href="Iterative.Sets.html#12774" class="Bound">A</a><a id="12797" class="Symbol">)</a> <a id="12799" class="Symbol">→</a> <a id="12801" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12803" class="Symbol">(</a><a id="12804" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12813" href="Iterative.Sets.html#12774" class="Bound">A</a> <a id="12815" href="Iterative.Sets.html#12785" class="Bound">x</a><a id="12816" class="Symbol">))</a> <a id="12819" class="Symbol">→</a> <a id="12821" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12823" href="Iterative.Sets.html#12774" class="Bound">A</a>
  <a id="12827" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="12830" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12831" class="Symbol">@(</a><a id="12833" href="Iterative.Sets.html#12833" class="Bound">M</a><a id="12834" class="Symbol">@(</a><a id="12836" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="12841" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12843" href="Iterative.Sets.html#12843" class="Bound">φ</a><a id="12844" class="Symbol">)</a> <a id="12846" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12848" href="Iterative.Sets.html#12848" class="Bound">i</a><a id="12849" class="Symbol">@(</a><a id="12851" href="Iterative.Sets.html#12851" class="Bound">φ-emb</a> <a id="12857" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="12859" href="Iterative.Sets.html#12859" class="Bound">φ-iter</a><a id="12865" class="Symbol">))</a> <a id="12868" href="Iterative.Sets.html#12868" class="Bound">g</a> <a id="12870" class="Symbol">=</a> <a id="12872" href="Iterative.Sets.html#13002" class="Function">II</a>
   <a id="12878" class="Keyword">where</a>
    <a id="12888" href="Iterative.Sets.html#12888" class="Function">I</a> <a id="12890" class="Symbol">:</a> <a id="12892" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="12894" class="Symbol">(</a><a id="12895" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="12902" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12904" class="Symbol">(</a><a id="12905" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12914" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12915" class="Symbol">)</a> <a id="12917" class="Symbol">(</a><a id="12918" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="12940" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12941" class="Symbol">))</a>
    <a id="12948" href="Iterative.Sets.html#12888" class="Function">I</a> <a id="12950" class="Symbol">=</a> <a id="12952" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="12954" href="Iterative.Sets.html#12841" class="Bound">X</a> <a id="12956" class="Symbol">(</a><a id="12957" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="12966" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12967" class="Symbol">)</a> <a id="12969" class="Symbol">(</a><a id="12970" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="12992" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="12993" class="Symbol">)</a> <a id="12995" href="Iterative.Sets.html#12868" class="Bound">g</a>

    <a id="13002" href="Iterative.Sets.html#13002" class="Function">II</a> <a id="13005" class="Symbol">:</a> <a id="13007" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13009" href="Iterative.Sets.html#12830" class="Bound">A</a>
    <a id="13015" href="Iterative.Sets.html#13002" class="Function">II</a> <a id="13018" class="Symbol">=</a> <a id="13020" href="MLTT.Id.html#735" class="Function">transport</a> <a id="13030" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13032" class="Symbol">(</a><a id="13033" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13037" href="Iterative.Sets.html#12830" class="Bound">A</a><a id="13038" class="Symbol">)</a> <a id="13040" href="Iterative.Sets.html#12888" class="Function">I</a>

  <a id="13045" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13047" class="Symbol">:</a> <a id="13049" class="Symbol">(</a><a id="13050" href="Iterative.Sets.html#13050" class="Bound">A</a> <a id="13052" class="Symbol">:</a> <a id="13054" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13055" class="Symbol">)</a> <a id="13057" class="Symbol">→</a> <a id="13059" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13061" href="Iterative.Sets.html#13050" class="Bound">A</a>
  <a id="13065" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13067" class="Symbol">=</a> <a id="13069" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="13073" class="Symbol">(</a><a id="13074" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="13087" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13089" href="Iterative.Sets.html#12768" class="Function">f&#39;</a><a id="13091" class="Symbol">)</a>

  <a id="13096" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13100" class="Symbol">:</a> <a id="13102" class="Symbol">(</a><a id="13103" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13105" class="Symbol">:</a> <a id="13107" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13108" class="Symbol">)</a> <a id="13110" class="Symbol">→</a> <a id="13112" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13114" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13116" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13118" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="13121" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13123" class="Symbol">(λ</a> <a id="13126" href="Iterative.Sets.html#13126" class="Bound">x</a> <a id="13128" class="Symbol">→</a> <a id="13130" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13132" class="Symbol">(</a><a id="13133" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="13142" href="Iterative.Sets.html#13103" class="Bound">A</a> <a id="13144" href="Iterative.Sets.html#13126" class="Bound">x</a><a id="13145" class="Symbol">))</a>
  <a id="13150" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13154" class="Symbol">=</a> <a id="13156" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="13160" class="Symbol">(</a><a id="13161" href="Iterative.Sets.html#12050" class="Function">𝕍-Induction&#39;</a> <a id="13174" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13176" href="Iterative.Sets.html#12768" class="Function">f&#39;</a><a id="13178" class="Symbol">)</a>

  <a id="13183" href="Iterative.Sets.html#13183" class="Function">IV</a> <a id="13186" class="Symbol">:</a> <a id="13188" class="Symbol">(</a><a id="13189" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13191" class="Symbol">:</a> <a id="13193" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="13195" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="13197" class="Symbol">)</a> <a id="13199" class="Symbol">(</a><a id="13200" href="Iterative.Sets.html#13200" class="Bound">ϕ</a> <a id="13202" class="Symbol">:</a> <a id="13204" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13206" class="Symbol">→</a> <a id="13208" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="13209" class="Symbol">)</a> <a id="13211" class="Symbol">(</a><a id="13212" href="Iterative.Sets.html#13212" class="Bound">e</a> <a id="13214" class="Symbol">:</a> <a id="13216" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="13229" href="Iterative.Sets.html#13200" class="Bound">ϕ</a><a id="13230" class="Symbol">)</a>
     <a id="13237" class="Symbol">→</a> <a id="13239" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13241" class="Symbol">(</a><a id="13242" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13249" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13251" href="Iterative.Sets.html#13200" class="Bound">ϕ</a> <a id="13253" href="Iterative.Sets.html#13212" class="Bound">e</a><a id="13254" class="Symbol">)</a> <a id="13256" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13258" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13260" href="Iterative.Sets.html#13189" class="Bound">X</a> <a id="13262" href="Iterative.Sets.html#13200" class="Bound">ϕ</a> <a id="13264" href="Iterative.Sets.html#13212" class="Bound">e</a> <a id="13266" class="Symbol">(λ</a> <a id="13269" href="Iterative.Sets.html#13269" class="Bound">x</a> <a id="13271" class="Symbol">→</a> <a id="13273" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13275" class="Symbol">(</a><a id="13276" href="Iterative.Sets.html#13200" class="Bound">ϕ</a> <a id="13278" href="Iterative.Sets.html#13269" class="Bound">x</a><a id="13279" class="Symbol">))</a>
  <a id="13284" href="Iterative.Sets.html#13183" class="Function">IV</a> <a id="13287" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13289" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13291" href="Iterative.Sets.html#13291" class="Bound">e</a> <a id="13293" class="Symbol">=</a>
   <a id="13298" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13300" href="Iterative.Sets.html#13790" class="Function">A</a>                                                               <a id="13364" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="13367" href="Iterative.Sets.html#13096" class="Function">III</a> <a id="13371" href="Iterative.Sets.html#13790" class="Function">A</a> <a id="13373" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="13378" href="Iterative.Sets.html#12768" class="Function">f&#39;</a> <a id="13381" href="Iterative.Sets.html#13790" class="Function">A</a> <a id="13383" class="Symbol">(λ</a> <a id="13386" href="Iterative.Sets.html#13386" class="Bound">x</a> <a id="13388" class="Symbol">→</a> <a id="13390" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13392" class="Symbol">(</a><a id="13393" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13395" href="Iterative.Sets.html#13386" class="Bound">x</a><a id="13396" class="Symbol">))</a>                                              <a id="13444" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="13447" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="13452" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="13457" href="Iterative.Sets.html#13771" class="Function">t</a> <a id="13459" href="Iterative.Sets.html#12746" class="Bound">P</a>                <a id="13476" class="Symbol">(</a><a id="13477" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13481" href="Iterative.Sets.html#13790" class="Function">A</a><a id="13482" class="Symbol">)</a>             <a id="13496" class="Symbol">(</a><a id="13497" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13499" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13501" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13503" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13506" class="Symbol">(λ</a> <a id="13509" href="Iterative.Sets.html#13509" class="Bound">x</a> <a id="13511" class="Symbol">→</a> <a id="13513" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13515" class="Symbol">(</a><a id="13516" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13518" href="Iterative.Sets.html#13509" class="Bound">x</a><a id="13519" class="Symbol">)))</a> <a id="13523" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="13526" href="Iterative.Sets.html#13966" class="Function">i</a> <a id="13528" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="13533" href="Iterative.Sets.html#13771" class="Function">t</a> <a id="13535" href="Iterative.Sets.html#12746" class="Bound">P</a>                <a id="13552" class="Symbol">(</a><a id="13553" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13556" class="Symbol">(</a><a id="13557" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13564" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13566" href="Iterative.Sets.html#13289" class="Bound">ϕ</a><a id="13567" class="Symbol">)</a> <a id="13569" href="Iterative.Sets.html#13848" class="Function">p</a><a id="13570" class="Symbol">)</a> <a id="13572" class="Symbol">(</a><a id="13573" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13575" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13577" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13579" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13582" class="Symbol">(λ</a> <a id="13585" href="Iterative.Sets.html#13585" class="Bound">x</a> <a id="13587" class="Symbol">→</a> <a id="13589" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13591" class="Symbol">(</a><a id="13592" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13594" href="Iterative.Sets.html#13585" class="Bound">x</a><a id="13595" class="Symbol">)))</a> <a id="13599" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="13602" href="Iterative.Sets.html#14023" class="Function">ii</a> <a id="13605" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="13610" href="Iterative.Sets.html#13771" class="Function">t</a> <a id="13612" class="Symbol">(</a><a id="13613" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13615" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="13617" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13624" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13626" href="Iterative.Sets.html#13289" class="Bound">ϕ</a><a id="13627" class="Symbol">)</a> <a id="13629" href="Iterative.Sets.html#13848" class="Function">p</a>                   <a id="13649" class="Symbol">(</a><a id="13650" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13652" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13654" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13656" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13659" class="Symbol">(λ</a> <a id="13662" href="Iterative.Sets.html#13662" class="Bound">x</a> <a id="13664" class="Symbol">→</a> <a id="13666" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13668" class="Symbol">(</a><a id="13669" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13671" href="Iterative.Sets.html#13662" class="Bound">x</a><a id="13672" class="Symbol">)))</a> <a id="13676" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="13679" href="Iterative.Sets.html#14068" class="Function">iii</a> <a id="13683" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
   <a id="13688" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13690" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13692" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13694" href="Iterative.Sets.html#13291" class="Bound">e</a> <a id="13696" class="Symbol">(λ</a> <a id="13699" href="Iterative.Sets.html#13699" class="Bound">x</a> <a id="13701" class="Symbol">→</a> <a id="13703" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="13705" class="Symbol">(</a><a id="13706" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13708" href="Iterative.Sets.html#13699" class="Bound">x</a><a id="13709" class="Symbol">))</a>                                           <a id="13754" href="MLTT.Id.html#2787" class="Function Operator">∎</a>
    <a id="13760" class="Keyword">where</a>
     <a id="13771" href="Iterative.Sets.html#13771" class="Function">t</a> <a id="13773" class="Symbol">=</a> <a id="13775" href="MLTT.Id.html#735" class="Function">transport</a>
     <a id="13790" href="Iterative.Sets.html#13790" class="Function">A</a>  <a id="13793" class="Symbol">=</a> <a id="13795" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13802" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13804" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13806" href="Iterative.Sets.html#13291" class="Bound">e</a>
     <a id="13813" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13816" class="Symbol">=</a> <a id="13818" href="Iterative.Sets.html#8665" class="Function">𝕍-forest-is-embedding</a> <a id="13840" href="Iterative.Sets.html#13790" class="Function">A</a>

     <a id="13848" href="Iterative.Sets.html#13848" class="Function">p</a> <a id="13850" class="Symbol">:</a> <a id="13852" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13855" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13857" href="Iterative.Sets.html#13291" class="Bound">e</a>
     <a id="13864" href="Iterative.Sets.html#13848" class="Function">p</a> <a id="13866" class="Symbol">=</a> <a id="13868" href="UF.Embeddings.html#691" class="Function">being-embedding-is-prop</a> <a id="13892" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="13895" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13897" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13900" href="Iterative.Sets.html#13291" class="Bound">e</a>

     <a id="13908" href="Iterative.Sets.html#13908" class="Function">q</a> <a id="13910" class="Symbol">:</a> <a id="13912" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="13916" href="Iterative.Sets.html#13790" class="Function">A</a> <a id="13918" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="13920" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13923" class="Symbol">(</a><a id="13924" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="13931" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13933" href="Iterative.Sets.html#13289" class="Bound">ϕ</a><a id="13934" class="Symbol">)</a> <a id="13936" href="Iterative.Sets.html#13848" class="Function">p</a>
     <a id="13943" href="Iterative.Sets.html#13908" class="Function">q</a> <a id="13945" class="Symbol">=</a> <a id="13947" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a> <a id="13956" class="Symbol">_</a> <a id="13958" class="Symbol">_</a>

     <a id="13966" href="Iterative.Sets.html#13966" class="Function">i</a>   <a id="13970" class="Symbol">=</a> <a id="13972" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="13975" class="Symbol">(λ</a> <a id="13978" href="Iterative.Sets.html#13978" class="Bound">-</a> <a id="13980" class="Symbol">→</a> <a id="13982" href="Iterative.Sets.html#13771" class="Function">t</a> <a id="13984" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="13986" href="Iterative.Sets.html#13978" class="Bound">-</a> <a id="13988" class="Symbol">(</a><a id="13989" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="13991" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="13993" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="13995" href="Iterative.Sets.html#13813" class="Function">e&#39;</a> <a id="13998" class="Symbol">(λ</a> <a id="14001" href="Iterative.Sets.html#14001" class="Bound">x</a> <a id="14003" class="Symbol">→</a> <a id="14005" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="14007" class="Symbol">(</a><a id="14008" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="14010" href="Iterative.Sets.html#14001" class="Bound">x</a><a id="14011" class="Symbol">))))</a> <a id="14016" href="Iterative.Sets.html#13908" class="Function">q</a>
     <a id="14023" href="Iterative.Sets.html#14023" class="Function">ii</a>  <a id="14027" class="Symbol">=</a> <a id="14029" class="Symbol">(</a><a id="14030" href="UF.Base.html#5112" class="Function">transport-ap</a> <a id="14043" href="Iterative.Sets.html#12746" class="Bound">P</a> <a id="14045" class="Symbol">(</a><a id="14046" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14053" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="14055" href="Iterative.Sets.html#13289" class="Bound">ϕ</a><a id="14056" class="Symbol">)</a> <a id="14058" href="Iterative.Sets.html#13848" class="Function">p</a><a id="14059" class="Symbol">)</a><a id="14060" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>
     <a id="14068" href="Iterative.Sets.html#14068" class="Function">iii</a> <a id="14072" class="Symbol">=</a> <a id="14074" href="UF.Base.html#7318" class="Function">apd</a> <a id="14078" class="Symbol">(λ</a> <a id="14081" href="Iterative.Sets.html#14081" class="Bound">-</a> <a id="14083" class="Symbol">→</a> <a id="14085" href="Iterative.Sets.html#12748" class="Bound">f</a> <a id="14087" href="Iterative.Sets.html#13287" class="Bound">X</a> <a id="14089" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="14091" href="Iterative.Sets.html#14081" class="Bound">-</a> <a id="14093" class="Symbol">(λ</a> <a id="14096" href="Iterative.Sets.html#14096" class="Bound">x</a> <a id="14098" class="Symbol">→</a> <a id="14100" href="Iterative.Sets.html#13045" class="Function">h</a> <a id="14102" class="Symbol">(</a><a id="14103" href="Iterative.Sets.html#13289" class="Bound">ϕ</a> <a id="14105" href="Iterative.Sets.html#14096" class="Bound">x</a><a id="14106" class="Symbol">)))</a> <a id="14110" href="Iterative.Sets.html#13848" class="Function">p</a>

<a id="𝕍-induction"></a><a id="14113" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="14125" class="Symbol">:</a> <a id="14127" class="Symbol">(</a><a id="14128" href="Iterative.Sets.html#14128" class="Bound">P</a> <a id="14130" class="Symbol">:</a> <a id="14132" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14134" class="Symbol">→</a> <a id="14136" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="14138" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14140" class="Symbol">)</a>
            <a id="14154" class="Symbol">→</a> <a id="14156" class="Symbol">((</a><a id="14158" href="Iterative.Sets.html#14158" class="Bound">X</a> <a id="14160" class="Symbol">:</a> <a id="14162" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14164" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14166" class="Symbol">)</a> <a id="14168" class="Symbol">(</a><a id="14169" href="Iterative.Sets.html#14169" class="Bound">ϕ</a> <a id="14171" class="Symbol">:</a> <a id="14173" href="Iterative.Sets.html#14158" class="Bound">X</a> <a id="14175" class="Symbol">→</a> <a id="14177" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14178" class="Symbol">)</a> <a id="14180" class="Symbol">(</a><a id="14181" href="Iterative.Sets.html#14181" class="Bound">e</a> <a id="14183" class="Symbol">:</a> <a id="14185" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14198" href="Iterative.Sets.html#14169" class="Bound">ϕ</a><a id="14199" class="Symbol">)</a>
                  <a id="14219" class="Symbol">→</a> <a id="14221" class="Symbol">((</a><a id="14223" href="Iterative.Sets.html#14223" class="Bound">x</a> <a id="14225" class="Symbol">:</a> <a id="14227" href="Iterative.Sets.html#14158" class="Bound">X</a><a id="14228" class="Symbol">)</a> <a id="14230" class="Symbol">→</a> <a id="14232" href="Iterative.Sets.html#14128" class="Bound">P</a> <a id="14234" class="Symbol">(</a><a id="14235" href="Iterative.Sets.html#14169" class="Bound">ϕ</a> <a id="14237" href="Iterative.Sets.html#14223" class="Bound">x</a><a id="14238" class="Symbol">))</a>
                  <a id="14259" class="Symbol">→</a> <a id="14261" href="Iterative.Sets.html#14128" class="Bound">P</a> <a id="14263" class="Symbol">(</a><a id="14264" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14271" href="Iterative.Sets.html#14158" class="Bound">X</a> <a id="14273" href="Iterative.Sets.html#14169" class="Bound">ϕ</a> <a id="14275" href="Iterative.Sets.html#14181" class="Bound">e</a><a id="14276" class="Symbol">))</a>
            <a id="14291" class="Symbol">→</a> <a id="14293" class="Symbol">(</a><a id="14294" href="Iterative.Sets.html#14294" class="Bound">A</a> <a id="14296" class="Symbol">:</a> <a id="14298" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14299" class="Symbol">)</a> <a id="14301" class="Symbol">→</a> <a id="14303" href="Iterative.Sets.html#14128" class="Bound">P</a> <a id="14305" href="Iterative.Sets.html#14294" class="Bound">A</a>
<a id="14307" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="14319" href="Iterative.Sets.html#14319" class="Bound">P</a> <a id="14321" href="Iterative.Sets.html#14321" class="Bound">f</a> <a id="14323" class="Symbol">=</a> <a id="14325" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="14329" class="Symbol">(</a><a id="14330" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="14342" href="Iterative.Sets.html#14319" class="Bound">P</a> <a id="14344" href="Iterative.Sets.html#14321" class="Bound">f</a><a id="14345" class="Symbol">)</a>

<a id="𝕍-induction-behaviour"></a><a id="14348" href="Iterative.Sets.html#14348" class="Function">𝕍-induction-behaviour</a>
 <a id="14371" class="Symbol">:</a> <a id="14373" class="Symbol">(</a><a id="14374" href="Iterative.Sets.html#14374" class="Bound">P</a> <a id="14376" class="Symbol">:</a> <a id="14378" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14380" class="Symbol">→</a> <a id="14382" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="14384" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14386" class="Symbol">)</a>
 <a id="14389" class="Symbol">→</a> <a id="14391" class="Symbol">(</a><a id="14392" href="Iterative.Sets.html#14392" class="Bound">f</a> <a id="14394" class="Symbol">:</a> <a id="14396" class="Symbol">(</a><a id="14397" href="Iterative.Sets.html#14397" class="Bound">X</a> <a id="14399" class="Symbol">:</a> <a id="14401" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14403" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14405" class="Symbol">)</a> <a id="14407" class="Symbol">(</a><a id="14408" href="Iterative.Sets.html#14408" class="Bound">ϕ</a> <a id="14410" class="Symbol">:</a> <a id="14412" href="Iterative.Sets.html#14397" class="Bound">X</a> <a id="14414" class="Symbol">→</a> <a id="14416" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14417" class="Symbol">)</a> <a id="14419" class="Symbol">(</a><a id="14420" href="Iterative.Sets.html#14420" class="Bound">e</a> <a id="14422" class="Symbol">:</a> <a id="14424" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14437" href="Iterative.Sets.html#14408" class="Bound">ϕ</a><a id="14438" class="Symbol">)</a>
      <a id="14446" class="Symbol">→</a> <a id="14448" class="Symbol">((</a><a id="14450" href="Iterative.Sets.html#14450" class="Bound">x</a> <a id="14452" class="Symbol">:</a> <a id="14454" href="Iterative.Sets.html#14397" class="Bound">X</a><a id="14455" class="Symbol">)</a> <a id="14457" class="Symbol">→</a> <a id="14459" href="Iterative.Sets.html#14374" class="Bound">P</a> <a id="14461" class="Symbol">(</a><a id="14462" href="Iterative.Sets.html#14408" class="Bound">ϕ</a> <a id="14464" href="Iterative.Sets.html#14450" class="Bound">x</a><a id="14465" class="Symbol">))</a>
      <a id="14474" class="Symbol">→</a> <a id="14476" href="Iterative.Sets.html#14374" class="Bound">P</a> <a id="14478" class="Symbol">(</a><a id="14479" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14486" href="Iterative.Sets.html#14397" class="Bound">X</a> <a id="14488" href="Iterative.Sets.html#14408" class="Bound">ϕ</a> <a id="14490" href="Iterative.Sets.html#14420" class="Bound">e</a><a id="14491" class="Symbol">))</a>
 <a id="14495" class="Symbol">→</a> <a id="14497" class="Symbol">(</a><a id="14498" href="Iterative.Sets.html#14498" class="Bound">X</a> <a id="14500" class="Symbol">:</a> <a id="14502" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14504" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14506" class="Symbol">)</a> <a id="14508" class="Symbol">(</a><a id="14509" href="Iterative.Sets.html#14509" class="Bound">ϕ</a> <a id="14511" class="Symbol">:</a> <a id="14513" href="Iterative.Sets.html#14498" class="Bound">X</a> <a id="14515" class="Symbol">→</a> <a id="14517" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14518" class="Symbol">)</a> <a id="14520" class="Symbol">(</a><a id="14521" href="Iterative.Sets.html#14521" class="Bound">e</a> <a id="14523" class="Symbol">:</a> <a id="14525" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14538" href="Iterative.Sets.html#14509" class="Bound">ϕ</a><a id="14539" class="Symbol">)</a>
 <a id="14542" class="Symbol">→</a> <a id="14544" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="14556" href="Iterative.Sets.html#14374" class="Bound">P</a> <a id="14558" href="Iterative.Sets.html#14392" class="Bound">f</a> <a id="14560" class="Symbol">(</a><a id="14561" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="14568" href="Iterative.Sets.html#14498" class="Bound">X</a> <a id="14570" href="Iterative.Sets.html#14509" class="Bound">ϕ</a> <a id="14572" href="Iterative.Sets.html#14521" class="Bound">e</a><a id="14573" class="Symbol">)</a> <a id="14575" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="14577" href="Iterative.Sets.html#14392" class="Bound">f</a> <a id="14579" href="Iterative.Sets.html#14498" class="Bound">X</a> <a id="14581" href="Iterative.Sets.html#14509" class="Bound">ϕ</a> <a id="14583" href="Iterative.Sets.html#14521" class="Bound">e</a> <a id="14585" class="Symbol">(λ</a> <a id="14588" href="Iterative.Sets.html#14588" class="Bound">x</a> <a id="14590" class="Symbol">→</a> <a id="14592" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="14604" href="Iterative.Sets.html#14374" class="Bound">P</a> <a id="14606" href="Iterative.Sets.html#14392" class="Bound">f</a> <a id="14608" class="Symbol">(</a><a id="14609" href="Iterative.Sets.html#14509" class="Bound">ϕ</a> <a id="14611" href="Iterative.Sets.html#14588" class="Bound">x</a><a id="14612" class="Symbol">))</a>
<a id="14615" href="Iterative.Sets.html#14348" class="Function">𝕍-induction-behaviour</a> <a id="14637" href="Iterative.Sets.html#14637" class="Bound">P</a> <a id="14639" href="Iterative.Sets.html#14639" class="Bound">f</a> <a id="14641" class="Symbol">=</a> <a id="14643" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="14647" class="Symbol">(</a><a id="14648" href="Iterative.Sets.html#12462" class="Function">𝕍-Induction</a> <a id="14660" href="Iterative.Sets.html#14637" class="Bound">P</a> <a id="14662" href="Iterative.Sets.html#14639" class="Bound">f</a><a id="14663" class="Symbol">)</a>

<a id="𝕍-recursion"></a><a id="14666" href="Iterative.Sets.html#14666" class="Function">𝕍-recursion</a> <a id="14678" class="Symbol">:</a> <a id="14680" class="Symbol">(</a><a id="14681" href="Iterative.Sets.html#14681" class="Bound">P</a> <a id="14683" class="Symbol">:</a> <a id="14685" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="14687" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14689" class="Symbol">)</a>
            <a id="14703" class="Symbol">→</a> <a id="14705" class="Symbol">((</a><a id="14707" href="Iterative.Sets.html#14707" class="Bound">X</a> <a id="14709" class="Symbol">:</a> <a id="14711" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14713" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14715" class="Symbol">)</a> <a id="14717" class="Symbol">(</a><a id="14718" href="Iterative.Sets.html#14718" class="Bound">ϕ</a> <a id="14720" class="Symbol">:</a> <a id="14722" href="Iterative.Sets.html#14707" class="Bound">X</a> <a id="14724" class="Symbol">→</a> <a id="14726" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14727" class="Symbol">)</a>
                  <a id="14747" class="Symbol">→</a> <a id="14749" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14762" href="Iterative.Sets.html#14718" class="Bound">ϕ</a>
                  <a id="14782" class="Symbol">→</a> <a id="14784" class="Symbol">(</a><a id="14785" href="Iterative.Sets.html#14707" class="Bound">X</a> <a id="14787" class="Symbol">→</a> <a id="14789" href="Iterative.Sets.html#14681" class="Bound">P</a><a id="14790" class="Symbol">)</a>
                  <a id="14810" class="Symbol">→</a> <a id="14812" href="Iterative.Sets.html#14681" class="Bound">P</a><a id="14813" class="Symbol">)</a>
            <a id="14827" class="Symbol">→</a> <a id="14829" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="14831" class="Symbol">→</a> <a id="14833" href="Iterative.Sets.html#14681" class="Bound">P</a>
<a id="14835" href="Iterative.Sets.html#14666" class="Function">𝕍-recursion</a> <a id="14847" href="Iterative.Sets.html#14847" class="Bound">P</a> <a id="14849" class="Symbol">=</a> <a id="14851" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="14863" class="Symbol">(λ</a> <a id="14866" href="Iterative.Sets.html#14866" class="Bound">_</a> <a id="14868" class="Symbol">→</a> <a id="14870" href="Iterative.Sets.html#14847" class="Bound">P</a><a id="14871" class="Symbol">)</a>

<a id="𝕍-recursion-behaviour"></a><a id="14874" href="Iterative.Sets.html#14874" class="Function">𝕍-recursion-behaviour</a>
 <a id="14897" class="Symbol">:</a> <a id="14899" class="Symbol">(</a><a id="14900" href="Iterative.Sets.html#14900" class="Bound">P</a> <a id="14902" class="Symbol">:</a> <a id="14904" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="14906" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14908" class="Symbol">)</a>
 <a id="14911" class="Symbol">→</a> <a id="14913" class="Symbol">(</a><a id="14914" href="Iterative.Sets.html#14914" class="Bound">f</a> <a id="14916" class="Symbol">:</a> <a id="14918" class="Symbol">(</a><a id="14919" href="Iterative.Sets.html#14919" class="Bound">X</a> <a id="14921" class="Symbol">:</a> <a id="14923" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14925" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="14927" class="Symbol">)</a> <a id="14929" class="Symbol">(</a><a id="14930" href="Iterative.Sets.html#14930" class="Bound">ϕ</a> <a id="14932" class="Symbol">:</a> <a id="14934" href="Iterative.Sets.html#14919" class="Bound">X</a> <a id="14936" class="Symbol">→</a> <a id="14938" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="14939" class="Symbol">)</a> <a id="14941" class="Symbol">(</a><a id="14942" href="Iterative.Sets.html#14942" class="Bound">e</a> <a id="14944" class="Symbol">:</a> <a id="14946" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="14959" href="Iterative.Sets.html#14930" class="Bound">ϕ</a><a id="14960" class="Symbol">)</a>
      <a id="14968" class="Symbol">→</a> <a id="14970" class="Symbol">(</a><a id="14971" href="Iterative.Sets.html#14919" class="Bound">X</a> <a id="14973" class="Symbol">→</a> <a id="14975" href="Iterative.Sets.html#14900" class="Bound">P</a><a id="14976" class="Symbol">)</a>
      <a id="14984" class="Symbol">→</a> <a id="14986" href="Iterative.Sets.html#14900" class="Bound">P</a><a id="14987" class="Symbol">)</a>
 <a id="14990" class="Symbol">→</a> <a id="14992" class="Symbol">(</a><a id="14993" href="Iterative.Sets.html#14993" class="Bound">X</a> <a id="14995" class="Symbol">:</a> <a id="14997" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="14999" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15001" class="Symbol">)</a> <a id="15003" class="Symbol">(</a><a id="15004" href="Iterative.Sets.html#15004" class="Bound">ϕ</a> <a id="15006" class="Symbol">:</a> <a id="15008" href="Iterative.Sets.html#14993" class="Bound">X</a> <a id="15010" class="Symbol">→</a> <a id="15012" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15013" class="Symbol">)</a> <a id="15015" class="Symbol">(</a><a id="15016" href="Iterative.Sets.html#15016" class="Bound">e</a> <a id="15018" class="Symbol">:</a> <a id="15020" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="15033" href="Iterative.Sets.html#15004" class="Bound">ϕ</a><a id="15034" class="Symbol">)</a>
 <a id="15037" class="Symbol">→</a> <a id="15039" href="Iterative.Sets.html#14666" class="Function">𝕍-recursion</a> <a id="15051" href="Iterative.Sets.html#14900" class="Bound">P</a> <a id="15053" href="Iterative.Sets.html#14914" class="Bound">f</a> <a id="15055" class="Symbol">(</a><a id="15056" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="15063" href="Iterative.Sets.html#14993" class="Bound">X</a> <a id="15065" href="Iterative.Sets.html#15004" class="Bound">ϕ</a> <a id="15067" href="Iterative.Sets.html#15016" class="Bound">e</a><a id="15068" class="Symbol">)</a> <a id="15070" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15072" href="Iterative.Sets.html#14914" class="Bound">f</a> <a id="15074" href="Iterative.Sets.html#14993" class="Bound">X</a> <a id="15076" href="Iterative.Sets.html#15004" class="Bound">ϕ</a> <a id="15078" href="Iterative.Sets.html#15016" class="Bound">e</a> <a id="15080" class="Symbol">(λ</a> <a id="15083" href="Iterative.Sets.html#15083" class="Bound">x</a> <a id="15085" class="Symbol">→</a> <a id="15087" href="Iterative.Sets.html#14666" class="Function">𝕍-recursion</a> <a id="15099" href="Iterative.Sets.html#14900" class="Bound">P</a> <a id="15101" href="Iterative.Sets.html#14914" class="Bound">f</a> <a id="15103" class="Symbol">(</a><a id="15104" href="Iterative.Sets.html#15004" class="Bound">ϕ</a> <a id="15106" href="Iterative.Sets.html#15083" class="Bound">x</a><a id="15107" class="Symbol">))</a>
<a id="15110" href="Iterative.Sets.html#14874" class="Function">𝕍-recursion-behaviour</a> <a id="15132" href="Iterative.Sets.html#15132" class="Bound">P</a> <a id="15134" class="Symbol">=</a> <a id="15136" href="Iterative.Sets.html#14348" class="Function">𝕍-induction-behaviour</a> <a id="15158" class="Symbol">(λ</a> <a id="15161" href="Iterative.Sets.html#15161" class="Bound">_</a> <a id="15163" class="Symbol">→</a> <a id="15165" href="Iterative.Sets.html#15132" class="Bound">P</a><a id="15166" class="Symbol">)</a>

<a id="𝕍-iteration"></a><a id="15169" href="Iterative.Sets.html#15169" class="Function">𝕍-iteration</a> <a id="15181" class="Symbol">:</a> <a id="15183" class="Symbol">(</a><a id="15184" href="Iterative.Sets.html#15184" class="Bound">P</a> <a id="15186" class="Symbol">:</a> <a id="15188" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="15190" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15192" class="Symbol">)</a>
            <a id="15206" class="Symbol">→</a> <a id="15208" class="Symbol">((</a><a id="15210" href="Iterative.Sets.html#15210" class="Bound">X</a> <a id="15212" class="Symbol">:</a> <a id="15214" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15216" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15218" class="Symbol">)</a> <a id="15220" class="Symbol">→</a> <a id="15222" class="Symbol">(</a><a id="15223" href="Iterative.Sets.html#15210" class="Bound">X</a> <a id="15225" class="Symbol">→</a> <a id="15227" href="Iterative.Sets.html#15184" class="Bound">P</a><a id="15228" class="Symbol">)</a> <a id="15230" class="Symbol">→</a> <a id="15232" href="Iterative.Sets.html#15184" class="Bound">P</a><a id="15233" class="Symbol">)</a>
            <a id="15247" class="Symbol">→</a> <a id="15249" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="15251" class="Symbol">→</a> <a id="15253" href="Iterative.Sets.html#15184" class="Bound">P</a>
<a id="15255" href="Iterative.Sets.html#15169" class="Function">𝕍-iteration</a> <a id="15267" href="Iterative.Sets.html#15267" class="Bound">P</a> <a id="15269" href="Iterative.Sets.html#15269" class="Bound">f</a> <a id="15271" class="Symbol">=</a> <a id="15273" href="Iterative.Sets.html#14666" class="Function">𝕍-recursion</a> <a id="15285" href="Iterative.Sets.html#15267" class="Bound">P</a> <a id="15287" class="Symbol">(λ</a> <a id="15290" href="Iterative.Sets.html#15290" class="Bound">X</a> <a id="15292" href="Iterative.Sets.html#15292" class="Bound">ϕ</a> <a id="15294" href="Iterative.Sets.html#15294" class="Bound">e</a> <a id="15296" class="Symbol">→</a> <a id="15298" href="Iterative.Sets.html#15269" class="Bound">f</a> <a id="15300" href="Iterative.Sets.html#15290" class="Bound">X</a><a id="15301" class="Symbol">)</a>

<a id="𝕍-iteration-behaviour"></a><a id="15304" href="Iterative.Sets.html#15304" class="Function">𝕍-iteration-behaviour</a>
 <a id="15327" class="Symbol">:</a> <a id="15329" class="Symbol">(</a><a id="15330" href="Iterative.Sets.html#15330" class="Bound">P</a> <a id="15332" class="Symbol">:</a> <a id="15334" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="15336" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15338" class="Symbol">)</a>
 <a id="15341" class="Symbol">→</a> <a id="15343" class="Symbol">(</a><a id="15344" href="Iterative.Sets.html#15344" class="Bound">f</a> <a id="15346" class="Symbol">:</a> <a id="15348" class="Symbol">(</a><a id="15349" href="Iterative.Sets.html#15349" class="Bound">X</a> <a id="15351" class="Symbol">:</a> <a id="15353" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15355" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15357" class="Symbol">)</a> <a id="15359" class="Symbol">→</a> <a id="15361" class="Symbol">(</a><a id="15362" href="Iterative.Sets.html#15349" class="Bound">X</a> <a id="15364" class="Symbol">→</a> <a id="15366" href="Iterative.Sets.html#15330" class="Bound">P</a><a id="15367" class="Symbol">)</a> <a id="15369" class="Symbol">→</a> <a id="15371" href="Iterative.Sets.html#15330" class="Bound">P</a><a id="15372" class="Symbol">)</a>
 <a id="15375" class="Symbol">→</a> <a id="15377" class="Symbol">(</a><a id="15378" href="Iterative.Sets.html#15378" class="Bound">X</a> <a id="15380" class="Symbol">:</a> <a id="15382" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15384" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15386" class="Symbol">)</a> <a id="15388" class="Symbol">(</a><a id="15389" href="Iterative.Sets.html#15389" class="Bound">ϕ</a> <a id="15391" class="Symbol">:</a> <a id="15393" href="Iterative.Sets.html#15378" class="Bound">X</a> <a id="15395" class="Symbol">→</a> <a id="15397" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15398" class="Symbol">)</a> <a id="15400" class="Symbol">(</a><a id="15401" href="Iterative.Sets.html#15401" class="Bound">e</a> <a id="15403" class="Symbol">:</a> <a id="15405" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="15418" href="Iterative.Sets.html#15389" class="Bound">ϕ</a><a id="15419" class="Symbol">)</a>
 <a id="15422" class="Symbol">→</a> <a id="15424" href="Iterative.Sets.html#15169" class="Function">𝕍-iteration</a> <a id="15436" href="Iterative.Sets.html#15330" class="Bound">P</a> <a id="15438" href="Iterative.Sets.html#15344" class="Bound">f</a> <a id="15440" class="Symbol">(</a><a id="15441" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="15448" href="Iterative.Sets.html#15378" class="Bound">X</a> <a id="15450" href="Iterative.Sets.html#15389" class="Bound">ϕ</a> <a id="15452" href="Iterative.Sets.html#15401" class="Bound">e</a><a id="15453" class="Symbol">)</a> <a id="15455" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="15457" href="Iterative.Sets.html#15344" class="Bound">f</a> <a id="15459" href="Iterative.Sets.html#15378" class="Bound">X</a> <a id="15461" class="Symbol">(λ</a> <a id="15464" href="Iterative.Sets.html#15464" class="Bound">x</a> <a id="15466" class="Symbol">→</a> <a id="15468" href="Iterative.Sets.html#15169" class="Function">𝕍-iteration</a> <a id="15480" href="Iterative.Sets.html#15330" class="Bound">P</a> <a id="15482" href="Iterative.Sets.html#15344" class="Bound">f</a> <a id="15484" class="Symbol">(</a><a id="15485" href="Iterative.Sets.html#15389" class="Bound">ϕ</a> <a id="15487" href="Iterative.Sets.html#15464" class="Bound">x</a><a id="15488" class="Symbol">))</a>
<a id="15491" href="Iterative.Sets.html#15304" class="Function">𝕍-iteration-behaviour</a> <a id="15513" href="Iterative.Sets.html#15513" class="Bound">P</a> <a id="15515" href="Iterative.Sets.html#15515" class="Bound">f</a> <a id="15517" class="Symbol">=</a> <a id="15519" href="Iterative.Sets.html#14874" class="Function">𝕍-recursion-behaviour</a> <a id="15541" href="Iterative.Sets.html#15513" class="Bound">P</a> <a id="15543" class="Symbol">(λ</a> <a id="15546" href="Iterative.Sets.html#15546" class="Bound">X</a> <a id="15548" href="Iterative.Sets.html#15548" class="Bound">ϕ</a> <a id="15550" href="Iterative.Sets.html#15550" class="Bound">e</a> <a id="15552" class="Symbol">→</a> <a id="15554" href="Iterative.Sets.html#15515" class="Bound">f</a> <a id="15556" href="Iterative.Sets.html#15546" class="Bound">X</a><a id="15557" class="Symbol">)</a>

<a id="15560" class="Markup">\end{code}</a><a id="15570" class="Background">

So we are essentially working with (an encoding) of the above
non-strictly positive data type.

The usual induction principle for iterative sets follows directly from
the above form of induction. This consequence is already in Gylterud [4].

</a><a id="15814" class="Markup">\begin{code}</a>

<a id="∈-induction"></a><a id="15828" href="Iterative.Sets.html#15828" class="Function">∈-induction</a> <a id="15840" class="Symbol">:</a> <a id="15842" class="Symbol">(</a><a id="15843" href="Iterative.Sets.html#15843" class="Bound">P</a> <a id="15845" class="Symbol">:</a> <a id="15847" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="15849" class="Symbol">→</a> <a id="15851" href="MLTT.Universes.html#3836" class="Generalizable">𝓥</a> <a id="15853" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15855" class="Symbol">)</a>
            <a id="15869" class="Symbol">→</a> <a id="15871" class="Symbol">((</a><a id="15873" href="Iterative.Sets.html#15873" class="Bound">A</a> <a id="15875" class="Symbol">:</a> <a id="15877" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15878" class="Symbol">)</a> <a id="15880" class="Symbol">→</a> <a id="15882" class="Symbol">((</a><a id="15884" href="Iterative.Sets.html#15884" class="Bound">B</a> <a id="15886" class="Symbol">:</a> <a id="15888" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15889" class="Symbol">)</a> <a id="15891" class="Symbol">→</a> <a id="15893" href="Iterative.Sets.html#15884" class="Bound">B</a> <a id="15895" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="15897" href="Iterative.Sets.html#15873" class="Bound">A</a> <a id="15899" class="Symbol">→</a> <a id="15901" href="Iterative.Sets.html#15843" class="Bound">P</a> <a id="15903" href="Iterative.Sets.html#15884" class="Bound">B</a><a id="15904" class="Symbol">)</a> <a id="15906" class="Symbol">→</a> <a id="15908" href="Iterative.Sets.html#15843" class="Bound">P</a> <a id="15910" href="Iterative.Sets.html#15873" class="Bound">A</a><a id="15911" class="Symbol">)</a>
            <a id="15925" class="Symbol">→</a> <a id="15927" class="Symbol">(</a><a id="15928" href="Iterative.Sets.html#15928" class="Bound">A</a> <a id="15930" class="Symbol">:</a> <a id="15932" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="15933" class="Symbol">)</a> <a id="15935" class="Symbol">→</a> <a id="15937" href="Iterative.Sets.html#15843" class="Bound">P</a> <a id="15939" href="Iterative.Sets.html#15928" class="Bound">A</a>
<a id="15941" href="Iterative.Sets.html#15828" class="Function">∈-induction</a> <a id="15953" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="15955" href="Iterative.Sets.html#15955" class="Bound">IH</a> <a id="15958" class="Symbol">=</a> <a id="15960" href="Iterative.Sets.html#14113" class="Function">𝕍-induction</a> <a id="15972" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="15974" href="Iterative.Sets.html#15985" class="Function">f</a>
 <a id="15977" class="Keyword">where</a>
  <a id="15985" href="Iterative.Sets.html#15985" class="Function">f</a> <a id="15987" class="Symbol">:</a> <a id="15989" class="Symbol">(</a><a id="15990" href="Iterative.Sets.html#15990" class="Bound">X</a> <a id="15992" class="Symbol">:</a> <a id="15994" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="15996" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="15998" class="Symbol">)</a> <a id="16000" class="Symbol">(</a><a id="16001" href="Iterative.Sets.html#16001" class="Bound">ϕ</a> <a id="16003" class="Symbol">:</a> <a id="16005" href="Iterative.Sets.html#15990" class="Bound">X</a> <a id="16007" class="Symbol">→</a> <a id="16009" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16010" class="Symbol">)</a> <a id="16012" class="Symbol">(</a><a id="16013" href="Iterative.Sets.html#16013" class="Bound">e</a> <a id="16015" class="Symbol">:</a> <a id="16017" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="16030" href="Iterative.Sets.html#16001" class="Bound">ϕ</a><a id="16031" class="Symbol">)</a>
    <a id="16037" class="Symbol">→</a> <a id="16039" class="Symbol">((</a><a id="16041" href="Iterative.Sets.html#16041" class="Bound">x</a> <a id="16043" class="Symbol">:</a> <a id="16045" href="Iterative.Sets.html#15990" class="Bound">X</a><a id="16046" class="Symbol">)</a> <a id="16048" class="Symbol">→</a> <a id="16050" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16052" class="Symbol">(</a><a id="16053" href="Iterative.Sets.html#16001" class="Bound">ϕ</a> <a id="16055" href="Iterative.Sets.html#16041" class="Bound">x</a><a id="16056" class="Symbol">))</a>
    <a id="16063" class="Symbol">→</a> <a id="16065" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16067" class="Symbol">(</a><a id="16068" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16075" href="Iterative.Sets.html#15990" class="Bound">X</a> <a id="16077" href="Iterative.Sets.html#16001" class="Bound">ϕ</a> <a id="16079" href="Iterative.Sets.html#16013" class="Bound">e</a><a id="16080" class="Symbol">)</a>
  <a id="16084" href="Iterative.Sets.html#15985" class="Function">f</a> <a id="16086" href="Iterative.Sets.html#16086" class="Bound">X</a> <a id="16088" href="Iterative.Sets.html#16088" class="Bound">ϕ</a> <a id="16090" href="Iterative.Sets.html#16090" class="Bound">e</a> <a id="16092" href="Iterative.Sets.html#16092" class="Bound">IH&#39;</a> <a id="16096" class="Symbol">=</a> <a id="16098" href="Iterative.Sets.html#15955" class="Bound">IH</a> <a id="16101" href="Iterative.Sets.html#16118" class="Function">A</a> <a id="16103" href="Iterative.Sets.html#16150" class="Function">s</a>
   <a id="16108" class="Keyword">where</a>
    <a id="16118" href="Iterative.Sets.html#16118" class="Function">A</a> <a id="16120" class="Symbol">:</a> <a id="16122" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="16128" href="Iterative.Sets.html#16118" class="Function">A</a> <a id="16130" class="Symbol">=</a> <a id="16132" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16139" href="Iterative.Sets.html#16086" class="Bound">X</a> <a id="16141" href="Iterative.Sets.html#16088" class="Bound">ϕ</a> <a id="16143" href="Iterative.Sets.html#16090" class="Bound">e</a>

    <a id="16150" href="Iterative.Sets.html#16150" class="Function">s</a> <a id="16152" class="Symbol">:</a> <a id="16154" class="Symbol">(</a><a id="16155" href="Iterative.Sets.html#16155" class="Bound">B</a> <a id="16157" class="Symbol">:</a> <a id="16159" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16160" class="Symbol">)</a> <a id="16162" class="Symbol">→</a> <a id="16164" href="Iterative.Sets.html#16155" class="Bound">B</a> <a id="16166" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16168" href="Iterative.Sets.html#16118" class="Function">A</a> <a id="16170" class="Symbol">→</a> <a id="16172" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16174" href="Iterative.Sets.html#16155" class="Bound">B</a>
    <a id="16180" href="Iterative.Sets.html#16150" class="Function">s</a> <a id="16182" href="Iterative.Sets.html#16182" class="Bound">B</a><a id="16183" class="Symbol">@(</a><a id="16185" class="DottedPattern Symbol">.(</a><a id="16187" href="Iterative.Sets.html#2892" class="DottedPattern Function">underlying-mset</a> <a id="16203" class="DottedPattern Symbol">(</a><a id="16204" href="Iterative.Sets.html#16088" class="DottedPattern Bound">ϕ</a> <a id="16206" href="Iterative.Sets.html#16216" class="DottedPattern Bound">x</a><a id="16207" class="DottedPattern Symbol">))</a> <a id="16210" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16212" href="Iterative.Sets.html#16212" class="Bound">j</a><a id="16213" class="Symbol">)</a> <a id="16215" class="Symbol">(</a><a id="16216" href="Iterative.Sets.html#16216" class="Bound">x</a> <a id="16218" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16220" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="16224" class="Symbol">)</a> <a id="16226" class="Symbol">=</a> <a id="16228" href="Iterative.Sets.html#16283" class="Function">II</a>
     <a id="16236" class="Keyword">where</a>
      <a id="16248" href="Iterative.Sets.html#16248" class="Function">I</a> <a id="16250" class="Symbol">:</a> <a id="16252" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16254" class="Symbol">(</a><a id="16255" href="Iterative.Sets.html#16088" class="Bound">ϕ</a> <a id="16257" href="Iterative.Sets.html#16216" class="Bound">x</a><a id="16258" class="Symbol">)</a>
      <a id="16266" href="Iterative.Sets.html#16248" class="Function">I</a> <a id="16268" class="Symbol">=</a> <a id="16270" href="Iterative.Sets.html#16092" class="Bound">IH&#39;</a> <a id="16274" href="Iterative.Sets.html#16216" class="Bound">x</a>

      <a id="16283" href="Iterative.Sets.html#16283" class="Function">II</a> <a id="16286" class="Symbol">:</a> <a id="16288" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16290" class="Symbol">(</a><a id="16291" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="16307" class="Symbol">(</a><a id="16308" href="Iterative.Sets.html#16088" class="Bound">ϕ</a> <a id="16310" href="Iterative.Sets.html#16216" class="Bound">x</a><a id="16311" class="Symbol">)</a> <a id="16313" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="16315" href="Iterative.Sets.html#16212" class="Bound">j</a><a id="16316" class="Symbol">)</a>
      <a id="16324" href="Iterative.Sets.html#16283" class="Function">II</a> <a id="16327" class="Symbol">=</a> <a id="16329" href="MLTT.Id.html#735" class="Function">transport</a> <a id="16339" href="Iterative.Sets.html#15953" class="Bound">P</a> <a id="16341" class="Symbol">(</a><a id="16342" href="UF.Subsingletons.html#4964" class="Function">to-subtype-＝</a> <a id="16355" href="Iterative.Sets.html#2308" class="Function">being-iset-is-prop</a> <a id="16374" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="16378" class="Symbol">)</a> <a id="16380" href="Iterative.Sets.html#16248" class="Function">I</a>

<a id="16383" class="Markup">\end{code}</a><a id="16393" class="Background">

And then it follows immediately that the membership relation is
accessible:

</a><a id="16472" class="Markup">\begin{code}</a>

<a id="∈-is-accessible"></a><a id="16486" href="Iterative.Sets.html#16486" class="Function">∈-is-accessible</a> <a id="16502" class="Symbol">:</a> <a id="16504" class="Symbol">(</a><a id="16505" href="Iterative.Sets.html#16505" class="Bound">A</a> <a id="16507" class="Symbol">:</a> <a id="16509" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16510" class="Symbol">)</a> <a id="16512" class="Symbol">→</a> <a id="16514" href="Ordinals.Notions.html#713" class="Datatype">is-accessible</a> <a id="16528" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a> <a id="16532" href="Iterative.Sets.html#16505" class="Bound">A</a>
<a id="16534" href="Iterative.Sets.html#16486" class="Function">∈-is-accessible</a> <a id="16550" class="Symbol">=</a> <a id="16552" href="Iterative.Sets.html#15828" class="Function">∈-induction</a> <a id="16564" class="Symbol">(</a><a id="16565" href="Ordinals.Notions.html#713" class="Datatype">is-accessible</a> <a id="16579" href="Iterative.Sets.html#4193" class="Function Operator">_∈_</a><a id="16582" class="Symbol">)</a> <a id="16584" class="Symbol">(λ</a> <a id="16587" href="Iterative.Sets.html#16587" class="Bound">_</a> <a id="16589" class="Symbol">→</a> <a id="16591" href="Ordinals.Notions.html#748" class="InductiveConstructor">acc</a><a id="16594" class="Symbol">)</a>

<a id="16597" class="Markup">\end{code}</a><a id="16607" class="Background">

Singleton sets can be constructed as follows.

</a><a id="16656" class="Markup">\begin{code}</a>

<a id="❴_❵"></a><a id="16670" href="Iterative.Sets.html#16670" class="Function Operator">❴_❵</a> <a id="16674" class="Symbol">:</a> <a id="16676" class="Symbol">(</a><a id="16677" href="Iterative.Sets.html#16677" class="Bound">A</a> <a id="16679" class="Symbol">:</a> <a id="16681" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16682" class="Symbol">)</a> <a id="16684" class="Symbol">→</a> <a id="16686" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
<a id="16688" href="Iterative.Sets.html#16670" class="Function Operator">❴</a> <a id="16690" href="Iterative.Sets.html#16690" class="Bound">A</a> <a id="16692" href="Iterative.Sets.html#16670" class="Function Operator">❵</a> <a id="16694" class="Symbol">=</a> <a id="16696" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="16703" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="16705" class="Symbol">(λ</a> <a id="16708" href="Iterative.Sets.html#16708" class="Bound">_</a> <a id="16710" class="Symbol">→</a> <a id="16712" href="Iterative.Sets.html#16690" class="Bound">A</a><a id="16713" class="Symbol">)</a> <a id="16715" class="Symbol">(</a><a id="16716" href="UF.DiscreteAndSeparated.html#24616" class="Function">global-point-is-embedding</a> <a id="16742" class="Symbol">(λ</a> <a id="16745" href="Iterative.Sets.html#16745" class="Bound">_</a> <a id="16747" class="Symbol">→</a> <a id="16749" href="Iterative.Sets.html#16690" class="Bound">A</a><a id="16750" class="Symbol">)</a> <a id="16752" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a><a id="16760" class="Symbol">)</a>

<a id="❴❵-behaviour"></a><a id="16763" href="Iterative.Sets.html#16763" class="Function">❴❵-behaviour</a> <a id="16776" class="Symbol">:</a> <a id="16778" class="Symbol">(</a><a id="16779" href="Iterative.Sets.html#16779" class="Bound">A</a> <a id="16781" class="Symbol">:</a> <a id="16783" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16784" class="Symbol">)</a> <a id="16786" class="Symbol">(</a><a id="16787" href="Iterative.Sets.html#16787" class="Bound">B</a> <a id="16789" class="Symbol">:</a> <a id="16791" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="16792" class="Symbol">)</a> <a id="16794" class="Symbol">→</a> <a id="16796" href="Iterative.Sets.html#16787" class="Bound">B</a> <a id="16798" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16800" href="Iterative.Sets.html#16670" class="Function Operator">❴</a> <a id="16802" href="Iterative.Sets.html#16779" class="Bound">A</a> <a id="16804" href="Iterative.Sets.html#16670" class="Function Operator">❵</a> <a id="16806" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="16808" class="Symbol">(</a><a id="16809" href="Iterative.Sets.html#16787" class="Bound">B</a> <a id="16811" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16813" href="Iterative.Sets.html#16779" class="Bound">A</a><a id="16814" class="Symbol">)</a>
<a id="16816" href="Iterative.Sets.html#16763" class="Function">❴❵-behaviour</a> <a id="16829" href="Iterative.Sets.html#16829" class="Bound">A</a> <a id="16831" href="Iterative.Sets.html#16831" class="Bound">B</a> <a id="16833" class="Symbol">=</a> <a id="16835" href="Iterative.Sets.html#16831" class="Bound">B</a> <a id="16837" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="16839" href="Iterative.Sets.html#16670" class="Function Operator">❴</a> <a id="16841" href="Iterative.Sets.html#16829" class="Bound">A</a> <a id="16843" href="Iterative.Sets.html#16670" class="Function Operator">❵</a>    <a id="16848" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16851" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="16864" href="Iterative.Sets.html#16831" class="Bound">B</a> <a id="16866" href="Iterative.Sets.html#16670" class="Function Operator">❴</a> <a id="16868" href="Iterative.Sets.html#16829" class="Bound">A</a> <a id="16870" href="Iterative.Sets.html#16670" class="Function Operator">❵</a> <a id="16872" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16893" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="16895" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="16897" class="Symbol">(</a><a id="16898" href="Iterative.Sets.html#16829" class="Bound">A</a> <a id="16900" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16902" href="Iterative.Sets.html#16831" class="Bound">B</a><a id="16903" class="Symbol">)</a> <a id="16905" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16908" href="UF.EquivalenceExamples.html#7420" class="Function">𝟙-lneutral</a> <a id="16919" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16940" class="Symbol">(</a><a id="16941" href="Iterative.Sets.html#16829" class="Bound">A</a> <a id="16943" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16945" href="Iterative.Sets.html#16831" class="Bound">B</a><a id="16946" class="Symbol">)</a>     <a id="16952" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="16955" href="UF.EquivalenceExamples.html#25145" class="Function">＝-flip</a> <a id="16962" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
                   <a id="16983" class="Symbol">(</a><a id="16984" href="Iterative.Sets.html#16831" class="Bound">B</a> <a id="16986" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="16988" href="Iterative.Sets.html#16829" class="Bound">A</a><a id="16989" class="Symbol">)</a>     <a id="16995" href="UF.Equiv.html#2815" class="Function Operator">■</a>

<a id="16998" class="Markup">\end{code}</a><a id="17008" class="Background">

Given a family of iterative sets indexed by a small type, we construct
its union as in [4].

We make use of propositional truncations (to define the image of a
map) and of set replacement (which follows from having set quotients).

</a><a id="17242" class="Markup">\begin{code}</a>

<a id="17256" class="Keyword">open</a> <a id="17261" class="Keyword">import</a> <a id="17268" href="UF.PropTrunc.html" class="Module">UF.PropTrunc</a>

<a id="17282" class="Keyword">module</a> <a id="17289" href="Iterative.Sets.html#17289" class="Module">_</a> <a id="17291" class="Symbol">(</a><a id="17292" href="Iterative.Sets.html#17292" class="Bound">pt</a> <a id="17295" class="Symbol">:</a> <a id="17297" href="UF.PropTrunc.html#486" class="Record">propositional-truncations-exist</a><a id="17328" class="Symbol">)</a> <a id="17330" class="Keyword">where</a>

 <a id="17338" class="Keyword">open</a> <a id="17343" href="UF.PropTrunc.html#792" class="Module">PropositionalTruncation</a> <a id="17367" href="Iterative.Sets.html#17292" class="Bound">pt</a>
 <a id="17371" class="Keyword">open</a> <a id="17376" class="Keyword">import</a> <a id="17383" href="UF.ImageAndSurjection.html" class="Module">UF.ImageAndSurjection</a> <a id="17405" href="Iterative.Sets.html#17292" class="Bound">pt</a>

 <a id="17410" class="Keyword">module</a> <a id="17417" href="Iterative.Sets.html#17417" class="Module">unions-of-iterative-sets</a> <a id="17442" class="Symbol">(</a><a id="17443" href="Iterative.Sets.html#17443" class="Bound">sr</a> <a id="17446" class="Symbol">:</a> <a id="17448" href="UF.Size.html#33129" class="Function">Set-Replacement</a> <a id="17464" href="Iterative.Sets.html#17292" class="Bound">pt</a><a id="17466" class="Symbol">)</a> <a id="17468" class="Keyword">where</a>

  <a id="17477" class="Keyword">private</a>
   <a id="17488" class="Keyword">module</a> <a id="17495" href="Iterative.Sets.html#17495" class="Module">union-construction</a>
          <a id="17524" class="Symbol">{</a><a id="17525" href="Iterative.Sets.html#17525" class="Bound">I</a> <a id="17527" class="Symbol">:</a> <a id="17529" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17531" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="17533" class="Symbol">}</a>
          <a id="17545" class="Symbol">(</a><a id="17546" href="Iterative.Sets.html#17546" class="Bound">𝓐</a> <a id="17548" class="Symbol">:</a> <a id="17550" href="Iterative.Sets.html#17525" class="Bound">I</a> <a id="17552" class="Symbol">→</a> <a id="17554" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="17555" class="Symbol">)</a>
         <a id="17566" class="Keyword">where</a>

    <a id="17577" href="Iterative.Sets.html#17577" class="Function">im</a> <a id="17580" class="Symbol">:</a> <a id="17582" href="Iterative.Sets.html#869" class="Function">𝓤⁺</a> <a id="17585" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
    <a id="17591" href="Iterative.Sets.html#17577" class="Function">im</a> <a id="17594" class="Symbol">=</a> <a id="17596" href="UF.ImageAndSurjection.html#939" class="Function">image</a> <a id="17602" href="Iterative.Sets.html#17546" class="Bound">𝓐</a>

    <a id="17609" href="Iterative.Sets.html#17609" class="Function">im-is-small</a> <a id="17621" class="Symbol">:</a> <a id="17623" href="UF.ImageAndSurjection.html#939" class="Function">image</a> <a id="17629" href="Iterative.Sets.html#17546" class="Bound">𝓐</a> <a id="17631" href="UF.Size.html#2097" class="Function Operator">is</a> <a id="17634" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17636" href="UF.Size.html#2097" class="Function Operator">small</a>
    <a id="17646" href="Iterative.Sets.html#17609" class="Function">im-is-small</a> <a id="17658" class="Symbol">=</a> <a id="17660" href="Iterative.Sets.html#17443" class="Bound">sr</a> <a id="17663" href="Iterative.Sets.html#17546" class="Bound">𝓐</a> <a id="17665" class="Symbol">(</a><a id="17666" href="Iterative.Sets.html#17525" class="Bound">I</a> <a id="17668" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="17670" href="UF.Equiv.html#1517" class="Function">≃-refl</a> <a id="17677" href="Iterative.Sets.html#17525" class="Bound">I</a><a id="17678" class="Symbol">)</a> <a id="17680" href="Iterative.Sets.html#2637" class="Function">𝕍-is-locally-small</a> <a id="17699" href="Iterative.Sets.html#6891" class="Function">𝕍-is-set</a>

    <a id="17713" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="17717" class="Symbol">:</a> <a id="17719" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="17721" href="MLTT.Universes.html#3977" class="Function Operator">̇</a>
    <a id="17727" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="17731" class="Symbol">=</a> <a id="17733" href="UF.Size.html#2247" class="Function">resized</a> <a id="17741" href="Iterative.Sets.html#17577" class="Function">im</a> <a id="17744" href="Iterative.Sets.html#17609" class="Function">im-is-small</a>

    <a id="17761" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a> <a id="17770" class="Symbol">:</a> <a id="17772" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="17776" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="17778" href="Iterative.Sets.html#17577" class="Function">im</a>
    <a id="17785" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a> <a id="17794" class="Symbol">=</a> <a id="17796" href="UF.Size.html#2306" class="Function">resizing-condition</a> <a id="17815" href="Iterative.Sets.html#17609" class="Function">im-is-small</a>

    <a id="17832" href="Iterative.Sets.html#17832" class="Function">π</a> <a id="17834" class="Symbol">:</a> <a id="17836" href="Iterative.Sets.html#17577" class="Function">im</a> <a id="17839" class="Symbol">→</a> <a id="17841" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="17847" href="Iterative.Sets.html#17832" class="Function">π</a> <a id="17849" class="Symbol">=</a> <a id="17851" href="UF.ImageAndSurjection.html#1030" class="Function">restriction</a> <a id="17863" href="Iterative.Sets.html#17546" class="Bound">𝓐</a>

    <a id="17870" href="Iterative.Sets.html#17870" class="Function">π⁻</a> <a id="17873" class="Symbol">:</a> <a id="17875" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="17879" class="Symbol">→</a> <a id="17881" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
    <a id="17887" href="Iterative.Sets.html#17870" class="Function">π⁻</a> <a id="17890" class="Symbol">=</a> <a id="17892" href="Iterative.Sets.html#17832" class="Function">π</a> <a id="17894" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="17896" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="17898" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a> <a id="17907" href="UF.Equiv.html#2933" class="Function Operator">⌝</a>

    <a id="17914" href="Iterative.Sets.html#17914" class="Function">π-is-embedding</a> <a id="17929" class="Symbol">:</a> <a id="17931" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="17944" href="Iterative.Sets.html#17832" class="Function">π</a>
    <a id="17950" href="Iterative.Sets.html#17914" class="Function">π-is-embedding</a> <a id="17965" class="Symbol">=</a> <a id="17967" href="UF.ImageAndSurjection.html#1395" class="Function">restrictions-are-embeddings</a> <a id="17995" href="Iterative.Sets.html#17546" class="Bound">𝓐</a>

    <a id="18002" href="Iterative.Sets.html#18002" class="Function">π⁻-is-embedding</a> <a id="18018" class="Symbol">:</a> <a id="18020" href="UF.Embeddings.html#592" class="Function">is-embedding</a> <a id="18033" href="Iterative.Sets.html#17870" class="Function">π⁻</a>
    <a id="18040" href="Iterative.Sets.html#18002" class="Function">π⁻-is-embedding</a> <a id="18056" class="Symbol">=</a> <a id="18058" href="UF.Embeddings.html#1109" class="Function">∘-is-embedding</a>
                       <a id="18096" class="Symbol">(</a><a id="18097" href="UF.Embeddings.html#3426" class="Function">equivs-are-embeddings</a>
                         <a id="18144" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="18146" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a> <a id="18155" href="UF.Equiv.html#2933" class="Function Operator">⌝</a>
                         <a id="18182" class="Symbol">(</a><a id="18183" href="UF.Equiv.html#3027" class="Function">⌜⌝-is-equiv</a> <a id="18195" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a><a id="18203" class="Symbol">))</a>
                       <a id="18229" href="Iterative.Sets.html#17914" class="Function">π-is-embedding</a>

  <a id="18247" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="18249" class="Symbol">:</a> <a id="18251" class="Symbol">{</a><a id="18252" href="Iterative.Sets.html#18252" class="Bound">I</a> <a id="18254" class="Symbol">:</a> <a id="18256" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="18258" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="18260" class="Symbol">}</a> <a id="18262" class="Symbol">(</a><a id="18263" href="Iterative.Sets.html#18263" class="Bound">𝓐</a> <a id="18265" class="Symbol">:</a> <a id="18267" href="Iterative.Sets.html#18252" class="Bound">I</a> <a id="18269" class="Symbol">→</a> <a id="18271" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18272" class="Symbol">)</a> <a id="18274" class="Symbol">→</a> <a id="18276" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
  <a id="18280" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="18282" class="Symbol">{</a><a id="18283" href="Iterative.Sets.html#18283" class="Bound">I</a><a id="18284" class="Symbol">}</a> <a id="18286" href="Iterative.Sets.html#18286" class="Bound">𝓐</a> <a id="18288" class="Symbol">=</a> <a id="18290" href="Iterative.Sets.html#9016" class="Function">𝕍-ssup</a> <a id="18297" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="18301" href="Iterative.Sets.html#17870" class="Function">π⁻</a> <a id="18304" href="Iterative.Sets.html#18002" class="Function">π⁻-is-embedding</a>
   <a id="18323" class="Keyword">where</a>
    <a id="18333" class="Keyword">open</a> <a id="18338" href="Iterative.Sets.html#17495" class="Module">union-construction</a> <a id="18357" href="Iterative.Sets.html#18286" class="Bound">𝓐</a>

  <a id="18362" href="Iterative.Sets.html#18362" class="Function">⋃-behaviour</a> <a id="18374" class="Symbol">:</a> <a id="18376" class="Symbol">{</a><a id="18377" href="Iterative.Sets.html#18377" class="Bound">I</a> <a id="18379" class="Symbol">:</a> <a id="18381" href="Iterative.Sets.html#784" class="Bound">𝓤</a> <a id="18383" href="MLTT.Universes.html#3977" class="Function Operator">̇</a> <a id="18385" class="Symbol">}</a> <a id="18387" class="Symbol">(</a><a id="18388" href="Iterative.Sets.html#18388" class="Bound">𝓐</a> <a id="18390" class="Symbol">:</a> <a id="18392" href="Iterative.Sets.html#18377" class="Bound">I</a> <a id="18394" class="Symbol">→</a> <a id="18396" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18397" class="Symbol">)</a> <a id="18399" class="Symbol">(</a><a id="18400" href="Iterative.Sets.html#18400" class="Bound">B</a> <a id="18402" class="Symbol">:</a> <a id="18404" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="18405" class="Symbol">)</a>
              <a id="18421" class="Symbol">→</a> <a id="18423" href="Iterative.Sets.html#18400" class="Bound">B</a> <a id="18425" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="18427" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="18429" href="Iterative.Sets.html#18388" class="Bound">𝓐</a> <a id="18431" href="UF.Equiv.html#1318" class="Function Operator">≃</a> <a id="18433" class="Symbol">(</a><a id="18434" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18436" href="Iterative.Sets.html#18436" class="Bound">i</a> <a id="18438" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="18440" href="Iterative.Sets.html#18377" class="Bound">I</a> <a id="18442" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="18444" href="Iterative.Sets.html#18400" class="Bound">B</a> <a id="18446" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18448" href="Iterative.Sets.html#18388" class="Bound">𝓐</a> <a id="18450" href="Iterative.Sets.html#18436" class="Bound">i</a><a id="18451" class="Symbol">)</a>
  <a id="18455" href="Iterative.Sets.html#18362" class="Function">⋃-behaviour</a> <a id="18467" class="Symbol">{</a><a id="18468" href="Iterative.Sets.html#18468" class="Bound">I</a><a id="18469" class="Symbol">}</a> <a id="18471" href="Iterative.Sets.html#18471" class="Bound">𝓐</a> <a id="18473" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="18475" class="Symbol">=</a>
   <a id="18480" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="18482" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="18484" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="18486" href="Iterative.Sets.html#18471" class="Bound">𝓐</a>                                    <a id="18523" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18526" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="18539" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="18541" class="Symbol">(</a><a id="18542" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="18544" href="Iterative.Sets.html#18471" class="Bound">𝓐</a><a id="18545" class="Symbol">)</a> <a id="18547" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18552" class="Symbol">(</a><a id="18553" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18555" href="Iterative.Sets.html#18555" class="Bound">j</a> <a id="18557" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18559" href="Iterative.Sets.html#17713" class="Function">im⁻</a> <a id="18563" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18565" href="Iterative.Sets.html#17870" class="Function">π⁻</a> <a id="18568" href="Iterative.Sets.html#18555" class="Bound">j</a> <a id="18570" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18572" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="18573" class="Symbol">)</a>                    <a id="18594" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18597" href="Iterative.Sets.html#19086" class="Function">e₁</a> <a id="18600" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18605" class="Symbol">(</a><a id="18606" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18608" href="Iterative.Sets.html#18608" class="Bound">j</a> <a id="18610" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18612" href="Iterative.Sets.html#17577" class="Function">im</a> <a id="18615" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18617" href="Iterative.Sets.html#17832" class="Function">π</a> <a id="18619" href="Iterative.Sets.html#18608" class="Bound">j</a> <a id="18621" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18623" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="18624" class="Symbol">)</a>                      <a id="18647" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18650" href="UF.EquivalenceExamples.html#2025" class="Function">Σ-assoc</a> <a id="18658" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18663" class="Symbol">(</a><a id="18664" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18666" href="Iterative.Sets.html#18666" class="Bound">C</a> <a id="18668" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18670" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="18672" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18674" href="Iterative.Sets.html#18666" class="Bound">C</a> <a id="18676" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18683" href="Iterative.Sets.html#18471" class="Bound">𝓐</a> <a id="18685" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18687" class="Symbol">(</a><a id="18688" href="Iterative.Sets.html#18666" class="Bound">C</a> <a id="18690" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18692" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="18693" class="Symbol">))</a>          <a id="18705" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18708" href="UF.EquivalenceExamples.html#3378" class="Function">Σ-cong</a> <a id="18715" class="Symbol">(λ</a> <a id="18718" href="Iterative.Sets.html#18718" class="Bound">C</a> <a id="18720" class="Symbol">→</a> <a id="18722" href="UF.EquivalenceExamples.html#7682" class="Function">×-comm</a><a id="18728" class="Symbol">)</a> <a id="18730" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18735" class="Symbol">(</a><a id="18736" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18738" href="Iterative.Sets.html#18738" class="Bound">C</a> <a id="18740" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18742" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="18744" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18746" class="Symbol">(</a><a id="18747" href="Iterative.Sets.html#18738" class="Bound">C</a> <a id="18749" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18751" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="18752" class="Symbol">)</a> <a id="18754" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18756" class="Symbol">(</a><a id="18757" href="Iterative.Sets.html#18738" class="Bound">C</a> <a id="18759" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18766" href="Iterative.Sets.html#18471" class="Bound">𝓐</a><a id="18767" class="Symbol">))</a>        <a id="18777" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18780" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="18786" href="UF.EquivalenceExamples.html#2025" class="Function">Σ-assoc</a> <a id="18794" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18799" class="Symbol">(</a><a id="18800" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="18802" href="Iterative.Sets.html#18802" class="Bound">s</a> <a id="18804" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="18806" href="UF.Subsingletons.html#3951" class="Function">singleton-type&#39;</a> <a id="18822" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="18824" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="18826" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="18830" href="Iterative.Sets.html#18802" class="Bound">s</a> <a id="18832" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18839" href="Iterative.Sets.html#18471" class="Bound">𝓐</a><a id="18840" class="Symbol">)</a> <a id="18842" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18845" href="UF.Equiv.html#7797" class="Function">≃-sym</a> <a id="18851" href="Iterative.Sets.html#19130" class="Function">e₂</a> <a id="18854" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18859" href="MLTT.Unit.html#129" class="Record">𝟙</a> <a id="18861" class="Symbol">{</a><a id="18862" href="Iterative.Sets.html#784" class="Bound">𝓤</a><a id="18863" class="Symbol">}</a> <a id="18865" href="MLTT.Sigma.html#558" class="Function Operator">×</a> <a id="18867" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="18869" href="UF.ImageAndSurjection.html#678" class="Function Operator">∈image</a> <a id="18876" href="Iterative.Sets.html#18471" class="Bound">𝓐</a>                         <a id="18902" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18905" href="UF.EquivalenceExamples.html#7420" class="Function">𝟙-lneutral</a> <a id="18916" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18921" class="Symbol">(</a><a id="18922" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18924" href="Iterative.Sets.html#18924" class="Bound">i</a> <a id="18926" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="18928" href="Iterative.Sets.html#18468" class="Bound">I</a> <a id="18930" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="18932" href="Iterative.Sets.html#18471" class="Bound">𝓐</a> <a id="18934" href="Iterative.Sets.html#18924" class="Bound">i</a> <a id="18936" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="18938" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="18939" class="Symbol">)</a>                       <a id="18963" href="UF.Equiv.html#2729" class="Function Operator">≃⟨</a> <a id="18966" href="UF.EquivalenceExamples.html#34711" class="Function">∃-cong</a> <a id="18973" href="Iterative.Sets.html#17292" class="Bound">pt</a> <a id="18976" class="Symbol">(λ</a> <a id="18979" href="Iterative.Sets.html#18979" class="Bound">i</a> <a id="18981" class="Symbol">→</a> <a id="18983" href="UF.EquivalenceExamples.html#25145" class="Function">＝-flip</a><a id="18989" class="Symbol">)</a> <a id="18991" href="UF.Equiv.html#2729" class="Function Operator">⟩</a>
   <a id="18996" class="Symbol">(</a><a id="18997" href="UF.PropTrunc.html#2407" class="Function">∃</a> <a id="18999" href="Iterative.Sets.html#18999" class="Bound">i</a> <a id="19001" href="UF.PropTrunc.html#2407" class="Function">꞉</a> <a id="19003" href="Iterative.Sets.html#18468" class="Bound">I</a> <a id="19005" href="UF.PropTrunc.html#2407" class="Function">,</a> <a id="19007" href="Iterative.Sets.html#18473" class="Bound">B</a> <a id="19009" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19011" href="Iterative.Sets.html#18471" class="Bound">𝓐</a> <a id="19013" href="Iterative.Sets.html#18999" class="Bound">i</a><a id="19014" class="Symbol">)</a>                       <a id="19038" href="UF.Equiv.html#2815" class="Function Operator">■</a>
    <a id="19044" class="Keyword">where</a>
     <a id="19055" class="Keyword">open</a> <a id="19060" href="Iterative.Sets.html#17495" class="Module">union-construction</a> <a id="19079" href="Iterative.Sets.html#18471" class="Bound">𝓐</a>
     <a id="19086" href="Iterative.Sets.html#19086" class="Function">e₁</a> <a id="19089" class="Symbol">=</a> <a id="19091" href="UF.EquivalenceExamples.html#20200" class="Function">Σ-change-of-variable-≃</a> <a id="19114" class="Symbol">_</a> <a id="19116" href="Iterative.Sets.html#17761" class="Function">im⁻-≃-im</a>
     <a id="19130" href="Iterative.Sets.html#19130" class="Function">e₂</a> <a id="19133" class="Symbol">=</a> <a id="19135" href="UF.EquivalenceExamples.html#20200" class="Function">Σ-change-of-variable-≃</a> <a id="19158" class="Symbol">_</a>
           <a id="19171" class="Symbol">(</a><a id="19172" href="UF.EquivalenceExamples.html#25557" class="Function">singleton-≃-𝟙&#39;</a> <a id="19187" class="Symbol">(</a><a id="19188" href="UF.Equiv.html#9612" class="Function">singleton-types&#39;-are-singletons</a> <a id="19220" href="Iterative.Sets.html#18473" class="Bound">B</a><a id="19221" class="Symbol">))</a>

<a id="19225" class="Markup">\end{code}</a><a id="19235" class="Background">

Any iterative set is the union of its 𝕍-forest.

</a><a id="19286" class="Markup">\begin{code}</a>

  <a id="19302" href="Iterative.Sets.html#19302" class="Function">⋃-η</a> <a id="19306" class="Symbol">:</a> <a id="19308" class="Symbol">(</a><a id="19309" href="Iterative.Sets.html#19309" class="Bound">A</a> <a id="19311" class="Symbol">:</a> <a id="19313" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="19314" class="Symbol">)</a> <a id="19316" class="Symbol">→</a> <a id="19318" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="19320" class="Symbol">(</a><a id="19321" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19330" href="Iterative.Sets.html#19309" class="Bound">A</a><a id="19331" class="Symbol">)</a> <a id="19333" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19335" href="Iterative.Sets.html#19309" class="Bound">A</a>
  <a id="19339" href="Iterative.Sets.html#19302" class="Function">⋃-η</a> <a id="19343" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19345" class="Symbol">=</a> <a id="19347" href="Iterative.Sets.html#5387" class="Function">∈-is-extensional</a> <a id="19364" class="Symbol">(</a><a id="19365" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="19367" class="Symbol">(</a><a id="19368" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19377" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19378" class="Symbol">))</a> <a id="19381" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19383" href="Iterative.Sets.html#19400" class="Function">i</a> <a id="19385" href="Iterative.Sets.html#19607" class="Function">j</a>
   <a id="19390" class="Keyword">where</a>
    <a id="19400" href="Iterative.Sets.html#19400" class="Function">i</a> <a id="19402" class="Symbol">:</a> <a id="19404" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="19406" class="Symbol">(</a><a id="19407" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19416" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19417" class="Symbol">)</a> <a id="19419" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="19421" href="Iterative.Sets.html#19343" class="Bound">A</a>
    <a id="19427" href="Iterative.Sets.html#19400" class="Function">i</a> <a id="19429" href="Iterative.Sets.html#19429" class="Bound">B</a> <a id="19431" href="Iterative.Sets.html#19431" class="Bound">m</a> <a id="19433" class="Symbol">=</a> <a id="19435" href="UF.PropTrunc.html#676" class="Field">∥∥-rec</a> <a id="19442" class="Symbol">(</a><a id="19443" href="Iterative.Sets.html#4743" class="Function">∈-is-prop-valued</a> <a id="19460" href="Iterative.Sets.html#19429" class="Bound">B</a> <a id="19462" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19463" class="Symbol">)</a> <a id="19465" href="Iterative.Sets.html#19519" class="Function">f</a> <a id="19467" class="Symbol">(</a><a id="19468" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="19470" href="Iterative.Sets.html#18362" class="Function">⋃-behaviour</a> <a id="19482" class="Symbol">(</a><a id="19483" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19492" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19493" class="Symbol">)</a> <a id="19495" href="Iterative.Sets.html#19429" class="Bound">B</a> <a id="19497" href="UF.Equiv.html#2933" class="Function Operator">⌝</a> <a id="19499" href="Iterative.Sets.html#19431" class="Bound">m</a><a id="19500" class="Symbol">)</a>
     <a id="19507" class="Keyword">where</a>
      <a id="19519" href="Iterative.Sets.html#19519" class="Function">f</a> <a id="19521" class="Symbol">:</a> <a id="19523" class="Symbol">(</a><a id="19524" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="19526" href="Iterative.Sets.html#19526" class="Bound">a</a> <a id="19528" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="19530" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19537" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19539" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="19541" href="Iterative.Sets.html#19429" class="Bound">B</a> <a id="19543" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19545" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19554" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19556" href="Iterative.Sets.html#19526" class="Bound">a</a><a id="19557" class="Symbol">)</a> <a id="19559" class="Symbol">→</a> <a id="19561" href="Iterative.Sets.html#19429" class="Bound">B</a> <a id="19563" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="19565" href="Iterative.Sets.html#19343" class="Bound">A</a>
      <a id="19573" href="Iterative.Sets.html#19519" class="Function">f</a> <a id="19575" class="Symbol">(</a><a id="19576" href="Iterative.Sets.html#19576" class="Bound">a</a> <a id="19578" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="19580" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a><a id="19584" class="Symbol">)</a> <a id="19586" class="Symbol">=</a> <a id="19588" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="19599" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19601" href="Iterative.Sets.html#19576" class="Bound">a</a>
    <a id="19607" href="Iterative.Sets.html#19607" class="Function">j</a> <a id="19609" class="Symbol">:</a> <a id="19611" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19613" href="Iterative.Sets.html#5057" class="Function Operator">⊆</a> <a id="19615" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="19617" class="Symbol">(</a><a id="19618" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19627" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19628" class="Symbol">)</a>
    <a id="19634" href="Iterative.Sets.html#19607" class="Function">j</a> <a id="19636" href="Iterative.Sets.html#19636" class="Bound">B</a> <a id="19638" href="Iterative.Sets.html#19638" class="Bound">m</a> <a id="19640" class="Symbol">=</a> <a id="19642" href="UF.Equiv.html#3224" class="Function Operator">⌜</a> <a id="19644" href="Iterative.Sets.html#18362" class="Function">⋃-behaviour</a> <a id="19656" class="Symbol">(</a><a id="19657" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19666" href="Iterative.Sets.html#19343" class="Bound">A</a><a id="19667" class="Symbol">)</a> <a id="19669" href="Iterative.Sets.html#19636" class="Bound">B</a> <a id="19671" href="UF.Equiv.html#3224" class="Function Operator">⌝⁻¹</a> <a id="19675" href="UF.PropTrunc.html#630" class="Field Operator">∣</a> <a id="19677" href="Iterative.Sets.html#19799" class="Function">a</a> <a id="19679" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a> <a id="19681" href="Iterative.Sets.html#19837" class="Function">e</a> <a id="19683" href="UF.PropTrunc.html#630" class="Field Operator">∣</a>
     <a id="19690" class="Keyword">where</a>
      <a id="19702" class="Keyword">abstract</a>
       <a id="19718" href="Iterative.Sets.html#19718" class="Function">m&#39;</a> <a id="19721" class="Symbol">:</a> <a id="19723" href="MLTT.Sigma.html#423" class="Function">Σ</a> <a id="19725" href="Iterative.Sets.html#19725" class="Bound">a</a> <a id="19727" href="MLTT.Sigma.html#423" class="Function">꞉</a> <a id="19729" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19736" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19738" href="MLTT.Sigma.html#423" class="Function">,</a> <a id="19740" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19749" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19751" href="Iterative.Sets.html#19725" class="Bound">a</a> <a id="19753" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19755" href="Iterative.Sets.html#19636" class="Bound">B</a>
       <a id="19764" href="Iterative.Sets.html#19718" class="Function">m&#39;</a> <a id="19767" class="Symbol">=</a> <a id="19769" href="UF.Equiv.html#2933" class="Function Operator">⌜</a> <a id="19771" href="Iterative.Sets.html#10822" class="Function">∈-behaviour&#39;</a> <a id="19784" href="Iterative.Sets.html#19636" class="Bound">B</a> <a id="19786" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19788" href="UF.Equiv.html#2933" class="Function Operator">⌝</a> <a id="19790" href="Iterative.Sets.html#19638" class="Bound">m</a>
       <a id="19799" href="Iterative.Sets.html#19799" class="Function">a</a> <a id="19801" class="Symbol">:</a> <a id="19803" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="19810" href="Iterative.Sets.html#19343" class="Bound">A</a>
       <a id="19819" href="Iterative.Sets.html#19799" class="Function">a</a> <a id="19821" class="Symbol">=</a> <a id="19823" href="MLTT.Sigma-Type.html#198" class="Field">pr₁</a> <a id="19827" href="Iterative.Sets.html#19718" class="Function">m&#39;</a>
       <a id="19837" href="Iterative.Sets.html#19837" class="Function">e</a> <a id="19839" class="Symbol">:</a> <a id="19841" href="Iterative.Sets.html#19636" class="Bound">B</a> <a id="19843" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="19845" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="19854" href="Iterative.Sets.html#19343" class="Bound">A</a> <a id="19856" href="Iterative.Sets.html#19799" class="Function">a</a>
       <a id="19865" href="Iterative.Sets.html#19837" class="Function">e</a> <a id="19867" class="Symbol">=</a> <a id="19869" class="Symbol">(</a><a id="19870" href="MLTT.Sigma-Type.html#209" class="Field">pr₂</a> <a id="19874" href="Iterative.Sets.html#19718" class="Function">m&#39;</a><a id="19876" class="Symbol">)</a> <a id="19878" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a>

<a id="19882" class="Markup">\end{code}</a><a id="19892" class="Background">

Unions allow us to construct a retraction of the inclusion 𝕍 ↪ 𝕄, and
this seems to be a new result.

</a><a id="19996" class="Markup">\begin{code}</a>

  <a id="20012" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20019" class="Symbol">:</a> <a id="20021" href="Iterative.Multisets.html#691" class="Function">𝕄</a> <a id="20023" class="Symbol">→</a> <a id="20025" href="Iterative.Sets.html#2594" class="Function">𝕍</a>
  <a id="20029" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20036" class="Symbol">(</a><a id="20037" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="20042" href="Iterative.Sets.html#20042" class="Bound">X</a> <a id="20044" href="Iterative.Sets.html#20044" class="Bound">φ</a><a id="20045" class="Symbol">)</a> <a id="20047" class="Symbol">=</a> <a id="20049" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="20051" class="Symbol">(</a><a id="20052" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20059" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20061" href="Iterative.Sets.html#20044" class="Bound">φ</a><a id="20062" class="Symbol">)</a>

  <a id="20067" href="Iterative.Sets.html#20067" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a> <a id="20101" class="Symbol">:</a> <a id="20103" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20110" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20112" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20128" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20130" href="MLTT.Pi.html#444" class="Function">id</a>
  <a id="20135" href="Iterative.Sets.html#20067" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a> <a id="20169" class="Symbol">=</a> <a id="20171" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="20179" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="20182" class="Symbol">(</a><a id="20183" href="Iterative.Sets.html#15828" class="Function">∈-induction</a> <a id="20195" class="Symbol">_</a> <a id="20197" href="Iterative.Sets.html#20213" class="Function">f</a><a id="20198" class="Symbol">)</a>
   <a id="20203" class="Keyword">where</a>
    <a id="20213" href="Iterative.Sets.html#20213" class="Function">f</a> <a id="20215" class="Symbol">:</a> <a id="20217" class="Symbol">(</a><a id="20218" href="Iterative.Sets.html#20218" class="Bound">A</a> <a id="20220" class="Symbol">:</a> <a id="20222" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="20223" class="Symbol">)</a> <a id="20225" class="Symbol">→</a> <a id="20227" class="Symbol">((</a><a id="20229" href="Iterative.Sets.html#20229" class="Bound">B</a> <a id="20231" class="Symbol">:</a> <a id="20233" href="Iterative.Sets.html#2594" class="Function">𝕍</a><a id="20234" class="Symbol">)</a> <a id="20236" class="Symbol">→</a> <a id="20238" href="Iterative.Sets.html#20229" class="Bound">B</a> <a id="20240" href="Iterative.Sets.html#4193" class="Function Operator">∈</a> <a id="20242" href="Iterative.Sets.html#20218" class="Bound">A</a> <a id="20244" class="Symbol">→</a> <a id="20246" class="Symbol">(</a><a id="20247" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20254" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20256" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20271" class="Symbol">)</a> <a id="20273" href="Iterative.Sets.html#20229" class="Bound">B</a> <a id="20275" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20277" href="Iterative.Sets.html#20229" class="Bound">B</a><a id="20278" class="Symbol">)</a>
      <a id="20286" class="Symbol">→</a> <a id="20288" class="Symbol">(</a><a id="20289" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20296" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20298" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20313" class="Symbol">)</a> <a id="20315" href="Iterative.Sets.html#20218" class="Bound">A</a> <a id="20317" href="MLTT.Id.html#193" class="Datatype Operator">＝</a> <a id="20319" href="Iterative.Sets.html#20218" class="Bound">A</a>
    <a id="20325" href="Iterative.Sets.html#20213" class="Function">f</a> <a id="20327" href="Iterative.Sets.html#20327" class="Bound">A</a> <a id="20329" href="Iterative.Sets.html#20329" class="Bound">IH</a> <a id="20332" class="Symbol">=</a> <a id="20334" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20341" href="Iterative.Sets.html#20734" class="Function">Aₘ</a>                                 <a id="20376" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="20379" href="Iterative.Sets.html#20794" class="Function">I</a> <a id="20381" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
             <a id="20396" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20403" class="Symbol">(</a><a id="20404" href="W.Type.html#192" class="InductiveConstructor">ssup</a> <a id="20409" class="Symbol">(</a><a id="20410" href="Iterative.Sets.html#3460" class="Function">𝕍-root</a> <a id="20417" href="Iterative.Sets.html#20327" class="Bound">A</a><a id="20418" class="Symbol">)</a> <a id="20420" class="Symbol">(</a><a id="20421" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="20430" href="Iterative.Sets.html#20734" class="Function">Aₘ</a><a id="20432" class="Symbol">))</a>    <a id="20438" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="20441" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="20446" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
             <a id="20461" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="20463" class="Symbol">(</a><a id="20464" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20471" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20473" href="Iterative.Multisets.html#1742" class="Function">𝕄-forest</a> <a id="20482" href="Iterative.Sets.html#20734" class="Function">Aₘ</a><a id="20484" class="Symbol">)</a>                  <a id="20503" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="20506" href="MLTT.Identity-Type.html#157" class="InductiveConstructor">refl</a> <a id="20511" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
             <a id="20526" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="20528" class="Symbol">(</a><a id="20529" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20536" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20538" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20554" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20556" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20565" href="Iterative.Sets.html#20327" class="Bound">A</a><a id="20566" class="Symbol">)</a> <a id="20568" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="20571" href="Iterative.Sets.html#20855" class="Function">II</a> <a id="20574" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
             <a id="20589" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="20591" class="Symbol">(</a><a id="20592" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20601" href="Iterative.Sets.html#20327" class="Bound">A</a><a id="20602" class="Symbol">)</a>                            <a id="20631" href="MLTT.Id.html#2705" class="Function Operator">＝⟨</a> <a id="20634" href="Iterative.Sets.html#19302" class="Function">⋃-η</a> <a id="20638" href="Iterative.Sets.html#20327" class="Bound">A</a> <a id="20640" href="MLTT.Id.html#2705" class="Function Operator">⟩</a>
             <a id="20655" href="Iterative.Sets.html#20327" class="Bound">A</a>                                         <a id="20697" href="MLTT.Id.html#2787" class="Function Operator">∎</a>
              <a id="20713" class="Keyword">where</a>
               <a id="20734" href="Iterative.Sets.html#20734" class="Function">Aₘ</a> <a id="20737" class="Symbol">:</a> <a id="20739" href="Iterative.Multisets.html#691" class="Function">𝕄</a>
               <a id="20756" href="Iterative.Sets.html#20734" class="Function">Aₘ</a> <a id="20759" class="Symbol">=</a> <a id="20761" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="20777" href="Iterative.Sets.html#20327" class="Bound">A</a>
               <a id="20794" href="Iterative.Sets.html#20794" class="Function">I</a>  <a id="20797" class="Symbol">=</a> <a id="20799" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20802" class="Symbol">(</a><a id="20803" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20810" href="MLTT.Pi.html#513" class="Function Operator">∘</a> <a id="20812" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a><a id="20827" class="Symbol">)</a> <a id="20829" class="Symbol">(</a><a id="20830" href="Iterative.Sets.html#10067" class="Function">𝕍-η</a> <a id="20834" href="Iterative.Sets.html#20327" class="Bound">A</a> <a id="20836" href="MLTT.Id.html#1055" class="Function Operator">⁻¹</a><a id="20838" class="Symbol">)</a>
               <a id="20855" href="Iterative.Sets.html#20855" class="Function">II</a> <a id="20858" class="Symbol">=</a> <a id="20860" href="MLTT.Id.html#1136" class="Function">ap</a> <a id="20863" href="Iterative.Sets.html#18247" class="Function">⋃</a> <a id="20865" class="Symbol">(</a><a id="20866" href="UF.FunExt.html#1242" class="Function">dfunext</a> <a id="20874" href="Iterative.Sets.html#895" class="Function">fe</a> <a id="20877" class="Symbol">(λ</a> <a id="20880" href="Iterative.Sets.html#20880" class="Bound">a</a> <a id="20882" class="Symbol">→</a> <a id="20884" href="Iterative.Sets.html#20329" class="Bound">IH</a> <a id="20887" class="Symbol">(</a><a id="20888" href="Iterative.Sets.html#3516" class="Function">𝕍-forest</a> <a id="20897" href="Iterative.Sets.html#20327" class="Bound">A</a> <a id="20899" href="Iterative.Sets.html#20880" class="Bound">a</a><a id="20900" class="Symbol">)</a> <a id="20902" class="Symbol">(</a><a id="20903" href="Iterative.Sets.html#4849" class="Function">𝕍-forest-∈</a> <a id="20914" href="Iterative.Sets.html#20327" class="Bound">A</a> <a id="20916" href="Iterative.Sets.html#20880" class="Bound">a</a><a id="20917" class="Symbol">)))</a>

  <a id="20924" href="Iterative.Sets.html#20924" class="Function">𝕍-is-retract-of-𝕄</a> <a id="20942" class="Symbol">:</a> <a id="20944" href="UF.Retracts.html#1303" class="Function Operator">retract</a> <a id="20952" href="Iterative.Sets.html#2594" class="Function">𝕍</a> <a id="20954" href="UF.Retracts.html#1303" class="Function Operator">of</a> <a id="20957" href="Iterative.Multisets.html#691" class="Function">𝕄</a>
  <a id="20961" href="Iterative.Sets.html#20924" class="Function">𝕍-is-retract-of-𝕄</a> <a id="20979" class="Symbol">=</a> <a id="20981" href="Iterative.Sets.html#20012" class="Function">𝕄-to-𝕍</a> <a id="20988" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
                      <a id="21012" href="Iterative.Sets.html#2892" class="Function">underlying-mset</a> <a id="21028" href="MLTT.Sigma.html#395" class="InductiveConstructor Operator">,</a>
                      <a id="21052" href="UF.Base.html#11014" class="Function">happly</a> <a id="21059" href="Iterative.Sets.html#20067" class="Function">𝕄-to-𝕍-is-retraction-of-inclusion</a>

<a id="21094" class="Markup">\end{code}</a><a id="21104" class="Background">
</a></pre></body></html>