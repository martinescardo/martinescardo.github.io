<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><title
    >DependentEquality</title
    ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta http-equiv="Content-Style-Type" content="text/css"
     /><link href="Agda.css" rel="stylesheet" type="text/css"
     /></head
  ><body
  ><pre
    ><a name="1" class="Comment"
      >      ==================</a
      ><a name="25"
      >
</a
      ><a name="26" class="Comment"
      >      Dependent equality</a
      ><a name="50"
      >
</a
      ><a name="51" class="Comment"
      >      ==================</a
      ><a name="75"
      >

</a
      ><a name="77" class="Comment"
      >      Advanced Functional Programming</a
      ><a name="114"
      >
</a
      ><a name="115" class="Comment"
      >      School of Computer Science</a
      ><a name="147"
      >
</a
      ><a name="148" class="Comment"
      >      University of Birmingham, UK</a
      ><a name="182"
      >

</a
      ><a name="184" class="Comment"
      >      Mart&#237;n H&#246;tzel Escard&#243;</a
      ><a name="211"
      >
</a
      ><a name="212" class="Comment"
      >      Lecture of 6rd February 2017</a
      ><a name="246"
      >

</a
      ><a name="248" class="Comment"
      >      (Adapted from http://www.cs.bham.ac.uk/~mhe/agda/VecConcatAssoc.html)</a
      ><a name="323"
      >

</a
      ><a name="325" class="Comment"
      >      (The ideas discussed here come from &quot;univalent foundations&quot; and</a
      ><a name="394"
      >
</a
      ><a name="395" class="Comment"
      >      &quot;homotopy type theory&quot;, but you don't need to know that in order</a
      ><a name="465"
      >
</a
      ><a name="466" class="Comment"
      >      to understand what is explained here.</a
      ><a name="509"
      >
</a
      ><a name="510" class="Comment"
      >      https://homotopytypetheory.org/book/)</a
      ><a name="553"
      >

</a
      ><a name="555" class="Comment"
      >Summary</a
      ><a name="562"
      >
</a
      ><a name="563" class="Comment"
      >=======</a
      ><a name="570"
      >

</a
      ><a name="572" class="Comment"
      >1. It is relatively easy to prove that list concatenation is</a
      ><a name="632"
      >
</a
      ><a name="633" class="Comment"
      >associative:</a
      ><a name="645"
      >

</a
      ><a name="647" class="Comment"
      >  (xs ++ ys) ++ zs &#8801; xs ++ (ys ++ zs).</a
      ><a name="685"
      >

</a
      ><a name="687" class="Comment"
      >You have already seen this, and we will quickly review it.</a
      ><a name="745"
      >

</a
      ><a name="747" class="Comment"
      >2. When we generalize lists to vectors, then this becomes a</a
      ><a name="806"
      >
</a
      ><a name="807" class="Comment"
      >problem. It is not that this is difficult to *prove*. Rather, it</a
      ><a name="871"
      >
</a
      ><a name="872" class="Comment"
      >becomes difficult to even figure out *what needs to be proved*: The</a
      ><a name="939"
      >
</a
      ><a name="940" class="Comment"
      >above equation doesn't type check, when xs, ys, zs are vectors rather</a
      ><a name="1009"
      >
</a
      ><a name="1010" class="Comment"
      >than lists, because its left and right sides live in different types,</a
      ><a name="1079"
      >
</a
      ><a name="1080" class="Comment"
      >as we shall see.</a
      ><a name="1096"
      >

</a
      ><a name="1098" class="Comment"
      >3. But once we know what to prove, the proof becomes just as easy as</a
      ><a name="1166"
      >
</a
      ><a name="1167" class="Comment"
      >that of associativity of list concatenation.</a
      ><a name="1211"
      >

</a
      ><a name="1213" class="Comment"
      >4. What we need is a concept of dependent equality: an equality that</a
      ><a name="1281"
      >
</a
      ><a name="1282" class="Comment"
      >depends on another equality. This is what we study in these notes.</a
      ><a name="1348"
      >

</a
      ><a name="1350" class="Comment"
      >This is a literate agda file</a
      ><a name="1378"
      >
</a
      ><a name="1379" class="Comment"
      >============================</a
      ><a name="1407"
      >

</a
      ><a name="1409" class="Comment"
      >This file (ending in .lagda rather than .agda) is in literate</a
      ><a name="1470"
      >
</a
      ><a name="1471" class="Comment"
      >style. This means that everything is a &quot;comment&quot;, except things</a
      ><a name="1534"
      >
</a
      ><a name="1535" class="Comment"
      >enclosed in a code environment.</a
      ><a name="1566"
      >

</a
      ><a name="1568" class="Comment"
      >Getting started</a
      ><a name="1583"
      >
</a
      ><a name="1584" class="Comment"
      >===============</a
      ><a name="1599"
      >

</a
      ><a name="1601" class="Comment"
      >This file is self-contained. We don't use libraries so that we know</a
      ><a name="1668"
      >
</a
      ><a name="1669" class="Comment"
      >exactly what is used for this task from first principles, and also so</a
      ><a name="1738"
      >
</a
      ><a name="1739" class="Comment"
      >that we can see explicitly that this can be done without much</a
      ><a name="1800"
      >
</a
      ><a name="1801" class="Comment"
      >machinery. (Although it requires a lot of explanation and</a
      ><a name="1858"
      >
</a
      ><a name="1859" class="Comment"
      >understanding effort.)</a
      ><a name="1881"
      >

\begin{code}

</a
      ><a name="1897" class="Symbol"
      >{-#</a
      ><a name="1900"
      > </a
      ><a name="1901" class="Keyword"
      >OPTIONS</a
      ><a name="1908"
      > --without-K </a
      ><a name="1921" class="Symbol"
      >#-}</a
      ><a name="1924"
      >

</a
      ><a name="1926" class="Keyword"
      >module</a
      ><a name="1932"
      > </a
      ><a name="1933" href="DependentEquality.html#1" class="Module"
      >DependentEquality</a
      ><a name="1950"
      > </a
      ><a name="1951" class="Keyword"
      >where</a
      ><a name="1956"
      >

\end{code}

</a
      ><a name="1970" class="Comment"
      >Standard stuff for equality, which you have already seen:</a
      ><a name="2027"
      >

\begin{code}

</a
      ><a name="2043" class="Keyword"
      >data</a
      ><a name="2047"
      > </a
      ><a name="2048" href="DependentEquality.html#2048" class="Datatype Operator"
      >_&#8801;_</a
      ><a name="2051"
      > </a
      ><a name="2052" class="Symbol"
      >{</a
      ><a name="2053" href="DependentEquality.html#2053" class="Bound"
      >X</a
      ><a name="2054"
      > </a
      ><a name="2055" class="Symbol"
      >:</a
      ><a name="2056"
      > </a
      ><a name="2057" class="PrimitiveType"
      >Set</a
      ><a name="2060" class="Symbol"
      >}</a
      ><a name="2061"
      > </a
      ><a name="2062" class="Symbol"
      >:</a
      ><a name="2063"
      > </a
      ><a name="2064" href="DependentEquality.html#2053" class="Bound"
      >X</a
      ><a name="2065"
      > </a
      ><a name="2066" class="Symbol"
      >&#8594;</a
      ><a name="2067"
      > </a
      ><a name="2068" href="DependentEquality.html#2053" class="Bound"
      >X</a
      ><a name="2069"
      > </a
      ><a name="2070" class="Symbol"
      >&#8594;</a
      ><a name="2071"
      > </a
      ><a name="2072" class="PrimitiveType"
      >Set</a
      ><a name="2075"
      > </a
      ><a name="2076" class="Keyword"
      >where</a
      ><a name="2081"
      >
 </a
      ><a name="2083" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="2087"
      > </a
      ><a name="2088" class="Symbol"
      >:</a
      ><a name="2089"
      > </a
      ><a name="2090" class="Symbol"
      >{</a
      ><a name="2091" href="DependentEquality.html#2091" class="Bound"
      >x</a
      ><a name="2092"
      > </a
      ><a name="2093" class="Symbol"
      >:</a
      ><a name="2094"
      > </a
      ><a name="2095" href="DependentEquality.html#2053" class="Bound"
      >X</a
      ><a name="2096" class="Symbol"
      >}</a
      ><a name="2097"
      > </a
      ><a name="2098" class="Symbol"
      >&#8594;</a
      ><a name="2099"
      > </a
      ><a name="2100" href="DependentEquality.html#2091" class="Bound"
      >x</a
      ><a name="2101"
      > </a
      ><a name="2102" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2103"
      > </a
      ><a name="2104" href="DependentEquality.html#2091" class="Bound"
      >x</a
      ><a name="2105"
      >

</a
      ><a name="2107" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="2111"
      > </a
      ><a name="2112" class="Symbol"
      >:</a
      ><a name="2113"
      > </a
      ><a name="2114" class="Symbol"
      >{</a
      ><a name="2115" href="DependentEquality.html#2115" class="Bound"
      >X</a
      ><a name="2116"
      > </a
      ><a name="2117" href="DependentEquality.html#2117" class="Bound"
      >Y</a
      ><a name="2118"
      > </a
      ><a name="2119" class="Symbol"
      >:</a
      ><a name="2120"
      > </a
      ><a name="2121" class="PrimitiveType"
      >Set</a
      ><a name="2124" class="Symbol"
      >}</a
      ><a name="2125"
      > </a
      ><a name="2126" class="Symbol"
      >(</a
      ><a name="2127" href="DependentEquality.html#2127" class="Bound"
      >f</a
      ><a name="2128"
      > </a
      ><a name="2129" class="Symbol"
      >:</a
      ><a name="2130"
      > </a
      ><a name="2131" href="DependentEquality.html#2115" class="Bound"
      >X</a
      ><a name="2132"
      > </a
      ><a name="2133" class="Symbol"
      >&#8594;</a
      ><a name="2134"
      > </a
      ><a name="2135" href="DependentEquality.html#2117" class="Bound"
      >Y</a
      ><a name="2136" class="Symbol"
      >)</a
      ><a name="2137"
      > </a
      ><a name="2138" class="Symbol"
      >{</a
      ><a name="2139" href="DependentEquality.html#2139" class="Bound"
      >x&#8320;</a
      ><a name="2141"
      > </a
      ><a name="2142" href="DependentEquality.html#2142" class="Bound"
      >x&#8321;</a
      ><a name="2144"
      > </a
      ><a name="2145" class="Symbol"
      >:</a
      ><a name="2146"
      > </a
      ><a name="2147" href="DependentEquality.html#2115" class="Bound"
      >X</a
      ><a name="2148" class="Symbol"
      >}</a
      ><a name="2149"
      > </a
      ><a name="2150" class="Symbol"
      >&#8594;</a
      ><a name="2151"
      > </a
      ><a name="2152" href="DependentEquality.html#2139" class="Bound"
      >x&#8320;</a
      ><a name="2154"
      > </a
      ><a name="2155" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2156"
      > </a
      ><a name="2157" href="DependentEquality.html#2142" class="Bound"
      >x&#8321;</a
      ><a name="2159"
      > </a
      ><a name="2160" class="Symbol"
      >&#8594;</a
      ><a name="2161"
      > </a
      ><a name="2162" href="DependentEquality.html#2127" class="Bound"
      >f</a
      ><a name="2163"
      > </a
      ><a name="2164" href="DependentEquality.html#2139" class="Bound"
      >x&#8320;</a
      ><a name="2166"
      > </a
      ><a name="2167" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2168"
      > </a
      ><a name="2169" href="DependentEquality.html#2127" class="Bound"
      >f</a
      ><a name="2170"
      > </a
      ><a name="2171" href="DependentEquality.html#2142" class="Bound"
      >x&#8321;</a
      ><a name="2173"
      >
</a
      ><a name="2174" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="2178"
      > </a
      ><a name="2179" class="Symbol"
      >{</a
      ><a name="2180" href="DependentEquality.html#2180" class="Bound"
      >X</a
      ><a name="2181" class="Symbol"
      >}</a
      ><a name="2182"
      > </a
      ><a name="2183" class="Symbol"
      >{</a
      ><a name="2184" href="DependentEquality.html#2184" class="Bound"
      >Y</a
      ><a name="2185" class="Symbol"
      >}</a
      ><a name="2186"
      > </a
      ><a name="2187" href="DependentEquality.html#2187" class="Bound"
      >f</a
      ><a name="2188"
      > </a
      ><a name="2189" class="Symbol"
      >(</a
      ><a name="2190" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="2194"
      > </a
      ><a name="2195" class="Symbol"
      >{</a
      ><a name="2196" href="DependentEquality.html#2196" class="Bound"
      >x</a
      ><a name="2197" class="Symbol"
      >})</a
      ><a name="2199"
      > </a
      ><a name="2200" class="Symbol"
      >=</a
      ><a name="2201"
      > </a
      ><a name="2202" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="2206"
      > </a
      ><a name="2207" class="Symbol"
      >{</a
      ><a name="2208" href="DependentEquality.html#2184" class="Bound"
      >Y</a
      ><a name="2209" class="Symbol"
      >}</a
      ><a name="2210"
      > </a
      ><a name="2211" class="Symbol"
      >{</a
      ><a name="2212" href="DependentEquality.html#2187" class="Bound"
      >f</a
      ><a name="2213"
      > </a
      ><a name="2214" href="DependentEquality.html#2196" class="Bound"
      >x</a
      ><a name="2215" class="Symbol"
      >}</a
      ><a name="2216"
      >

\end{code}

</a
      ><a name="2230" class="Comment"
      >You have already defined lists and concatenation, and shown that</a
      ><a name="2294"
      >
</a
      ><a name="2295" class="Comment"
      >concatenation is associative. Here is a recap:</a
      ><a name="2341"
      >

\begin{code}

</a
      ><a name="2357" class="Keyword"
      >module</a
      ><a name="2363"
      > </a
      ><a name="2364" href="DependentEquality.html#2364" class="Module"
      >recap</a
      ><a name="2369"
      > </a
      ><a name="2370" class="Keyword"
      >where</a
      ><a name="2375"
      >

  </a
      ><a name="2379" class="Keyword"
      >data</a
      ><a name="2383"
      > </a
      ><a name="2384" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2388"
      > </a
      ><a name="2389" class="Symbol"
      >(</a
      ><a name="2390" href="DependentEquality.html#2390" class="Bound"
      >X</a
      ><a name="2391"
      > </a
      ><a name="2392" class="Symbol"
      >:</a
      ><a name="2393"
      > </a
      ><a name="2394" class="PrimitiveType"
      >Set</a
      ><a name="2397" class="Symbol"
      >)</a
      ><a name="2398"
      > </a
      ><a name="2399" class="Symbol"
      >:</a
      ><a name="2400"
      > </a
      ><a name="2401" class="PrimitiveType"
      >Set</a
      ><a name="2404"
      > </a
      ><a name="2405" class="Keyword"
      >where</a
      ><a name="2410"
      >
    </a
      ><a name="2415" href="DependentEquality.html#2415" class="InductiveConstructor"
      >[]</a
      ><a name="2417"
      >  </a
      ><a name="2419" class="Symbol"
      >:</a
      ><a name="2420"
      > </a
      ><a name="2421" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2425"
      > </a
      ><a name="2426" href="DependentEquality.html#2390" class="Bound"
      >X</a
      ><a name="2427"
      >
    </a
      ><a name="2432" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >_&#8759;_</a
      ><a name="2435"
      > </a
      ><a name="2436" class="Symbol"
      >:</a
      ><a name="2437"
      > </a
      ><a name="2438" href="DependentEquality.html#2390" class="Bound"
      >X</a
      ><a name="2439"
      > </a
      ><a name="2440" class="Symbol"
      >&#8594;</a
      ><a name="2441"
      > </a
      ><a name="2442" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2446"
      > </a
      ><a name="2447" href="DependentEquality.html#2390" class="Bound"
      >X</a
      ><a name="2448"
      > </a
      ><a name="2449" class="Symbol"
      >&#8594;</a
      ><a name="2450"
      > </a
      ><a name="2451" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2455"
      > </a
      ><a name="2456" href="DependentEquality.html#2390" class="Bound"
      >X</a
      ><a name="2457"
      >

  </a
      ><a name="2461" href="DependentEquality.html#2461" class="Function Operator"
      >_++_</a
      ><a name="2465"
      > </a
      ><a name="2466" class="Symbol"
      >:</a
      ><a name="2467"
      > </a
      ><a name="2468" class="Symbol"
      >&#8704;{</a
      ><a name="2470" href="DependentEquality.html#2470" class="Bound"
      >X</a
      ><a name="2471" class="Symbol"
      >}</a
      ><a name="2472"
      > </a
      ><a name="2473" class="Symbol"
      >&#8594;</a
      ><a name="2474"
      > </a
      ><a name="2475" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2479"
      > </a
      ><a name="2480" href="DependentEquality.html#2470" class="Bound"
      >X</a
      ><a name="2481"
      > </a
      ><a name="2482" class="Symbol"
      >&#8594;</a
      ><a name="2483"
      > </a
      ><a name="2484" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2488"
      > </a
      ><a name="2489" href="DependentEquality.html#2470" class="Bound"
      >X</a
      ><a name="2490"
      > </a
      ><a name="2491" class="Symbol"
      >&#8594;</a
      ><a name="2492"
      > </a
      ><a name="2493" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2497"
      > </a
      ><a name="2498" href="DependentEquality.html#2470" class="Bound"
      >X</a
      ><a name="2499"
      >
  </a
      ><a name="2502" href="DependentEquality.html#2415" class="InductiveConstructor"
      >[]</a
      ><a name="2504"
      >       </a
      ><a name="2511" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2513"
      > </a
      ><a name="2514" href="DependentEquality.html#2514" class="Bound"
      >ys</a
      ><a name="2516"
      > </a
      ><a name="2517" class="Symbol"
      >=</a
      ><a name="2518"
      > </a
      ><a name="2519" href="DependentEquality.html#2514" class="Bound"
      >ys</a
      ><a name="2521"
      >
  </a
      ><a name="2524" class="Symbol"
      >(</a
      ><a name="2525" href="DependentEquality.html#2525" class="Bound"
      >x</a
      ><a name="2526"
      > </a
      ><a name="2527" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2528"
      > </a
      ><a name="2529" href="DependentEquality.html#2529" class="Bound"
      >xs</a
      ><a name="2531" class="Symbol"
      >)</a
      ><a name="2532"
      > </a
      ><a name="2533" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2535"
      > </a
      ><a name="2536" href="DependentEquality.html#2536" class="Bound"
      >ys</a
      ><a name="2538"
      > </a
      ><a name="2539" class="Symbol"
      >=</a
      ><a name="2540"
      > </a
      ><a name="2541" href="DependentEquality.html#2525" class="Bound"
      >x</a
      ><a name="2542"
      > </a
      ><a name="2543" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2544"
      > </a
      ><a name="2545" class="Symbol"
      >(</a
      ><a name="2546" href="DependentEquality.html#2529" class="Bound"
      >xs</a
      ><a name="2548"
      > </a
      ><a name="2549" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2551"
      > </a
      ><a name="2552" href="DependentEquality.html#2536" class="Bound"
      >ys</a
      ><a name="2554" class="Symbol"
      >)</a
      ><a name="2555"
      >

  </a
      ><a name="2559" href="DependentEquality.html#2559" class="Function"
      >++-assoc</a
      ><a name="2567"
      > </a
      ><a name="2568" class="Symbol"
      >:</a
      ><a name="2569"
      > </a
      ><a name="2570" class="Symbol"
      >&#8704;</a
      ><a name="2571"
      > </a
      ><a name="2572" class="Symbol"
      >{</a
      ><a name="2573" href="DependentEquality.html#2573" class="Bound"
      >X</a
      ><a name="2574" class="Symbol"
      >}</a
      ><a name="2575"
      > </a
      ><a name="2576" class="Symbol"
      >(</a
      ><a name="2577" href="DependentEquality.html#2577" class="Bound"
      >xs</a
      ><a name="2579"
      > </a
      ><a name="2580" href="DependentEquality.html#2580" class="Bound"
      >ys</a
      ><a name="2582"
      > </a
      ><a name="2583" href="DependentEquality.html#2583" class="Bound"
      >zs</a
      ><a name="2585"
      > </a
      ><a name="2586" class="Symbol"
      >:</a
      ><a name="2587"
      > </a
      ><a name="2588" href="DependentEquality.html#2384" class="Datatype"
      >List</a
      ><a name="2592"
      > </a
      ><a name="2593" href="DependentEquality.html#2573" class="Bound"
      >X</a
      ><a name="2594" class="Symbol"
      >)</a
      ><a name="2595"
      >
          </a
      ><a name="2606" class="Symbol"
      >&#8594;</a
      ><a name="2607"
      > </a
      ><a name="2608" class="Symbol"
      >(</a
      ><a name="2609" href="DependentEquality.html#2577" class="Bound"
      >xs</a
      ><a name="2611"
      > </a
      ><a name="2612" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2614"
      > </a
      ><a name="2615" href="DependentEquality.html#2580" class="Bound"
      >ys</a
      ><a name="2617" class="Symbol"
      >)</a
      ><a name="2618"
      > </a
      ><a name="2619" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2621"
      > </a
      ><a name="2622" href="DependentEquality.html#2583" class="Bound"
      >zs</a
      ><a name="2624"
      > </a
      ><a name="2625" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2626"
      > </a
      ><a name="2627" href="DependentEquality.html#2577" class="Bound"
      >xs</a
      ><a name="2629"
      > </a
      ><a name="2630" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2632"
      > </a
      ><a name="2633" class="Symbol"
      >(</a
      ><a name="2634" href="DependentEquality.html#2580" class="Bound"
      >ys</a
      ><a name="2636"
      > </a
      ><a name="2637" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2639"
      > </a
      ><a name="2640" href="DependentEquality.html#2583" class="Bound"
      >zs</a
      ><a name="2642" class="Symbol"
      >)</a
      ><a name="2643"
      >
  </a
      ><a name="2646" href="DependentEquality.html#2559" class="Function"
      >++-assoc</a
      ><a name="2654"
      > </a
      ><a name="2655" href="DependentEquality.html#2415" class="InductiveConstructor"
      >[]</a
      ><a name="2657"
      >       </a
      ><a name="2664" href="DependentEquality.html#2664" class="Bound"
      >ys</a
      ><a name="2666"
      > </a
      ><a name="2667" href="DependentEquality.html#2667" class="Bound"
      >zs</a
      ><a name="2669"
      > </a
      ><a name="2670" class="Symbol"
      >=</a
      ><a name="2671"
      > </a
      ><a name="2672" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="2676"
      >
  </a
      ><a name="2679" href="DependentEquality.html#2559" class="Function"
      >++-assoc</a
      ><a name="2687"
      > </a
      ><a name="2688" class="Symbol"
      >(</a
      ><a name="2689" href="DependentEquality.html#2689" class="Bound"
      >x</a
      ><a name="2690"
      > </a
      ><a name="2691" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2692"
      > </a
      ><a name="2693" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2695" class="Symbol"
      >)</a
      ><a name="2696"
      > </a
      ><a name="2697" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2699"
      > </a
      ><a name="2700" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2702"
      > </a
      ><a name="2703" class="Symbol"
      >=</a
      ><a name="2704"
      > </a
      ><a name="2705" href="DependentEquality.html#2795" class="Function"
      >goal</a
      ><a name="2709"
      >
   </a
      ><a name="2713" class="Keyword"
      >where</a
      ><a name="2718"
      >
    </a
      ><a name="2723" href="DependentEquality.html#2723" class="Function"
      >IH</a
      ><a name="2725"
      > </a
      ><a name="2726" class="Symbol"
      >:</a
      ><a name="2727"
      > </a
      ><a name="2728" class="Symbol"
      >(</a
      ><a name="2729" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2731"
      > </a
      ><a name="2732" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2734"
      > </a
      ><a name="2735" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2737" class="Symbol"
      >)</a
      ><a name="2738"
      > </a
      ><a name="2739" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2741"
      > </a
      ><a name="2742" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2744"
      > </a
      ><a name="2745" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2746"
      > </a
      ><a name="2747" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2749"
      > </a
      ><a name="2750" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2752"
      > </a
      ><a name="2753" class="Symbol"
      >(</a
      ><a name="2754" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2756"
      > </a
      ><a name="2757" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2759"
      > </a
      ><a name="2760" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2762" class="Symbol"
      >)</a
      ><a name="2763"
      >
    </a
      ><a name="2768" href="DependentEquality.html#2723" class="Function"
      >IH</a
      ><a name="2770"
      > </a
      ><a name="2771" class="Symbol"
      >=</a
      ><a name="2772"
      > </a
      ><a name="2773" href="DependentEquality.html#2559" class="Function"
      >++-assoc</a
      ><a name="2781"
      > </a
      ><a name="2782" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2784"
      > </a
      ><a name="2785" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2787"
      > </a
      ><a name="2788" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2790"
      >
    </a
      ><a name="2795" href="DependentEquality.html#2795" class="Function"
      >goal</a
      ><a name="2799"
      > </a
      ><a name="2800" class="Symbol"
      >:</a
      ><a name="2801"
      > </a
      ><a name="2802" href="DependentEquality.html#2689" class="Bound"
      >x</a
      ><a name="2803"
      > </a
      ><a name="2804" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2805"
      > </a
      ><a name="2806" class="Symbol"
      >((</a
      ><a name="2808" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2810"
      > </a
      ><a name="2811" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2813"
      > </a
      ><a name="2814" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2816" class="Symbol"
      >)</a
      ><a name="2817"
      > </a
      ><a name="2818" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2820"
      > </a
      ><a name="2821" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2823" class="Symbol"
      >)</a
      ><a name="2824"
      >  </a
      ><a name="2826" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="2827"
      >  </a
      ><a name="2829" href="DependentEquality.html#2689" class="Bound"
      >x</a
      ><a name="2830"
      > </a
      ><a name="2831" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2832"
      > </a
      ><a name="2833" class="Symbol"
      >(</a
      ><a name="2834" href="DependentEquality.html#2693" class="Bound"
      >xs</a
      ><a name="2836"
      > </a
      ><a name="2837" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2839"
      > </a
      ><a name="2840" class="Symbol"
      >(</a
      ><a name="2841" href="DependentEquality.html#2697" class="Bound"
      >ys</a
      ><a name="2843"
      > </a
      ><a name="2844" href="DependentEquality.html#2461" class="Function Operator"
      >++</a
      ><a name="2846"
      > </a
      ><a name="2847" href="DependentEquality.html#2700" class="Bound"
      >zs</a
      ><a name="2849" class="Symbol"
      >))</a
      ><a name="2851"
      >
    </a
      ><a name="2856" href="DependentEquality.html#2795" class="Function"
      >goal</a
      ><a name="2860"
      > </a
      ><a name="2861" class="Symbol"
      >=</a
      ><a name="2862"
      > </a
      ><a name="2863" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="2867"
      > </a
      ><a name="2868" class="Symbol"
      >(&#955;</a
      ><a name="2870"
      > </a
      ><a name="2871" href="DependentEquality.html#2871" class="Bound"
      >ws</a
      ><a name="2873"
      > </a
      ><a name="2874" class="Symbol"
      >&#8594;</a
      ><a name="2875"
      > </a
      ><a name="2876" href="DependentEquality.html#2689" class="Bound"
      >x</a
      ><a name="2877"
      > </a
      ><a name="2878" href="DependentEquality.html#2432" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="2879"
      > </a
      ><a name="2880" href="DependentEquality.html#2871" class="Bound"
      >ws</a
      ><a name="2882" class="Symbol"
      >)</a
      ><a name="2883"
      > </a
      ><a name="2884" href="DependentEquality.html#2723" class="Function"
      >IH</a
      ><a name="2886"
      >

\end{code}

</a
      ><a name="2900" class="Comment"
      >We have put the above in a separate submodule so that it doesn't</a
      ><a name="2964"
      >
</a
      ><a name="2965" class="Comment"
      >pollute our global name space and in particular the names _++_ and</a
      ><a name="3031"
      >
</a
      ><a name="3032" class="Comment"
      >++-assoc remain available for vector concatenation and associativity.</a
      ><a name="3101"
      >

</a
      ><a name="3103" class="Comment"
      >Standard stuff for natural numbers:</a
      ><a name="3138"
      >

\begin{code}

</a
      ><a name="3154" class="Keyword"
      >data</a
      ><a name="3158"
      > </a
      ><a name="3159" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3160"
      > </a
      ><a name="3161" class="Symbol"
      >:</a
      ><a name="3162"
      > </a
      ><a name="3163" class="PrimitiveType"
      >Set</a
      ><a name="3166"
      > </a
      ><a name="3167" class="Keyword"
      >where</a
      ><a name="3172"
      >
 </a
      ><a name="3174" href="DependentEquality.html#3174" class="InductiveConstructor"
      >zero</a
      ><a name="3178"
      > </a
      ><a name="3179" class="Symbol"
      >:</a
      ><a name="3180"
      > </a
      ><a name="3181" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3182"
      >
 </a
      ><a name="3184" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3188"
      > </a
      ><a name="3189" class="Symbol"
      >:</a
      ><a name="3190"
      > </a
      ><a name="3191" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3192"
      > </a
      ><a name="3193" class="Symbol"
      >&#8594;</a
      ><a name="3194"
      > </a
      ><a name="3195" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3196"
      >

</a
      ><a name="3198" href="DependentEquality.html#3198" class="Function Operator"
      >_+_</a
      ><a name="3201"
      > </a
      ><a name="3202" class="Symbol"
      >:</a
      ><a name="3203"
      > </a
      ><a name="3204" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3205"
      > </a
      ><a name="3206" class="Symbol"
      >&#8594;</a
      ><a name="3207"
      > </a
      ><a name="3208" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3209"
      > </a
      ><a name="3210" class="Symbol"
      >&#8594;</a
      ><a name="3211"
      > </a
      ><a name="3212" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3213"
      >
</a
      ><a name="3214" href="DependentEquality.html#3174" class="InductiveConstructor"
      >zero</a
      ><a name="3218"
      >   </a
      ><a name="3221" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3222"
      > </a
      ><a name="3223" href="DependentEquality.html#3223" class="Bound"
      >y</a
      ><a name="3224"
      > </a
      ><a name="3225" class="Symbol"
      >=</a
      ><a name="3226"
      > </a
      ><a name="3227" href="DependentEquality.html#3223" class="Bound"
      >y</a
      ><a name="3228"
      >
</a
      ><a name="3229" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3233"
      > </a
      ><a name="3234" href="DependentEquality.html#3234" class="Bound"
      >x</a
      ><a name="3235"
      > </a
      ><a name="3236" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3237"
      > </a
      ><a name="3238" href="DependentEquality.html#3238" class="Bound"
      >y</a
      ><a name="3239"
      > </a
      ><a name="3240" class="Symbol"
      >=</a
      ><a name="3241"
      > </a
      ><a name="3242" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3246" class="Symbol"
      >(</a
      ><a name="3247" href="DependentEquality.html#3234" class="Bound"
      >x</a
      ><a name="3248"
      > </a
      ><a name="3249" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3250"
      > </a
      ><a name="3251" href="DependentEquality.html#3238" class="Bound"
      >y</a
      ><a name="3252" class="Symbol"
      >)</a
      ><a name="3253"
      >

</a
      ><a name="3255" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="3262"
      > </a
      ><a name="3263" class="Symbol"
      >:</a
      ><a name="3264"
      > </a
      ><a name="3265" class="Symbol"
      >&#8704;</a
      ><a name="3266"
      > </a
      ><a name="3267" href="DependentEquality.html#3267" class="Bound"
      >l</a
      ><a name="3268"
      > </a
      ><a name="3269" href="DependentEquality.html#3269" class="Bound"
      >m</a
      ><a name="3270"
      > </a
      ><a name="3271" href="DependentEquality.html#3271" class="Bound"
      >n</a
      ><a name="3272"
      > </a
      ><a name="3273" class="Symbol"
      >&#8594;</a
      ><a name="3274"
      > </a
      ><a name="3275" class="Symbol"
      >(</a
      ><a name="3276" href="DependentEquality.html#3267" class="Bound"
      >l</a
      ><a name="3277"
      > </a
      ><a name="3278" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3279"
      > </a
      ><a name="3280" href="DependentEquality.html#3269" class="Bound"
      >m</a
      ><a name="3281" class="Symbol"
      >)</a
      ><a name="3282"
      > </a
      ><a name="3283" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3284"
      > </a
      ><a name="3285" href="DependentEquality.html#3271" class="Bound"
      >n</a
      ><a name="3286"
      > </a
      ><a name="3287" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="3288"
      > </a
      ><a name="3289" href="DependentEquality.html#3267" class="Bound"
      >l</a
      ><a name="3290"
      > </a
      ><a name="3291" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3292"
      > </a
      ><a name="3293" class="Symbol"
      >(</a
      ><a name="3294" href="DependentEquality.html#3269" class="Bound"
      >m</a
      ><a name="3295"
      > </a
      ><a name="3296" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3297"
      > </a
      ><a name="3298" href="DependentEquality.html#3271" class="Bound"
      >n</a
      ><a name="3299" class="Symbol"
      >)</a
      ><a name="3300"
      >
</a
      ><a name="3301" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="3308"
      > </a
      ><a name="3309" href="DependentEquality.html#3174" class="InductiveConstructor"
      >zero</a
      ><a name="3313"
      >     </a
      ><a name="3318" href="DependentEquality.html#3318" class="Bound"
      >m</a
      ><a name="3319"
      > </a
      ><a name="3320" href="DependentEquality.html#3320" class="Bound"
      >n</a
      ><a name="3321"
      > </a
      ><a name="3322" class="Symbol"
      >=</a
      ><a name="3323"
      > </a
      ><a name="3324" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="3328"
      >
</a
      ><a name="3329" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="3336"
      > </a
      ><a name="3337" class="Symbol"
      >(</a
      ><a name="3338" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3342"
      > </a
      ><a name="3343" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3344" class="Symbol"
      >)</a
      ><a name="3345"
      > </a
      ><a name="3346" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3347"
      > </a
      ><a name="3348" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3349"
      > </a
      ><a name="3350" class="Symbol"
      >=</a
      ><a name="3351"
      > </a
      ><a name="3352" href="DependentEquality.html#3420" class="Function"
      >goal</a
      ><a name="3356"
      >
 </a
      ><a name="3358" class="Keyword"
      >where</a
      ><a name="3363"
      >
  </a
      ><a name="3366" href="DependentEquality.html#3366" class="Function"
      >IH</a
      ><a name="3368"
      > </a
      ><a name="3369" class="Symbol"
      >:</a
      ><a name="3370"
      > </a
      ><a name="3371" class="Symbol"
      >(</a
      ><a name="3372" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3373"
      > </a
      ><a name="3374" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3375"
      > </a
      ><a name="3376" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3377" class="Symbol"
      >)</a
      ><a name="3378"
      > </a
      ><a name="3379" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3380"
      > </a
      ><a name="3381" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3382"
      > </a
      ><a name="3383" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="3384"
      > </a
      ><a name="3385" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3386"
      > </a
      ><a name="3387" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3388"
      > </a
      ><a name="3389" class="Symbol"
      >(</a
      ><a name="3390" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3391"
      > </a
      ><a name="3392" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3393"
      > </a
      ><a name="3394" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3395" class="Symbol"
      >)</a
      ><a name="3396"
      >
  </a
      ><a name="3399" href="DependentEquality.html#3366" class="Function"
      >IH</a
      ><a name="3401"
      > </a
      ><a name="3402" class="Symbol"
      >=</a
      ><a name="3403"
      > </a
      ><a name="3404" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="3411"
      > </a
      ><a name="3412" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3413"
      > </a
      ><a name="3414" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3415"
      > </a
      ><a name="3416" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3417"
      >
  </a
      ><a name="3420" href="DependentEquality.html#3420" class="Function"
      >goal</a
      ><a name="3424"
      > </a
      ><a name="3425" class="Symbol"
      >:</a
      ><a name="3426"
      > </a
      ><a name="3427" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3431"
      > </a
      ><a name="3432" class="Symbol"
      >((</a
      ><a name="3434" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3435"
      > </a
      ><a name="3436" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3437"
      > </a
      ><a name="3438" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3439" class="Symbol"
      >)</a
      ><a name="3440"
      > </a
      ><a name="3441" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3442"
      > </a
      ><a name="3443" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3444" class="Symbol"
      >)</a
      ><a name="3445"
      > </a
      ><a name="3446" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="3447"
      > </a
      ><a name="3448" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3452"
      > </a
      ><a name="3453" class="Symbol"
      >(</a
      ><a name="3454" href="DependentEquality.html#3343" class="Bound"
      >l</a
      ><a name="3455"
      > </a
      ><a name="3456" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3457"
      > </a
      ><a name="3458" class="Symbol"
      >(</a
      ><a name="3459" href="DependentEquality.html#3346" class="Bound"
      >m</a
      ><a name="3460"
      > </a
      ><a name="3461" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="3462"
      > </a
      ><a name="3463" href="DependentEquality.html#3348" class="Bound"
      >n</a
      ><a name="3464" class="Symbol"
      >))</a
      ><a name="3466"
      >
  </a
      ><a name="3469" href="DependentEquality.html#3420" class="Function"
      >goal</a
      ><a name="3473"
      > </a
      ><a name="3474" class="Symbol"
      >=</a
      ><a name="3475"
      > </a
      ><a name="3476" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="3480"
      > </a
      ><a name="3481" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3485"
      > </a
      ><a name="3486" href="DependentEquality.html#3366" class="Function"
      >IH</a
      ><a name="3488"
      >

\end{code}

</a
      ><a name="3502" class="Comment"
      >Notice how the proof of associativity of addition is analogous to the</a
      ><a name="3571"
      >
</a
      ><a name="3572" class="Comment"
      >proof of associativity of concatenation.</a
      ><a name="3612"
      >

</a
      ><a name="3614" class="Comment"
      >Vectors</a
      ><a name="3621"
      >
</a
      ><a name="3622" class="Comment"
      >=======</a
      ><a name="3629"
      >

</a
      ><a name="3631" class="Comment"
      >Sometimes it is useful to consider lists of a given length. These are</a
      ><a name="3700"
      >
</a
      ><a name="3701" class="Comment"
      >called vectors, and the type of vectors of elements of type X with</a
      ><a name="3767"
      >
</a
      ><a name="3768" class="Comment"
      >length n is written Vec X n and defined as follows:</a
      ><a name="3819"
      >

\begin{code}

</a
      ><a name="3835" class="Keyword"
      >data</a
      ><a name="3839"
      > </a
      ><a name="3840" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="3843"
      > </a
      ><a name="3844" class="Symbol"
      >(</a
      ><a name="3845" href="DependentEquality.html#3845" class="Bound"
      >X</a
      ><a name="3846"
      > </a
      ><a name="3847" class="Symbol"
      >:</a
      ><a name="3848"
      > </a
      ><a name="3849" class="PrimitiveType"
      >Set</a
      ><a name="3852" class="Symbol"
      >)</a
      ><a name="3853"
      > </a
      ><a name="3854" class="Symbol"
      >:</a
      ><a name="3855"
      > </a
      ><a name="3856" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="3857"
      > </a
      ><a name="3858" class="Symbol"
      >&#8594;</a
      ><a name="3859"
      > </a
      ><a name="3860" class="PrimitiveType"
      >Set</a
      ><a name="3863"
      > </a
      ><a name="3864" class="Keyword"
      >where</a
      ><a name="3869"
      >
  </a
      ><a name="3872" href="DependentEquality.html#3872" class="InductiveConstructor"
      >[]</a
      ><a name="3874"
      >  </a
      ><a name="3876" class="Symbol"
      >:</a
      ><a name="3877"
      > </a
      ><a name="3878" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="3881"
      > </a
      ><a name="3882" href="DependentEquality.html#3845" class="Bound"
      >X</a
      ><a name="3883"
      > </a
      ><a name="3884" href="DependentEquality.html#3174" class="InductiveConstructor"
      >zero</a
      ><a name="3888"
      >
  </a
      ><a name="3891" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >_&#8759;_</a
      ><a name="3894"
      > </a
      ><a name="3895" class="Symbol"
      >:</a
      ><a name="3896"
      > </a
      ><a name="3897" class="Symbol"
      >&#8704;{</a
      ><a name="3899" href="DependentEquality.html#3899" class="Bound"
      >n</a
      ><a name="3900" class="Symbol"
      >}</a
      ><a name="3901"
      > </a
      ><a name="3902" class="Symbol"
      >&#8594;</a
      ><a name="3903"
      > </a
      ><a name="3904" href="DependentEquality.html#3845" class="Bound"
      >X</a
      ><a name="3905"
      > </a
      ><a name="3906" class="Symbol"
      >&#8594;</a
      ><a name="3907"
      > </a
      ><a name="3908" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="3911"
      > </a
      ><a name="3912" href="DependentEquality.html#3845" class="Bound"
      >X</a
      ><a name="3913"
      > </a
      ><a name="3914" href="DependentEquality.html#3899" class="Bound"
      >n</a
      ><a name="3915"
      > </a
      ><a name="3916" class="Symbol"
      >&#8594;</a
      ><a name="3917"
      > </a
      ><a name="3918" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="3921"
      > </a
      ><a name="3922" href="DependentEquality.html#3845" class="Bound"
      >X</a
      ><a name="3923"
      > </a
      ><a name="3924" class="Symbol"
      >(</a
      ><a name="3925" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="3929"
      > </a
      ><a name="3930" href="DependentEquality.html#3899" class="Bound"
      >n</a
      ><a name="3931" class="Symbol"
      >)</a
      ><a name="3932"
      >

\end{code}

</a
      ><a name="3946" class="Comment"
      >For example, with this we can define safe head and tail functions:</a
      ><a name="4012"
      >

\begin{code}

</a
      ><a name="4028" href="DependentEquality.html#4028" class="Function"
      >hd</a
      ><a name="4030"
      > </a
      ><a name="4031" class="Symbol"
      >:</a
      ><a name="4032"
      > </a
      ><a name="4033" class="Symbol"
      >{</a
      ><a name="4034" href="DependentEquality.html#4034" class="Bound"
      >X</a
      ><a name="4035"
      > </a
      ><a name="4036" class="Symbol"
      >:</a
      ><a name="4037"
      > </a
      ><a name="4038" class="PrimitiveType"
      >Set</a
      ><a name="4041" class="Symbol"
      >}</a
      ><a name="4042"
      > </a
      ><a name="4043" class="Symbol"
      >{</a
      ><a name="4044" href="DependentEquality.html#4044" class="Bound"
      >n</a
      ><a name="4045"
      > </a
      ><a name="4046" class="Symbol"
      >:</a
      ><a name="4047"
      > </a
      ><a name="4048" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="4049" class="Symbol"
      >}</a
      ><a name="4050"
      > </a
      ><a name="4051" class="Symbol"
      >&#8594;</a
      ><a name="4052"
      > </a
      ><a name="4053" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="4056"
      > </a
      ><a name="4057" href="DependentEquality.html#4034" class="Bound"
      >X</a
      ><a name="4058"
      > </a
      ><a name="4059" class="Symbol"
      >(</a
      ><a name="4060" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="4064"
      > </a
      ><a name="4065" href="DependentEquality.html#4044" class="Bound"
      >n</a
      ><a name="4066" class="Symbol"
      >)</a
      ><a name="4067"
      > </a
      ><a name="4068" class="Symbol"
      >&#8594;</a
      ><a name="4069"
      > </a
      ><a name="4070" href="DependentEquality.html#4034" class="Bound"
      >X</a
      ><a name="4071"
      >
</a
      ><a name="4072" href="DependentEquality.html#4028" class="Function"
      >hd</a
      ><a name="4074"
      > </a
      ><a name="4075" class="Symbol"
      >(</a
      ><a name="4076" href="DependentEquality.html#4076" class="Bound"
      >x</a
      ><a name="4077"
      > </a
      ><a name="4078" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="4079"
      > </a
      ><a name="4080" href="DependentEquality.html#4080" class="Bound"
      >xs</a
      ><a name="4082" class="Symbol"
      >)</a
      ><a name="4083"
      > </a
      ><a name="4084" class="Symbol"
      >=</a
      ><a name="4085"
      > </a
      ><a name="4086" href="DependentEquality.html#4076" class="Bound"
      >x</a
      ><a name="4087"
      >

</a
      ><a name="4089" href="DependentEquality.html#4089" class="Function"
      >tl</a
      ><a name="4091"
      > </a
      ><a name="4092" class="Symbol"
      >:</a
      ><a name="4093"
      > </a
      ><a name="4094" class="Symbol"
      >{</a
      ><a name="4095" href="DependentEquality.html#4095" class="Bound"
      >X</a
      ><a name="4096"
      > </a
      ><a name="4097" class="Symbol"
      >:</a
      ><a name="4098"
      > </a
      ><a name="4099" class="PrimitiveType"
      >Set</a
      ><a name="4102" class="Symbol"
      >}</a
      ><a name="4103"
      > </a
      ><a name="4104" class="Symbol"
      >{</a
      ><a name="4105" href="DependentEquality.html#4105" class="Bound"
      >n</a
      ><a name="4106"
      > </a
      ><a name="4107" class="Symbol"
      >:</a
      ><a name="4108"
      > </a
      ><a name="4109" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="4110" class="Symbol"
      >}</a
      ><a name="4111"
      > </a
      ><a name="4112" class="Symbol"
      >&#8594;</a
      ><a name="4113"
      > </a
      ><a name="4114" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="4117"
      > </a
      ><a name="4118" href="DependentEquality.html#4095" class="Bound"
      >X</a
      ><a name="4119"
      > </a
      ><a name="4120" class="Symbol"
      >(</a
      ><a name="4121" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="4125"
      > </a
      ><a name="4126" href="DependentEquality.html#4105" class="Bound"
      >n</a
      ><a name="4127" class="Symbol"
      >)</a
      ><a name="4128"
      > </a
      ><a name="4129" class="Symbol"
      >&#8594;</a
      ><a name="4130"
      > </a
      ><a name="4131" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="4134"
      > </a
      ><a name="4135" href="DependentEquality.html#4095" class="Bound"
      >X</a
      ><a name="4136"
      > </a
      ><a name="4137" href="DependentEquality.html#4105" class="Bound"
      >n</a
      ><a name="4138"
      >
</a
      ><a name="4139" href="DependentEquality.html#4089" class="Function"
      >tl</a
      ><a name="4141"
      > </a
      ><a name="4142" class="Symbol"
      >(</a
      ><a name="4143" href="DependentEquality.html#4143" class="Bound"
      >x</a
      ><a name="4144"
      > </a
      ><a name="4145" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="4146"
      > </a
      ><a name="4147" href="DependentEquality.html#4147" class="Bound"
      >xs</a
      ><a name="4149" class="Symbol"
      >)</a
      ><a name="4150"
      > </a
      ><a name="4151" class="Symbol"
      >=</a
      ><a name="4152"
      > </a
      ><a name="4153" href="DependentEquality.html#4147" class="Bound"
      >xs</a
      ><a name="4155"
      >

\end{code}

</a
      ><a name="4169" class="Comment"
      >Notice that we don't have a case for the empty vector [] because it</a
      ><a name="4236"
      >
</a
      ><a name="4237" class="Comment"
      >doesn't belong to the type Vec X (succ n).</a
      ><a name="4279"
      >

</a
      ><a name="4281" class="Comment"
      >We can also define a safe indexing operation. We first need to define,</a
      ><a name="4351"
      >
</a
      ><a name="4352" class="Comment"
      >given a natural number n : &#8469;, the type of numbers from 0 to n-1, which</a
      ><a name="4422"
      >
</a
      ><a name="4423" class="Comment"
      >is written Fin n. We do this so that Fin 0 is an empty type:</a
      ><a name="4483"
      >

\begin{code}

</a
      ><a name="4499" class="Keyword"
      >data</a
      ><a name="4503"
      > </a
      ><a name="4504" href="DependentEquality.html#4504" class="Datatype"
      >Fin</a
      ><a name="4507"
      > </a
      ><a name="4508" class="Symbol"
      >:</a
      ><a name="4509"
      > </a
      ><a name="4510" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="4511"
      > </a
      ><a name="4512" class="Symbol"
      >&#8594;</a
      ><a name="4513"
      > </a
      ><a name="4514" class="PrimitiveType"
      >Set</a
      ><a name="4517"
      > </a
      ><a name="4518" class="Keyword"
      >where</a
      ><a name="4523"
      >
 </a
      ><a name="4525" href="DependentEquality.html#4525" class="InductiveConstructor"
      >zero</a
      ><a name="4529"
      > </a
      ><a name="4530" class="Symbol"
      >:</a
      ><a name="4531"
      > </a
      ><a name="4532" class="Symbol"
      >{</a
      ><a name="4533" href="DependentEquality.html#4533" class="Bound"
      >n</a
      ><a name="4534"
      > </a
      ><a name="4535" class="Symbol"
      >:</a
      ><a name="4536"
      > </a
      ><a name="4537" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="4538" class="Symbol"
      >}</a
      ><a name="4539"
      > </a
      ><a name="4540" class="Symbol"
      >&#8594;</a
      ><a name="4541"
      > </a
      ><a name="4542" href="DependentEquality.html#4504" class="Datatype"
      >Fin</a
      ><a name="4545"
      > </a
      ><a name="4546" class="Symbol"
      >(</a
      ><a name="4547" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="4551"
      > </a
      ><a name="4552" href="DependentEquality.html#4533" class="Bound"
      >n</a
      ><a name="4553" class="Symbol"
      >)</a
      ><a name="4554"
      >
 </a
      ><a name="4556" href="DependentEquality.html#4556" class="InductiveConstructor"
      >succ</a
      ><a name="4560"
      > </a
      ><a name="4561" class="Symbol"
      >:</a
      ><a name="4562"
      > </a
      ><a name="4563" class="Symbol"
      >{</a
      ><a name="4564" href="DependentEquality.html#4564" class="Bound"
      >n</a
      ><a name="4565"
      > </a
      ><a name="4566" class="Symbol"
      >:</a
      ><a name="4567"
      > </a
      ><a name="4568" href="DependentEquality.html#3159" class="Datatype"
      >&#8469;</a
      ><a name="4569" class="Symbol"
      >}</a
      ><a name="4570"
      > </a
      ><a name="4571" class="Symbol"
      >&#8594;</a
      ><a name="4572"
      > </a
      ><a name="4573" href="DependentEquality.html#4504" class="Datatype"
      >Fin</a
      ><a name="4576"
      > </a
      ><a name="4577" href="DependentEquality.html#4564" class="Bound"
      >n</a
      ><a name="4578"
      > </a
      ><a name="4579" class="Symbol"
      >&#8594;</a
      ><a name="4580"
      > </a
      ><a name="4581" href="DependentEquality.html#4504" class="Datatype"
      >Fin</a
      ><a name="4584"
      > </a
      ><a name="4585" class="Symbol"
      >(</a
      ><a name="4586" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="4590"
      > </a
      ><a name="4591" href="DependentEquality.html#4564" class="Bound"
      >n</a
      ><a name="4592" class="Symbol"
      >)</a
      ><a name="4593"
      >

\end{code}

</a
      ><a name="4607" class="Comment"
      >Now, given a vector xs of length k and a number in i the range</a
      ><a name="4669"
      >
</a
      ><a name="4670" class="Comment"
      >0,1,..,n,n-1, that is, an element of Fin n, we can fetch the ith</a
      ><a name="4734"
      >
</a
      ><a name="4735" class="Comment"
      >element of xs in a type-safe way:</a
      ><a name="4768"
      >

\begin{code}

</a
      ><a name="4784" href="DependentEquality.html#4784" class="Function"
      >fetch</a
      ><a name="4789"
      > </a
      ><a name="4790" class="Symbol"
      >:</a
      ><a name="4791"
      > </a
      ><a name="4792" class="Symbol"
      >&#8704;</a
      ><a name="4793"
      > </a
      ><a name="4794" class="Symbol"
      >{</a
      ><a name="4795" href="DependentEquality.html#4795" class="Bound"
      >X</a
      ><a name="4796"
      > </a
      ><a name="4797" href="DependentEquality.html#4797" class="Bound"
      >n</a
      ><a name="4798" class="Symbol"
      >}</a
      ><a name="4799"
      > </a
      ><a name="4800" class="Symbol"
      >&#8594;</a
      ><a name="4801"
      > </a
      ><a name="4802" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="4805"
      > </a
      ><a name="4806" href="DependentEquality.html#4795" class="Bound"
      >X</a
      ><a name="4807"
      > </a
      ><a name="4808" href="DependentEquality.html#4797" class="Bound"
      >n</a
      ><a name="4809"
      > </a
      ><a name="4810" class="Symbol"
      >&#8594;</a
      ><a name="4811"
      > </a
      ><a name="4812" href="DependentEquality.html#4504" class="Datatype"
      >Fin</a
      ><a name="4815"
      > </a
      ><a name="4816" href="DependentEquality.html#4797" class="Bound"
      >n</a
      ><a name="4817"
      > </a
      ><a name="4818" class="Symbol"
      >&#8594;</a
      ><a name="4819"
      > </a
      ><a name="4820" href="DependentEquality.html#4795" class="Bound"
      >X</a
      ><a name="4821"
      >
</a
      ><a name="4822" href="DependentEquality.html#4784" class="Function"
      >fetch</a
      ><a name="4827"
      > </a
      ><a name="4828" class="Symbol"
      >(</a
      ><a name="4829" href="DependentEquality.html#4829" class="Bound"
      >x</a
      ><a name="4830"
      > </a
      ><a name="4831" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="4832"
      > </a
      ><a name="4833" href="DependentEquality.html#4833" class="Bound"
      >xs</a
      ><a name="4835" class="Symbol"
      >)</a
      ><a name="4836"
      >  </a
      ><a name="4838" href="DependentEquality.html#4525" class="InductiveConstructor"
      >zero</a
      ><a name="4842"
      >    </a
      ><a name="4846" class="Symbol"
      >=</a
      ><a name="4847"
      > </a
      ><a name="4848" href="DependentEquality.html#4829" class="Bound"
      >x</a
      ><a name="4849"
      >
</a
      ><a name="4850" href="DependentEquality.html#4784" class="Function"
      >fetch</a
      ><a name="4855"
      > </a
      ><a name="4856" class="Symbol"
      >(</a
      ><a name="4857" href="DependentEquality.html#4857" class="Bound"
      >x</a
      ><a name="4858"
      > </a
      ><a name="4859" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="4860"
      > </a
      ><a name="4861" href="DependentEquality.html#4861" class="Bound"
      >xs</a
      ><a name="4863" class="Symbol"
      >)</a
      ><a name="4864"
      > </a
      ><a name="4865" class="Symbol"
      >(</a
      ><a name="4866" href="DependentEquality.html#4556" class="InductiveConstructor"
      >succ</a
      ><a name="4870"
      > </a
      ><a name="4871" href="DependentEquality.html#4871" class="Bound"
      >i</a
      ><a name="4872" class="Symbol"
      >)</a
      ><a name="4873"
      > </a
      ><a name="4874" class="Symbol"
      >=</a
      ><a name="4875"
      > </a
      ><a name="4876" href="DependentEquality.html#4784" class="Function"
      >fetch</a
      ><a name="4881"
      > </a
      ><a name="4882" href="DependentEquality.html#4861" class="Bound"
      >xs</a
      ><a name="4884"
      > </a
      ><a name="4885" href="DependentEquality.html#4871" class="Bound"
      >i</a
      ><a name="4886"
      >

\end{code}

</a
      ><a name="4900" class="Comment"
      >Vector concatenation is defined in the same way as list concatenation,</a
      ><a name="4970"
      >
</a
      ><a name="4971" class="Comment"
      >but with a different type:</a
      ><a name="4997"
      >

\begin{code}

</a
      ><a name="5013" href="DependentEquality.html#5013" class="Function Operator"
      >_++_</a
      ><a name="5017"
      > </a
      ><a name="5018" class="Symbol"
      >:</a
      ><a name="5019"
      > </a
      ><a name="5020" class="Symbol"
      >&#8704;{</a
      ><a name="5022" href="DependentEquality.html#5022" class="Bound"
      >X</a
      ><a name="5023"
      > </a
      ><a name="5024" href="DependentEquality.html#5024" class="Bound"
      >m</a
      ><a name="5025"
      > </a
      ><a name="5026" href="DependentEquality.html#5026" class="Bound"
      >n</a
      ><a name="5027" class="Symbol"
      >}</a
      ><a name="5028"
      > </a
      ><a name="5029" class="Symbol"
      >&#8594;</a
      ><a name="5030"
      > </a
      ><a name="5031" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="5034"
      > </a
      ><a name="5035" href="DependentEquality.html#5022" class="Bound"
      >X</a
      ><a name="5036"
      > </a
      ><a name="5037" href="DependentEquality.html#5024" class="Bound"
      >m</a
      ><a name="5038"
      > </a
      ><a name="5039" class="Symbol"
      >&#8594;</a
      ><a name="5040"
      > </a
      ><a name="5041" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="5044"
      > </a
      ><a name="5045" href="DependentEquality.html#5022" class="Bound"
      >X</a
      ><a name="5046"
      > </a
      ><a name="5047" href="DependentEquality.html#5026" class="Bound"
      >n</a
      ><a name="5048"
      > </a
      ><a name="5049" class="Symbol"
      >&#8594;</a
      ><a name="5050"
      > </a
      ><a name="5051" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="5054"
      > </a
      ><a name="5055" href="DependentEquality.html#5022" class="Bound"
      >X</a
      ><a name="5056"
      > </a
      ><a name="5057" class="Symbol"
      >(</a
      ><a name="5058" href="DependentEquality.html#5024" class="Bound"
      >m</a
      ><a name="5059"
      > </a
      ><a name="5060" href="DependentEquality.html#3198" class="Function Operator"
      >+</a
      ><a name="5061"
      > </a
      ><a name="5062" href="DependentEquality.html#5026" class="Bound"
      >n</a
      ><a name="5063" class="Symbol"
      >)</a
      ><a name="5064"
      >
</a
      ><a name="5065" href="DependentEquality.html#3872" class="InductiveConstructor"
      >[]</a
      ><a name="5067"
      >       </a
      ><a name="5074" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="5076"
      > </a
      ><a name="5077" href="DependentEquality.html#5077" class="Bound"
      >ys</a
      ><a name="5079"
      > </a
      ><a name="5080" class="Symbol"
      >=</a
      ><a name="5081"
      > </a
      ><a name="5082" href="DependentEquality.html#5077" class="Bound"
      >ys</a
      ><a name="5084"
      >
</a
      ><a name="5085" class="Symbol"
      >(</a
      ><a name="5086" href="DependentEquality.html#5086" class="Bound"
      >x</a
      ><a name="5087"
      > </a
      ><a name="5088" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="5089"
      > </a
      ><a name="5090" href="DependentEquality.html#5090" class="Bound"
      >xs</a
      ><a name="5092" class="Symbol"
      >)</a
      ><a name="5093"
      > </a
      ><a name="5094" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="5096"
      > </a
      ><a name="5097" href="DependentEquality.html#5097" class="Bound"
      >ys</a
      ><a name="5099"
      > </a
      ><a name="5100" class="Symbol"
      >=</a
      ><a name="5101"
      > </a
      ><a name="5102" href="DependentEquality.html#5086" class="Bound"
      >x</a
      ><a name="5103"
      > </a
      ><a name="5104" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="5105"
      > </a
      ><a name="5106" class="Symbol"
      >(</a
      ><a name="5107" href="DependentEquality.html#5090" class="Bound"
      >xs</a
      ><a name="5109"
      > </a
      ><a name="5110" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="5112"
      > </a
      ><a name="5113" href="DependentEquality.html#5097" class="Bound"
      >ys</a
      ><a name="5115" class="Symbol"
      >)</a
      ><a name="5116"
      >

\end{code}

</a
      ><a name="5130" class="Comment"
      >Dependent equality of Vectors</a
      ><a name="5159"
      >
</a
      ><a name="5160" class="Comment"
      >=============================</a
      ><a name="5189"
      >

</a
      ><a name="5191" class="Comment"
      >We now come to the heart of the problem considered here, the</a
      ><a name="5251"
      >
</a
      ><a name="5252" class="Comment"
      >formulation and proof of associativity of vector concatenation.</a
      ><a name="5315"
      >

</a
      ><a name="5317" class="Comment"
      >We try to prove this (uncomment to get an error):</a
      ><a name="5366"
      >

\begin{code}

</a
      ><a name="5382" class="Comment"
      >-- ++-assoc' : &#8704;{X} l m n (xs : Vec X l) (ys : Vec X m) (zs : Vec X n)</a
      ><a name="5452"
      >
</a
      ><a name="5453" class="Comment"
      >--          &#8594; (xs ++ ys) ++ zs  &#8801; xs ++ (ys ++ zs)</a
      ><a name="5503"
      >
</a
      ><a name="5504" class="Comment"
      >-- ++-assoc' l m n xs ys zs = ?</a
      ><a name="5535"
      >

\end{code}</a
      ><a name="5547" class="Comment"
      > </a
      ><a name="5548"
      >

</a
      ><a name="5550" class="Comment"
      >We get the cryptic error message </a
      ><a name="5583"
      >

</a
      ><a name="5585" class="Comment"
      >  l != l + m of type &#8469;</a
      ><a name="5607"
      >
</a
      ><a name="5608" class="Comment"
      >  when checking that the expression xs ++ (ys ++ zs) has type</a
      ><a name="5669"
      >
</a
      ><a name="5670" class="Comment"
      >  Vec X (l + m + n)</a
      ><a name="5689"
      >

</a
      ><a name="5691" class="Comment"
      >What is going on? We have</a
      ><a name="5716"
      >

</a
      ><a name="5718" class="Comment"
      >  (xs ++ ys) ++ zs : Vec X ((l + m) + n),</a
      ><a name="5759"
      >
</a
      ><a name="5760" class="Comment"
      >  xs ++ (ys ++ zs) : Vec X (l + (m + n)).</a
      ><a name="5801"
      >

</a
      ><a name="5803" class="Comment"
      >While we do have </a
      ><a name="5820"
      >

</a
      ><a name="5822" class="Comment"
      >  (l + m) + n &#8801; l + (m + n),</a
      ><a name="5850"
      >

</a
      ><a name="5852" class="Comment"
      >as proved above, we don't get that the types</a
      ><a name="5896"
      >

</a
      ><a name="5898" class="Comment"
      >  Vec X ((l + m) + n) and Vec X (l + (m + n))</a
      ><a name="5943"
      >

</a
      ><a name="5945" class="Comment"
      >are the same, which is perhaps counter-intuitive. </a
      ><a name="5995"
      >

</a
      ><a name="5997" class="Comment"
      >We know that (l + m) + n &#8801; l + (m + n) because we have proved it, but</a
      ><a name="6066"
      >
</a
      ><a name="6067" class="Comment"
      >when Agda type checks your code it doesn't use this equality. Why?</a
      ><a name="6133"
      >

</a
      ><a name="6135" class="Comment"
      >The only equalities Agda uses when type checking code are those that</a
      ><a name="6203"
      >
</a
      ><a name="6204" class="Comment"
      >it knows in advance, and that are built-in in the type checker, before</a
      ><a name="6274"
      >
</a
      ><a name="6275" class="Comment"
      >we write any code proving more equalities.</a
      ><a name="6317"
      >

</a
      ><a name="6319" class="Comment"
      >And the above associativity equality is not built-in: we had to prove</a
      ><a name="6388"
      >
</a
      ><a name="6389" class="Comment"
      >it. And it required some insight.</a
      ><a name="6422"
      >

</a
      ><a name="6424" class="Comment"
      >The only equalities that Agda uses when type checking your code are</a
      ><a name="6491"
      >
</a
      ><a name="6492" class="Comment"
      >those which are routine and don't require any insight whatsoever,</a
      ><a name="6557"
      >
</a
      ><a name="6558" class="Comment"
      >which can be proved mechanically, and which you could therefore call</a
      ><a name="6626"
      >
</a
      ><a name="6627" class="Comment"
      >obvious.</a
      ><a name="6635"
      >

</a
      ><a name="6637" class="Comment"
      >Hence the expressions</a
      ><a name="6658"
      >

</a
      ><a name="6660" class="Comment"
      >  (xs ++ ys) ++ zs and xs ++ (ys ++ zs)</a
      ><a name="6699"
      >

</a
      ><a name="6701" class="Comment"
      >live in different types as far as Agda is concerned.</a
      ><a name="6753"
      >

</a
      ><a name="6755" class="Comment"
      >But equality is only defined for elements of the same type. Hence the</a
      ><a name="6824"
      >
</a
      ><a name="6825" class="Comment"
      >two expressions cannot be equated.</a
      ><a name="6859"
      >

</a
      ><a name="6861" class="Comment"
      >To overcome this, we can explicitly tell Agda to use an equality we</a
      ><a name="6928"
      >
</a
      ><a name="6929" class="Comment"
      >have proved.</a
      ><a name="6941"
      >

</a
      ><a name="6943" class="Comment"
      >If we have</a
      ><a name="6953"
      >

</a
      ><a name="6955" class="Comment"
      >  p  : m &#8801; n</a
      ><a name="6967"
      >
</a
      ><a name="6968" class="Comment"
      >  xs : Vec X m</a
      ><a name="6982"
      >
</a
      ><a name="6983" class="Comment"
      >  ys : Vec X n</a
      ><a name="6997"
      >

</a
      ><a name="6999" class="Comment"
      >we can define an equality</a
      ><a name="7024"
      >

</a
      ><a name="7026" class="Comment"
      >  xs &#8801;[ p ] ys</a
      ><a name="7040"
      >

</a
      ><a name="7042" class="Comment"
      >of xs and ys depending on the given equality p.</a
      ><a name="7089"
      >

</a
      ><a name="7091" class="Comment"
      >As usual, we define this by pattern matching on p. The neat thing is</a
      ><a name="7159"
      >
</a
      ><a name="7160" class="Comment"
      >that when p is refl, then Agda knows that xs and ys do live in the</a
      ><a name="7226"
      >
</a
      ><a name="7227" class="Comment"
      >same type, and hence we can use the usual equality to define our new</a
      ><a name="7295"
      >
</a
      ><a name="7296" class="Comment"
      >dependent equality:</a
      ><a name="7315"
      >

\begin{code}

</a
      ><a name="7331" href="DependentEquality.html#7331" class="Function Operator"
      >_&#8801;[_]_</a
      ><a name="7337"
      > </a
      ><a name="7338" class="Symbol"
      >:</a
      ><a name="7339"
      > </a
      ><a name="7340" class="Symbol"
      >&#8704;{</a
      ><a name="7342" href="DependentEquality.html#7342" class="Bound"
      >X</a
      ><a name="7343"
      > </a
      ><a name="7344" href="DependentEquality.html#7344" class="Bound"
      >m</a
      ><a name="7345"
      > </a
      ><a name="7346" href="DependentEquality.html#7346" class="Bound"
      >n</a
      ><a name="7347" class="Symbol"
      >}</a
      ><a name="7348"
      > </a
      ><a name="7349" class="Symbol"
      >&#8594;</a
      ><a name="7350"
      > </a
      ><a name="7351" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="7354"
      > </a
      ><a name="7355" href="DependentEquality.html#7342" class="Bound"
      >X</a
      ><a name="7356"
      > </a
      ><a name="7357" href="DependentEquality.html#7344" class="Bound"
      >m</a
      ><a name="7358"
      > </a
      ><a name="7359" class="Symbol"
      >&#8594;</a
      ><a name="7360"
      > </a
      ><a name="7361" href="DependentEquality.html#7344" class="Bound"
      >m</a
      ><a name="7362"
      > </a
      ><a name="7363" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="7364"
      > </a
      ><a name="7365" href="DependentEquality.html#7346" class="Bound"
      >n</a
      ><a name="7366"
      > </a
      ><a name="7367" class="Symbol"
      >&#8594;</a
      ><a name="7368"
      > </a
      ><a name="7369" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="7372"
      > </a
      ><a name="7373" href="DependentEquality.html#7342" class="Bound"
      >X</a
      ><a name="7374"
      > </a
      ><a name="7375" href="DependentEquality.html#7346" class="Bound"
      >n</a
      ><a name="7376"
      > </a
      ><a name="7377" class="Symbol"
      >&#8594;</a
      ><a name="7378"
      > </a
      ><a name="7379" class="PrimitiveType"
      >Set</a
      ><a name="7382"
      >
</a
      ><a name="7383" href="DependentEquality.html#7383" class="Bound"
      >xs</a
      ><a name="7385"
      > </a
      ><a name="7386" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="7388"
      > </a
      ><a name="7389" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="7393"
      > </a
      ><a name="7394" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="7395"
      > </a
      ><a name="7396" href="DependentEquality.html#7396" class="Bound"
      >ys</a
      ><a name="7398"
      >   </a
      ><a name="7401" class="Symbol"
      >=</a
      ><a name="7402"
      >   </a
      ><a name="7405" href="DependentEquality.html#7383" class="Bound"
      >xs</a
      ><a name="7407"
      > </a
      ><a name="7408" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="7409"
      > </a
      ><a name="7410" href="DependentEquality.html#7396" class="Bound"
      >ys</a
      ><a name="7412"
      >

\end{code}

</a
      ><a name="7426" class="Comment"
      >Later we will generalize the above definition, because it actually has</a
      ><a name="7496"
      >
</a
      ><a name="7497" class="Comment"
      >little to do with vectors and is useful in many other similar</a
      ><a name="7558"
      >
</a
      ><a name="7559" class="Comment"
      >situations (which we will not explore in these notes).</a
      ><a name="7613"
      >

</a
      ><a name="7615" class="Comment"
      >The following generalizes our cong function to this situation, but</a
      ><a name="7681"
      >
</a
      ><a name="7682" class="Comment"
      >here we only consider the situation where the parameter to cong is</a
      ><a name="7748"
      >
</a
      ><a name="7749" class="Comment"
      >the &quot;cons&quot; function &#955; ws &#8594; x &#8759; ws, which is what we needed above in</a
      ><a name="7816"
      >
</a
      ><a name="7817" class="Comment"
      >order to prove associativity of list concatenation, and which we will</a
      ><a name="7886"
      >
</a
      ><a name="7887" class="Comment"
      >need again to prove associativity of vector concatenation:</a
      ><a name="7945"
      >

\begin{code}

</a
      ><a name="7961" href="DependentEquality.html#7961" class="Function"
      >cong-cons</a
      ><a name="7970"
      > </a
      ><a name="7971" class="Symbol"
      >:</a
      ><a name="7972"
      > </a
      ><a name="7973" class="Symbol"
      >&#8704;{</a
      ><a name="7975" href="DependentEquality.html#7975" class="Bound"
      >X</a
      ><a name="7976"
      > </a
      ><a name="7977" href="DependentEquality.html#7977" class="Bound"
      >m</a
      ><a name="7978"
      > </a
      ><a name="7979" href="DependentEquality.html#7979" class="Bound"
      >n</a
      ><a name="7980" class="Symbol"
      >}</a
      ><a name="7981"
      > </a
      ><a name="7982" class="Symbol"
      >(</a
      ><a name="7983" href="DependentEquality.html#7983" class="Bound"
      >x</a
      ><a name="7984"
      > </a
      ><a name="7985" class="Symbol"
      >:</a
      ><a name="7986"
      > </a
      ><a name="7987" href="DependentEquality.html#7975" class="Bound"
      >X</a
      ><a name="7988" class="Symbol"
      >)</a
      ><a name="7989"
      > </a
      ><a name="7990" class="Symbol"
      >{</a
      ><a name="7991" href="DependentEquality.html#7991" class="Bound"
      >xs</a
      ><a name="7993"
      > </a
      ><a name="7994" class="Symbol"
      >:</a
      ><a name="7995"
      > </a
      ><a name="7996" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="7999"
      > </a
      ><a name="8000" href="DependentEquality.html#7975" class="Bound"
      >X</a
      ><a name="8001"
      > </a
      ><a name="8002" href="DependentEquality.html#7977" class="Bound"
      >m</a
      ><a name="8003" class="Symbol"
      >}</a
      ><a name="8004"
      > </a
      ><a name="8005" class="Symbol"
      >{</a
      ><a name="8006" href="DependentEquality.html#8006" class="Bound"
      >ys</a
      ><a name="8008"
      > </a
      ><a name="8009" class="Symbol"
      >:</a
      ><a name="8010"
      > </a
      ><a name="8011" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="8014"
      > </a
      ><a name="8015" href="DependentEquality.html#7975" class="Bound"
      >X</a
      ><a name="8016"
      > </a
      ><a name="8017" href="DependentEquality.html#7979" class="Bound"
      >n</a
      ><a name="8018" class="Symbol"
      >}</a
      ><a name="8019"
      > </a
      ><a name="8020" class="Symbol"
      >(</a
      ><a name="8021" href="DependentEquality.html#8021" class="Bound"
      >p</a
      ><a name="8022"
      > </a
      ><a name="8023" class="Symbol"
      >:</a
      ><a name="8024"
      > </a
      ><a name="8025" href="DependentEquality.html#7977" class="Bound"
      >m</a
      ><a name="8026"
      > </a
      ><a name="8027" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="8028"
      > </a
      ><a name="8029" href="DependentEquality.html#7979" class="Bound"
      >n</a
      ><a name="8030" class="Symbol"
      >)</a
      ><a name="8031"
      >
          </a
      ><a name="8042" class="Symbol"
      >&#8594;</a
      ><a name="8043"
      > </a
      ><a name="8044" href="DependentEquality.html#7991" class="Bound"
      >xs</a
      ><a name="8046"
      > </a
      ><a name="8047" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="8049"
      > </a
      ><a name="8050" href="DependentEquality.html#8021" class="Bound"
      >p</a
      ><a name="8051"
      > </a
      ><a name="8052" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="8053"
      > </a
      ><a name="8054" href="DependentEquality.html#8006" class="Bound"
      >ys</a
      ><a name="8056"
      > </a
      ><a name="8057" class="Symbol"
      >&#8594;</a
      ><a name="8058"
      > </a
      ><a name="8059" href="DependentEquality.html#7983" class="Bound"
      >x</a
      ><a name="8060"
      > </a
      ><a name="8061" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="8062"
      > </a
      ><a name="8063" href="DependentEquality.html#7991" class="Bound"
      >xs</a
      ><a name="8065"
      >  </a
      ><a name="8067" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="8069"
      > </a
      ><a name="8070" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="8074"
      > </a
      ><a name="8075" class="InductiveConstructor"
      >succ</a
      ><a name="8079"
      > </a
      ><a name="8080" href="DependentEquality.html#8021" class="Bound"
      >p</a
      ><a name="8081"
      > </a
      ><a name="8082" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="8083"
      >  </a
      ><a name="8085" href="DependentEquality.html#7983" class="Bound"
      >x</a
      ><a name="8086"
      > </a
      ><a name="8087" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="8088"
      > </a
      ><a name="8089" href="DependentEquality.html#8006" class="Bound"
      >ys</a
      ><a name="8091"
      >
</a
      ><a name="8092" href="DependentEquality.html#7961" class="Function"
      >cong-cons</a
      ><a name="8101"
      > </a
      ><a name="8102" class="Symbol"
      >_</a
      ><a name="8103"
      > </a
      ><a name="8104" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="8108"
      > </a
      ><a name="8109" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="8113"
      > </a
      ><a name="8114" class="Symbol"
      >=</a
      ><a name="8115"
      > </a
      ><a name="8116" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="8120"
      >

\end{code}

</a
      ><a name="8135" class="Comment"
      >Notice that if p : m &#8801; n, then cong succ p : succ m &#8801; succ n, and that</a
      ><a name="8205"
      >
</a
      ><a name="8206" class="Comment"
      >if</a
      ><a name="8208"
      >

</a
      ><a name="8210" class="Comment"
      >  xs : Vec X m and ys : Vec X n</a
      ><a name="8241"
      >

</a
      ><a name="8243" class="Comment"
      >then</a
      ><a name="8247"
      >

</a
      ><a name="8249" class="Comment"
      >  x &#8759; xs : Vec X (succ m) and x &#8759; ys : Vec X (succ n).</a
      ><a name="8303"
      >

</a
      ><a name="8305" class="Comment"
      >This is why from</a
      ><a name="8321"
      >

</a
      ><a name="8323" class="Comment"
      >  xs &#8801;[ p ] ys</a
      ><a name="8337"
      >

</a
      ><a name="8339" class="Comment"
      >we get</a
      ><a name="8345"
      >

</a
      ><a name="8347" class="Comment"
      >  x &#8759; xs &#8801;[ cong succ p ] x &#8759; ys</a
      ><a name="8379"
      >

</a
      ><a name="8381" class="Comment"
      >in the above definition.</a
      ><a name="8405"
      >

</a
      ><a name="8407" class="Comment"
      >So what we want to prove is that</a
      ><a name="8439"
      >

</a
      ><a name="8441" class="Comment"
      >  (xs ++ ys) ++ zs  &#8801;[ p ]  xs ++ (ys ++ zs)</a
      ><a name="8485"
      >

</a
      ><a name="8487" class="Comment"
      >for a suitable p : (l + m) + n &#8801; l + (m + n), which we can take to be</a
      ><a name="8556"
      >
</a
      ><a name="8557" class="Comment"
      >+-assoc l m n. </a
      ><a name="8572"
      >

</a
      ><a name="8574" class="Comment"
      >This statement does type check, and its proof is essentially the same</a
      ><a name="8643"
      >
</a
      ><a name="8644" class="Comment"
      >as that for the case of lists, recalled above. The crucial thing is</a
      ><a name="8711"
      >
</a
      ><a name="8712" class="Comment"
      >that now we need to use the fact that addition of natural numbers is</a
      ><a name="8780"
      >
</a
      ><a name="8781" class="Comment"
      >associative, as discussed above.</a
      ><a name="8813"
      >

</a
      ><a name="8815" class="Comment"
      >And with these remarks we are done. Here is the formulation and proof</a
      ><a name="8884"
      >
</a
      ><a name="8885" class="Comment"
      >that vector concatenation is associative:</a
      ><a name="8926"
      >

\begin{code}

</a
      ><a name="8942" href="DependentEquality.html#8942" class="Function"
      >++-assoc</a
      ><a name="8950"
      > </a
      ><a name="8951" class="Symbol"
      >:</a
      ><a name="8952"
      > </a
      ><a name="8953" class="Symbol"
      >&#8704;{</a
      ><a name="8955" href="DependentEquality.html#8955" class="Bound"
      >X</a
      ><a name="8956" class="Symbol"
      >}</a
      ><a name="8957"
      > </a
      ><a name="8958" href="DependentEquality.html#8958" class="Bound"
      >l</a
      ><a name="8959"
      > </a
      ><a name="8960" href="DependentEquality.html#8960" class="Bound"
      >m</a
      ><a name="8961"
      > </a
      ><a name="8962" href="DependentEquality.html#8962" class="Bound"
      >n</a
      ><a name="8963"
      > </a
      ><a name="8964" class="Symbol"
      >(</a
      ><a name="8965" href="DependentEquality.html#8965" class="Bound"
      >xs</a
      ><a name="8967"
      > </a
      ><a name="8968" class="Symbol"
      >:</a
      ><a name="8969"
      > </a
      ><a name="8970" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="8973"
      > </a
      ><a name="8974" href="DependentEquality.html#8955" class="Bound"
      >X</a
      ><a name="8975"
      > </a
      ><a name="8976" href="DependentEquality.html#8958" class="Bound"
      >l</a
      ><a name="8977" class="Symbol"
      >)</a
      ><a name="8978"
      > </a
      ><a name="8979" class="Symbol"
      >(</a
      ><a name="8980" href="DependentEquality.html#8980" class="Bound"
      >ys</a
      ><a name="8982"
      > </a
      ><a name="8983" class="Symbol"
      >:</a
      ><a name="8984"
      > </a
      ><a name="8985" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="8988"
      > </a
      ><a name="8989" href="DependentEquality.html#8955" class="Bound"
      >X</a
      ><a name="8990"
      > </a
      ><a name="8991" href="DependentEquality.html#8960" class="Bound"
      >m</a
      ><a name="8992" class="Symbol"
      >)</a
      ><a name="8993"
      > </a
      ><a name="8994" class="Symbol"
      >(</a
      ><a name="8995" href="DependentEquality.html#8995" class="Bound"
      >zs</a
      ><a name="8997"
      > </a
      ><a name="8998" class="Symbol"
      >:</a
      ><a name="8999"
      > </a
      ><a name="9000" href="DependentEquality.html#3840" class="Datatype"
      >Vec</a
      ><a name="9003"
      > </a
      ><a name="9004" href="DependentEquality.html#8955" class="Bound"
      >X</a
      ><a name="9005"
      > </a
      ><a name="9006" href="DependentEquality.html#8962" class="Bound"
      >n</a
      ><a name="9007" class="Symbol"
      >)</a
      ><a name="9008"
      >
         </a
      ><a name="9018" class="Symbol"
      >&#8594;</a
      ><a name="9019"
      > </a
      ><a name="9020" class="Symbol"
      >(</a
      ><a name="9021" href="DependentEquality.html#8965" class="Bound"
      >xs</a
      ><a name="9023"
      > </a
      ><a name="9024" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9026"
      > </a
      ><a name="9027" href="DependentEquality.html#8980" class="Bound"
      >ys</a
      ><a name="9029" class="Symbol"
      >)</a
      ><a name="9030"
      > </a
      ><a name="9031" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9033"
      > </a
      ><a name="9034" href="DependentEquality.html#8995" class="Bound"
      >zs</a
      ><a name="9036"
      >  </a
      ><a name="9038" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="9040"
      > </a
      ><a name="9041" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="9048"
      > </a
      ><a name="9049" href="DependentEquality.html#8958" class="Bound"
      >l</a
      ><a name="9050"
      > </a
      ><a name="9051" href="DependentEquality.html#8960" class="Bound"
      >m</a
      ><a name="9052"
      > </a
      ><a name="9053" href="DependentEquality.html#8962" class="Bound"
      >n</a
      ><a name="9054"
      > </a
      ><a name="9055" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="9056"
      >  </a
      ><a name="9058" href="DependentEquality.html#8965" class="Bound"
      >xs</a
      ><a name="9060"
      > </a
      ><a name="9061" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9063"
      > </a
      ><a name="9064" class="Symbol"
      >(</a
      ><a name="9065" href="DependentEquality.html#8980" class="Bound"
      >ys</a
      ><a name="9067"
      > </a
      ><a name="9068" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9070"
      > </a
      ><a name="9071" href="DependentEquality.html#8995" class="Bound"
      >zs</a
      ><a name="9073" class="Symbol"
      >)</a
      ><a name="9074"
      >
</a
      ><a name="9075" href="DependentEquality.html#8942" class="Function"
      >++-assoc</a
      ><a name="9083"
      > </a
      ><a name="9084" href="DependentEquality.html#3174" class="InductiveConstructor"
      >zero</a
      ><a name="9088"
      >     </a
      ><a name="9093" href="DependentEquality.html#9093" class="Bound"
      >m</a
      ><a name="9094"
      > </a
      ><a name="9095" href="DependentEquality.html#9095" class="Bound"
      >n</a
      ><a name="9096"
      > </a
      ><a name="9097" href="DependentEquality.html#3872" class="InductiveConstructor"
      >[]</a
      ><a name="9099"
      >       </a
      ><a name="9106" href="DependentEquality.html#9106" class="Bound"
      >ys</a
      ><a name="9108"
      > </a
      ><a name="9109" href="DependentEquality.html#9109" class="Bound"
      >zs</a
      ><a name="9111"
      > </a
      ><a name="9112" class="Symbol"
      >=</a
      ><a name="9113"
      > </a
      ><a name="9114" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="9118"
      >
</a
      ><a name="9119" href="DependentEquality.html#8942" class="Function"
      >++-assoc</a
      ><a name="9127"
      > </a
      ><a name="9128" class="Symbol"
      >(</a
      ><a name="9129" href="DependentEquality.html#3184" class="InductiveConstructor"
      >succ</a
      ><a name="9133"
      > </a
      ><a name="9134" href="DependentEquality.html#9134" class="Bound"
      >l</a
      ><a name="9135" class="Symbol"
      >)</a
      ><a name="9136"
      > </a
      ><a name="9137" href="DependentEquality.html#9137" class="Bound"
      >m</a
      ><a name="9138"
      > </a
      ><a name="9139" href="DependentEquality.html#9139" class="Bound"
      >n</a
      ><a name="9140"
      > </a
      ><a name="9141" class="Symbol"
      >(</a
      ><a name="9142" href="DependentEquality.html#9142" class="Bound"
      >x</a
      ><a name="9143"
      > </a
      ><a name="9144" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="9145"
      > </a
      ><a name="9146" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9148" class="Symbol"
      >)</a
      ><a name="9149"
      > </a
      ><a name="9150" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9152"
      > </a
      ><a name="9153" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9155"
      > </a
      ><a name="9156" class="Symbol"
      >=</a
      ><a name="9157"
      > </a
      ><a name="9158" href="DependentEquality.html#9265" class="Function"
      >goal</a
      ><a name="9162"
      >
 </a
      ><a name="9164" class="Keyword"
      >where</a
      ><a name="9169"
      >
  </a
      ><a name="9172" href="DependentEquality.html#9172" class="Function"
      >IH</a
      ><a name="9174"
      > </a
      ><a name="9175" class="Symbol"
      >:</a
      ><a name="9176"
      > </a
      ><a name="9177" class="Symbol"
      >(</a
      ><a name="9178" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9180"
      > </a
      ><a name="9181" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9183"
      > </a
      ><a name="9184" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9186" class="Symbol"
      >)</a
      ><a name="9187"
      > </a
      ><a name="9188" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9190"
      > </a
      ><a name="9191" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9193"
      >  </a
      ><a name="9195" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="9197"
      > </a
      ><a name="9198" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="9205"
      > </a
      ><a name="9206" href="DependentEquality.html#9134" class="Bound"
      >l</a
      ><a name="9207"
      > </a
      ><a name="9208" href="DependentEquality.html#9137" class="Bound"
      >m</a
      ><a name="9209"
      > </a
      ><a name="9210" href="DependentEquality.html#9139" class="Bound"
      >n</a
      ><a name="9211"
      > </a
      ><a name="9212" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="9213"
      >  </a
      ><a name="9215" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9217"
      > </a
      ><a name="9218" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9220"
      > </a
      ><a name="9221" class="Symbol"
      >(</a
      ><a name="9222" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9224"
      > </a
      ><a name="9225" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9227"
      > </a
      ><a name="9228" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9230" class="Symbol"
      >)</a
      ><a name="9231"
      >
  </a
      ><a name="9234" href="DependentEquality.html#9172" class="Function"
      >IH</a
      ><a name="9236"
      > </a
      ><a name="9237" class="Symbol"
      >=</a
      ><a name="9238"
      > </a
      ><a name="9239" href="DependentEquality.html#8942" class="Function"
      >++-assoc</a
      ><a name="9247"
      > </a
      ><a name="9248" href="DependentEquality.html#9134" class="Bound"
      >l</a
      ><a name="9249"
      > </a
      ><a name="9250" href="DependentEquality.html#9137" class="Bound"
      >m</a
      ><a name="9251"
      > </a
      ><a name="9252" href="DependentEquality.html#9139" class="Bound"
      >n</a
      ><a name="9253"
      > </a
      ><a name="9254" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9256"
      > </a
      ><a name="9257" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9259"
      > </a
      ><a name="9260" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9262"
      >
  </a
      ><a name="9265" href="DependentEquality.html#9265" class="Function"
      >goal</a
      ><a name="9269"
      > </a
      ><a name="9270" class="Symbol"
      >:</a
      ><a name="9271"
      > </a
      ><a name="9272" href="DependentEquality.html#9142" class="Bound"
      >x</a
      ><a name="9273"
      > </a
      ><a name="9274" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="9275"
      > </a
      ><a name="9276" class="Symbol"
      >((</a
      ><a name="9278" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9280"
      > </a
      ><a name="9281" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9283"
      > </a
      ><a name="9284" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9286" class="Symbol"
      >)</a
      ><a name="9287"
      > </a
      ><a name="9288" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9290"
      > </a
      ><a name="9291" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9293" class="Symbol"
      >)</a
      ><a name="9294"
      >  </a
      ><a name="9296" href="DependentEquality.html#7331" class="Function Operator"
      >&#8801;[</a
      ><a name="9298"
      > </a
      ><a name="9299" href="DependentEquality.html#2107" class="Function"
      >cong</a
      ><a name="9303"
      > </a
      ><a name="9304" class="InductiveConstructor"
      >succ</a
      ><a name="9308"
      > </a
      ><a name="9309" class="Symbol"
      >(</a
      ><a name="9310" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="9317"
      > </a
      ><a name="9318" href="DependentEquality.html#9134" class="Bound"
      >l</a
      ><a name="9319"
      > </a
      ><a name="9320" href="DependentEquality.html#9137" class="Bound"
      >m</a
      ><a name="9321"
      > </a
      ><a name="9322" href="DependentEquality.html#9139" class="Bound"
      >n</a
      ><a name="9323" class="Symbol"
      >)</a
      ><a name="9324"
      > </a
      ><a name="9325" href="DependentEquality.html#7331" class="Function Operator"
      >]</a
      ><a name="9326"
      >
         </a
      ><a name="9336" href="DependentEquality.html#9142" class="Bound"
      >x</a
      ><a name="9337"
      > </a
      ><a name="9338" href="DependentEquality.html#3891" class="InductiveConstructor Operator"
      >&#8759;</a
      ><a name="9339"
      > </a
      ><a name="9340" class="Symbol"
      >(</a
      ><a name="9341" href="DependentEquality.html#9146" class="Bound"
      >xs</a
      ><a name="9343"
      > </a
      ><a name="9344" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9346"
      > </a
      ><a name="9347" class="Symbol"
      >(</a
      ><a name="9348" href="DependentEquality.html#9150" class="Bound"
      >ys</a
      ><a name="9350"
      > </a
      ><a name="9351" href="DependentEquality.html#5013" class="Function Operator"
      >++</a
      ><a name="9353"
      > </a
      ><a name="9354" href="DependentEquality.html#9153" class="Bound"
      >zs</a
      ><a name="9356" class="Symbol"
      >))</a
      ><a name="9358"
      >
  </a
      ><a name="9361" href="DependentEquality.html#9265" class="Function"
      >goal</a
      ><a name="9365"
      > </a
      ><a name="9366" class="Symbol"
      >=</a
      ><a name="9367"
      > </a
      ><a name="9368" href="DependentEquality.html#7961" class="Function"
      >cong-cons</a
      ><a name="9377"
      > </a
      ><a name="9378" href="DependentEquality.html#9142" class="Bound"
      >x</a
      ><a name="9379"
      > </a
      ><a name="9380" class="Symbol"
      >(</a
      ><a name="9381" href="DependentEquality.html#3255" class="Function"
      >+-assoc</a
      ><a name="9388"
      > </a
      ><a name="9389" href="DependentEquality.html#9134" class="Bound"
      >l</a
      ><a name="9390"
      > </a
      ><a name="9391" href="DependentEquality.html#9137" class="Bound"
      >m</a
      ><a name="9392"
      > </a
      ><a name="9393" href="DependentEquality.html#9139" class="Bound"
      >n</a
      ><a name="9394" class="Symbol"
      >)</a
      ><a name="9395"
      > </a
      ><a name="9396" href="DependentEquality.html#9172" class="Function"
      >IH</a
      ><a name="9398"
      >

\end{code}

</a
      ><a name="9412" class="Comment"
      >If you have begun to understand these subtleties, then I have achieved</a
      ><a name="9482"
      >
</a
      ><a name="9483" class="Comment"
      >my learning objective.</a
      ><a name="9505"
      >

</a
      ><a name="9507" class="Comment"
      >Dependent equality more generally</a
      ><a name="9540"
      >
</a
      ><a name="9541" class="Comment"
      >=================================</a
      ><a name="9574"
      >

</a
      ><a name="9576" class="Comment"
      >But, to conclude, I am a little bit more ambitious.</a
      ><a name="9627"
      >

</a
      ><a name="9629" class="Comment"
      >We want to briefly generalize the above. Notice that</a
      ><a name="9681"
      >

</a
      ><a name="9683" class="Comment"
      >  Vec X : &#8469; &#8594; Set.</a
      ><a name="9701"
      >

</a
      ><a name="9703" class="Comment"
      >We replace &quot;Vec X&quot; by an arbitrary &quot;B&quot;, and &quot;&#8469;&quot; by an arbitrary &quot;A&quot;:</a
      ><a name="9771"
      >

</a
      ><a name="9773" class="Comment"
      >  A : Set,</a
      ><a name="9783"
      >
</a
      ><a name="9784" class="Comment"
      >  B : A &#8594; Set.</a
      ><a name="9798"
      >

</a
      ><a name="9800" class="Comment"
      >Then B is a family of sets indexed by A. In our main example,</a
      ><a name="9861"
      >

</a
      ><a name="9863" class="Comment"
      >  A = &#8469;,</a
      ><a name="9871"
      >
</a
      ><a name="9872" class="Comment"
      >  B = Vec X.</a
      ><a name="9884"
      >

</a
      ><a name="9886" class="Comment"
      >Our generalized dependent equality is</a
      ><a name="9923"
      >

</a
      ><a name="9925" class="Comment"
      >  b&#8320; &#8801;&#10214; p &#10215; b&#8321;</a
      ><a name="9939"
      >

</a
      ><a name="9941" class="Comment"
      >for</a
      ><a name="9944"
      >

</a
      ><a name="9946" class="Comment"
      >  a&#8320; a&#8321; : A,</a
      ><a name="9958"
      >
</a
      ><a name="9959" class="Comment"
      >     p  : a&#8320; &#8801; a&#8321;,</a
      ><a name="9977"
      >
</a
      ><a name="9978" class="Comment"
      >     b&#8320; : B a&#8320;,</a
      ><a name="9993"
      >
</a
      ><a name="9994" class="Comment"
      >     b&#8321; : B a&#8321;.</a
      ><a name="10009"
      >

</a
      ><a name="10011" class="Comment"
      >The types are more general, but the definition is the same as in the</a
      ><a name="10079"
      >
</a
      ><a name="10080" class="Comment"
      >particular case:</a
      ><a name="10096"
      >

\begin{code}

</a
      ><a name="10112" href="DependentEquality.html#10112" class="Function Operator"
      >_&#8801;&#10214;_&#10215;_</a
      ><a name="10118"
      > </a
      ><a name="10119" class="Symbol"
      >:</a
      ><a name="10120"
      > </a
      ><a name="10121" class="Symbol"
      >{</a
      ><a name="10122" href="DependentEquality.html#10122" class="Bound"
      >A</a
      ><a name="10123"
      > </a
      ><a name="10124" class="Symbol"
      >:</a
      ><a name="10125"
      > </a
      ><a name="10126" class="PrimitiveType"
      >Set</a
      ><a name="10129" class="Symbol"
      >}</a
      ><a name="10130"
      > </a
      ><a name="10131" class="Symbol"
      >{</a
      ><a name="10132" href="DependentEquality.html#10132" class="Bound"
      >B</a
      ><a name="10133"
      > </a
      ><a name="10134" class="Symbol"
      >:</a
      ><a name="10135"
      > </a
      ><a name="10136" href="DependentEquality.html#10122" class="Bound"
      >A</a
      ><a name="10137"
      > </a
      ><a name="10138" class="Symbol"
      >&#8594;</a
      ><a name="10139"
      > </a
      ><a name="10140" class="PrimitiveType"
      >Set</a
      ><a name="10143" class="Symbol"
      >}</a
      ><a name="10144"
      > </a
      ><a name="10145" class="Symbol"
      >{</a
      ><a name="10146" href="DependentEquality.html#10146" class="Bound"
      >a&#8320;</a
      ><a name="10148"
      > </a
      ><a name="10149" href="DependentEquality.html#10149" class="Bound"
      >a&#8321;</a
      ><a name="10151"
      > </a
      ><a name="10152" class="Symbol"
      >:</a
      ><a name="10153"
      > </a
      ><a name="10154" href="DependentEquality.html#10122" class="Bound"
      >A</a
      ><a name="10155" class="Symbol"
      >}</a
      ><a name="10156"
      >
       </a
      ><a name="10164" class="Symbol"
      >&#8594;</a
      ><a name="10165"
      > </a
      ><a name="10166" href="DependentEquality.html#10132" class="Bound"
      >B</a
      ><a name="10167"
      > </a
      ><a name="10168" href="DependentEquality.html#10146" class="Bound"
      >a&#8320;</a
      ><a name="10170"
      > </a
      ><a name="10171" class="Symbol"
      >&#8594;</a
      ><a name="10172"
      > </a
      ><a name="10173" href="DependentEquality.html#10146" class="Bound"
      >a&#8320;</a
      ><a name="10175"
      > </a
      ><a name="10176" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="10177"
      > </a
      ><a name="10178" href="DependentEquality.html#10149" class="Bound"
      >a&#8321;</a
      ><a name="10180"
      > </a
      ><a name="10181" class="Symbol"
      >&#8594;</a
      ><a name="10182"
      > </a
      ><a name="10183" href="DependentEquality.html#10132" class="Bound"
      >B</a
      ><a name="10184"
      > </a
      ><a name="10185" href="DependentEquality.html#10149" class="Bound"
      >a&#8321;</a
      ><a name="10187"
      > </a
      ><a name="10188" class="Symbol"
      >&#8594;</a
      ><a name="10189"
      > </a
      ><a name="10190" class="PrimitiveType"
      >Set</a
      ><a name="10193"
      >
</a
      ><a name="10194" href="DependentEquality.html#10194" class="Bound"
      >b&#8320;</a
      ><a name="10196"
      > </a
      ><a name="10197" href="DependentEquality.html#10112" class="Function Operator"
      >&#8801;&#10214;</a
      ><a name="10199"
      > </a
      ><a name="10200" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="10204"
      > </a
      ><a name="10205" href="DependentEquality.html#10112" class="Function Operator"
      >&#10215;</a
      ><a name="10206"
      > </a
      ><a name="10207" href="DependentEquality.html#10207" class="Bound"
      >b&#8321;</a
      ><a name="10209"
      >   </a
      ><a name="10212" class="Symbol"
      >=</a
      ><a name="10213"
      >   </a
      ><a name="10216" href="DependentEquality.html#10194" class="Bound"
      >b&#8320;</a
      ><a name="10218"
      > </a
      ><a name="10219" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="10220"
      > </a
      ><a name="10221" href="DependentEquality.html#10207" class="Bound"
      >b&#8321;</a
      ><a name="10223"
      >

\end{code}

</a
      ><a name="10237" class="Comment"
      >We then generalize cong defined above to a dependent version:</a
      ><a name="10298"
      >

\begin{code}

</a
      ><a name="10314" href="DependentEquality.html#10314" class="Function"
      >congd</a
      ><a name="10319"
      > </a
      ><a name="10320" class="Symbol"
      >:</a
      ><a name="10321"
      > </a
      ><a name="10322" class="Symbol"
      >{</a
      ><a name="10323" href="DependentEquality.html#10323" class="Bound"
      >A</a
      ><a name="10324"
      > </a
      ><a name="10325" class="Symbol"
      >:</a
      ><a name="10326"
      > </a
      ><a name="10327" class="PrimitiveType"
      >Set</a
      ><a name="10330" class="Symbol"
      >}</a
      ><a name="10331"
      > </a
      ><a name="10332" class="Symbol"
      >{</a
      ><a name="10333" href="DependentEquality.html#10333" class="Bound"
      >B</a
      ><a name="10334"
      > </a
      ><a name="10335" class="Symbol"
      >:</a
      ><a name="10336"
      > </a
      ><a name="10337" href="DependentEquality.html#10323" class="Bound"
      >A</a
      ><a name="10338"
      > </a
      ><a name="10339" class="Symbol"
      >&#8594;</a
      ><a name="10340"
      > </a
      ><a name="10341" class="PrimitiveType"
      >Set</a
      ><a name="10344" class="Symbol"
      >}</a
      ><a name="10345"
      > </a
      ><a name="10346" class="Symbol"
      >(</a
      ><a name="10347" href="DependentEquality.html#10347" class="Bound"
      >f</a
      ><a name="10348"
      > </a
      ><a name="10349" class="Symbol"
      >:</a
      ><a name="10350"
      > </a
      ><a name="10351" class="Symbol"
      >(</a
      ><a name="10352" href="DependentEquality.html#10352" class="Bound"
      >a</a
      ><a name="10353"
      > </a
      ><a name="10354" class="Symbol"
      >:</a
      ><a name="10355"
      > </a
      ><a name="10356" href="DependentEquality.html#10323" class="Bound"
      >A</a
      ><a name="10357" class="Symbol"
      >)</a
      ><a name="10358"
      > </a
      ><a name="10359" class="Symbol"
      >&#8594;</a
      ><a name="10360"
      > </a
      ><a name="10361" href="DependentEquality.html#10333" class="Bound"
      >B</a
      ><a name="10362"
      > </a
      ><a name="10363" href="DependentEquality.html#10352" class="Bound"
      >a</a
      ><a name="10364" class="Symbol"
      >)</a
      ><a name="10365"
      > </a
      ><a name="10366" class="Symbol"
      >{</a
      ><a name="10367" href="DependentEquality.html#10367" class="Bound"
      >a&#8320;</a
      ><a name="10369"
      > </a
      ><a name="10370" href="DependentEquality.html#10370" class="Bound"
      >a&#8321;</a
      ><a name="10372"
      > </a
      ><a name="10373" class="Symbol"
      >:</a
      ><a name="10374"
      > </a
      ><a name="10375" href="DependentEquality.html#10323" class="Bound"
      >A</a
      ><a name="10376" class="Symbol"
      >}</a
      ><a name="10377"
      >
     </a
      ><a name="10383" class="Symbol"
      >&#8594;</a
      ><a name="10384"
      > </a
      ><a name="10385" class="Symbol"
      >(</a
      ><a name="10386" href="DependentEquality.html#10386" class="Bound"
      >p</a
      ><a name="10387"
      > </a
      ><a name="10388" class="Symbol"
      >:</a
      ><a name="10389"
      > </a
      ><a name="10390" href="DependentEquality.html#10367" class="Bound"
      >a&#8320;</a
      ><a name="10392"
      > </a
      ><a name="10393" href="DependentEquality.html#2048" class="Datatype Operator"
      >&#8801;</a
      ><a name="10394"
      > </a
      ><a name="10395" href="DependentEquality.html#10370" class="Bound"
      >a&#8321;</a
      ><a name="10397" class="Symbol"
      >)</a
      ><a name="10398"
      > </a
      ><a name="10399" class="Symbol"
      >&#8594;</a
      ><a name="10400"
      > </a
      ><a name="10401" href="DependentEquality.html#10347" class="Bound"
      >f</a
      ><a name="10402"
      > </a
      ><a name="10403" href="DependentEquality.html#10367" class="Bound"
      >a&#8320;</a
      ><a name="10405"
      > </a
      ><a name="10406" href="DependentEquality.html#10112" class="Function Operator"
      >&#8801;&#10214;</a
      ><a name="10408"
      > </a
      ><a name="10409" href="DependentEquality.html#10386" class="Bound"
      >p</a
      ><a name="10410"
      > </a
      ><a name="10411" href="DependentEquality.html#10112" class="Function Operator"
      >&#10215;</a
      ><a name="10412"
      > </a
      ><a name="10413" href="DependentEquality.html#10347" class="Bound"
      >f</a
      ><a name="10414"
      > </a
      ><a name="10415" href="DependentEquality.html#10370" class="Bound"
      >a&#8321;</a
      ><a name="10417"
      >
</a
      ><a name="10418" href="DependentEquality.html#10314" class="Function"
      >congd</a
      ><a name="10423"
      > </a
      ><a name="10424" href="DependentEquality.html#10424" class="Bound"
      >f</a
      ><a name="10425"
      > </a
      ><a name="10426" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="10430"
      > </a
      ><a name="10431" class="Symbol"
      >=</a
      ><a name="10432"
      > </a
      ><a name="10433" href="DependentEquality.html#2083" class="InductiveConstructor"
      >refl</a
      ><a name="10437"
      >

\end{code}

</a
      ><a name="10451" class="Comment"
      >Conclusion</a
      ><a name="10461"
      >
</a
      ><a name="10462" class="Comment"
      >==========</a
      ><a name="10472"
      >

</a
      ><a name="10474" class="Comment"
      >Equality is subtler than it seems at first sight, but with the right</a
      ><a name="10542"
      >
</a
      ><a name="10543" class="Comment"
      >concepts and tools, and with practical experience, it becomes natural.</a
      ><a name="10613"
      >

</a
      ><a name="10615" class="Comment"
      >Of course there is much more to say, and the systematic study of</a
      ><a name="10679"
      >
</a
      ><a name="10680" class="Comment"
      >(dependent or independent) equality in dependent type theory is the</a
      ><a name="10747"
      >
</a
      ><a name="10748" class="Comment"
      >topic of &quot;univalent foundations&quot; or &quot;homotopy type theory&quot;, which is</a
      ><a name="10816"
      >
</a
      ><a name="10817" class="Comment"
      >beyond the scope of this module: https://homotopytypetheory.org/book</a
      ><a name="10885"
      >

</a
      ><a name="10887" class="Comment"
      >But in the past we have had successful reading groups and clubs with</a
      ><a name="10955"
      >
</a
      ><a name="10956" class="Comment"
      >undergrad, MSc, and PhD students, as well as with academic staff.</a
      ><a name="11021"
      >

</a
      ><a name="11023" class="Comment"
      >--------------------------------------------------------------------</a
      ><a name="11091"
      >
</a
      ><a name="11092" class="Comment"
      >Notational appendix. To complete our code so that it parses, we list</a
      ><a name="11160"
      >
</a
      ><a name="11161" class="Comment"
      >all fixities together for easy comparison of the operator precedences:</a
      ><a name="11231"
      >

\begin{code}

</a
      ><a name="11247" class="Keyword"
      >infixr</a
      ><a name="11253"
      > </a
      ><a name="11254" class="Number"
      >5</a
      ><a name="11255"
      > _&#8801;_
</a
      ><a name="11260" class="Keyword"
      >infixr</a
      ><a name="11266"
      > </a
      ><a name="11267" class="Number"
      >5</a
      ><a name="11268"
      > _&#8801;[_]_
</a
      ><a name="11276" class="Keyword"
      >infixr</a
      ><a name="11282"
      > </a
      ><a name="11283" class="Number"
      >5</a
      ><a name="11284"
      > _&#8801;&#10214;_&#10215;_
</a
      ><a name="11292" class="Keyword"
      >infixl</a
      ><a name="11298"
      > </a
      ><a name="11299" class="Number"
      >6</a
      ><a name="11300"
      > _++_
</a
      ><a name="11306" class="Keyword"
      >infixl</a
      ><a name="11312"
      > </a
      ><a name="11313" class="Number"
      >6</a
      ><a name="11314"
      > _+_
</a
      ><a name="11319" class="Keyword"
      >infixr</a
      ><a name="11325"
      > </a
      ><a name="11326" class="Number"
      >7</a
      ><a name="11327"
      > _&#8759;_

\end{code}
</a
      ></pre
    ></body
  ></html
>
