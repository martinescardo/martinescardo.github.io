<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>index</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">-- Martin Escardo, 3rd August 2015, last updated 5th August 2015</a>

<a id="67" class="Comment">{-
   A small type of propositions à la Voevodsky in Agda.

   (There is also a predicative version at
   http://www.cs.bham.ac.uk/~mhe/predicativity/)
-}</a>

<a id="223" class="Keyword">module</a> <a id="230" href="index.html" class="Module">index</a> <a id="236" class="Keyword">where</a>

<a id="243" class="Comment">{- 
   We use type-in-type to get an experimental implementation of
   impredicativity à la Voevodsky (propositional resizing) in Agda.

   Only the tiny module prop.agda needs to use type-in-type. All the
   other modules work without it.

   Because of limitations of Agda, or perhaps of our ability to exploit
   Agda, we can only resize from the second universe U₁=Set₁ to the
   first universe U=Set₀.

   A difference of this kind of impredicativity with CoC&#39;s
   impredicativity is that the &quot;axioms&quot; of unique choice and
   description hold. Our truth values are types with at most one
   element, and yet they are proof relevant in some sense.

   zip file with agda source available at
   http://www.cs.bham.ac.uk/~mhe/impredicativity/impredicativity.zip

   This type checks in Agda 2.4.2.2

   Click at a module name to navigate to it.
-}</a>

<a id="1094" class="Comment">{- 
   A truth value is a type together with a witness that it is a
   proposition. The following module defines the type Prp:U of truth
   values in U, which amounts to impredicativity. It is the only rogue
   module that uses type-in-type to define 

         Prp = Σ(P:U).isProp P 

   so that Prp:U.
-}</a>

<a id="1402" class="Keyword">open</a> <a id="1407" class="Keyword">import</a> <a id="1414" href="prop.html" class="Module">prop</a>

<a id="1420" class="Comment">{-
   NB. The option type-in-type is not inherited from prop.agda. For
   example, the following type checks with type-in-type, but fails to
   type check in this module, as it should:
-}</a>

<a id="1609" class="Comment">{- Fails to type check (good!):
set : Set
set = Set
-}</a>

<a id="1665" class="Comment">{-
   The type of propositions is a set, assuming functional and
   propositional extensionality:
-}</a>

<a id="1767" class="Keyword">open</a> <a id="1772" class="Keyword">import</a> <a id="1779" href="propisset.html" class="Module">propisset</a>

<a id="1790" class="Comment">{-
   Using impredicativity, we can define propositional truncation by
   universal quantification over truth values (as Voevodsky does):
-}</a>

<a id="1932" class="Keyword">open</a> <a id="1937" class="Keyword">import</a> <a id="1944" href="proptrunc.html" class="Module">proptrunc</a>

<a id="1955" class="Comment">{- 
   We then develop some amount of logic in the type Prp of
   propositions, where we define the logical connectives and their
   introduction and elimination rules following the ideas of the HoTT
   book. We then prove that

      false = ∀ r. r
      p ∧ q = ∀ r. (p ⇒ q ⇒ r) ⇒ r
      p ∨ q = ∀ r. (p ⇒ r) ⇒ (q ⇒ r) ⇒ r
      ∃ p   = ∀ r. (∀ x. p(x) ⇒ r) ⇒ r 
-}</a>

<a id="2325" class="Keyword">open</a> <a id="2330" class="Keyword">import</a> <a id="2337" href="logic.html" class="Module">logic</a>

<a id="2344" class="Comment">{- 
   We then prove the axiom of description: for any set X and any
   p:X→Prp,
    
       (∃! p) = true → Σ(x:X).p(x)=true.
-}</a>

<a id="2475" class="Keyword">open</a> <a id="2480" class="Keyword">import</a> <a id="2487" href="description.html" class="Module">description</a>

<a id="2500" class="Comment">{- We then get quotients (incomplete for the moment): -}</a>

<a id="2558" class="Keyword">open</a> <a id="2563" class="Keyword">import</a> <a id="2570" href="quotient.html" class="Module">quotient</a>


</pre></body></html>